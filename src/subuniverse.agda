--File: subuniverse.agda
--Author: William DeMeo
--Date: 10 Jan 2020
--Updated: 6 Feb 2020

{-# OPTIONS --without-K --exact-split #-}

open import Level

open import basic
open algebra
open signature

module subuniverse {‚Ñì : Level} {S : signature} where

open import preliminaries

open import Data.Empty
open import Data.Unit.Base using (‚ä§)
open import Data.Product
open import Data.Sum using (_‚äé_; [_,_])
open import Function
open import Relation.Unary
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_‚â°_; refl)
open import Data.Product using (Œ£; _,_; ‚àÉ; Œ£-syntax; ‚àÉ-syntax)

OpClosed : (A : algebra S) (B : Pred ‚ü¶ A ‚üß·µ§ ‚Ñì) -> Set ‚Ñì
OpClosed A B = ‚àÄ{ùì∏ : ‚ü® S ‚ü©‚Çí}
               (args : Fin (‚ü® S ‚ü©‚Çê ùì∏) -> ‚ü¶ A ‚üß·µ§) 
  ->           ‚àÄ(i : Fin (‚ü® S ‚ü©‚Çê ùì∏)) -> (args i) ‚àà B
              -------------------------------------------
  ->           (A ‚ü¶ ùì∏ ‚üß) args ‚àà B

record IsSubuniverse {A : algebra S} : Set (suc ‚Ñì) where

  field
    sset : Pred ‚ü¶ A ‚üß·µ§ ‚Ñì
    closed : OpClosed A sset    


--subalgebra type
record subalgebra (A : algebra S) : Set (suc ‚Ñì) where

  field

    subuniv : Pred ‚ü¶ A ‚üß·µ§ ‚Ñì
    _‚ü¶_‚üß : (ùì∏ : ‚ü® S ‚ü©‚Çí)
      ->   (args : Fin (‚ü® S ‚ü©‚Çê ùì∏) -> ‚ü¶ A ‚üß·µ§)
      ->   ( ‚àÄ(i : Fin (‚ü® S ‚ü©‚Çê ùì∏)) -> (args i) ‚àà subuniv )
         --------------------------------------------------
      ->   Set ‚Ñì
      
    closed : OpClosed A subuniv



open IsSubuniverse

SubAlgebra : (A : algebra S)
  ->         (B : IsSubuniverse {A})
           --------------------------
  ->         (subalgebra A)

SubAlgebra A B =
  record
    {
    subuniv = sset B ;
    _‚ü¶_‚üß = Œª ùì∏ args p -> (sset B) ((A ‚ü¶ ùì∏ ‚üß) args) ;
    closed = closed B
    }

-- Recall, Theorem 4.32 of Bergman.
-- Let A and B be algebras of type S. Then the following hold:
--
--   (1) For every n-ary term t and homomorphism g: A ‚Äî> B, 
--       g(t·¥¨(a‚ÇÅ,...,a‚Çô)) = t·¥Æ(g(a‚ÇÅ),...,g(a‚Çô)).
--   (2) For every term t ‚àà T(X) and every Œ∏ ‚àà Con(A), 
--       a Œ∏ b => t(a) Œ∏ t(b).
--   (3) For every subset Y of A,
--       Sg(Y) = { t(a‚ÇÅ,...,a‚Çô) : t ‚àà T(X‚Çô), n < œâ, and a·µ¢ ‚àà Y, for i ‚â§ n}.
--
-- (1) is proved in free.agda (see: comm-hom-term)
-- (2) is proved in free.agda (see: compatible-term and Compatible-Term)
--
-- PROOF of (3).
--
-- (3) For every subset Y of A,
--     Sg(Y) = { t(a‚ÇÅ,...,a‚Çô) : t ‚àà T(X‚Çô), n < œâ, and a·µ¢ ‚àà Y, for i ‚â§ n}.
--
-- _‚äÜ_ : ‚àÄ {‚Ñì‚ÇÉ ‚Ñì ‚Ñì‚ÇÇ} {Œ£ : signature} {A : Algebra {‚Ñì} {‚Ñì‚ÇÇ} Œ£} ‚Üí
--         Congruence {‚Ñì‚ÇÉ} A ‚Üí Congruence {‚Ñì‚ÇÉ} A ‚Üí Set _
-- Œ¶ ‚äÜ Œ® = ‚àÄ s ‚Üí (rel Œ¶ s) ‚áí (rel Œ® s)


--     -- subuniverse ------------------------------------------------
--     def Sub {ùî∏: algebra œÉ} (B‚ÇÄ: set ùî∏): Prop:=
--     ‚àÄ (f: Œ≤) (a: œÅ f ‚Üí ùî∏), (‚àÄ x, a x ‚àà B‚ÇÄ) ‚Üí (ùî∏.snd f a) ‚àà B‚ÇÄ
--        -- (N.B. ùî∏ f a ‚àà B‚ÇÄ  is syntactic sugar for  B‚ÇÄ (ùî∏ f a).)

--     -- is subalgebra? ---------------------------------------------
--     def is_subalgebra (ùî∏: algebra œÉ) 
--     (B‚ÇÄ: set ùî∏) (ùîπ: algebra_on œÉ B‚ÇÄ): Prop:= 
--     ‚àÄ f b, ‚Üë(ùîπ f b) = ùî∏.snd f ‚Üëb

--     -- subuniverse generated by X ---------------------------------
--     def Sg {ùî∏: algebra œÉ} (X: set ùî∏): set ùî∏:= 
--     ‚ãÇ‚ÇÄ {U | Sub U ‚àß X ‚äÜ U}

--     -- intersection introduction ----------------------------------
--     theorem Inter.intro {ùî∏: algebra œÉ} {x: ùî∏} {s: Œ≥ ‚Üí set ùî∏}: 
--     (‚àÄ i, x ‚àà s i) ‚Üí (x ‚àà ‚ãÇ i, s i) :=
--     assume h, iff.elim_right set.mem_Inter h

--     -- intersection elimination -------------------------------------
--     theorem Inter.elim {ùî∏: algebra œÉ} {x: ùî∏} {C: Œ≥ ‚Üí set ùî∏}: 
--     (x ‚àà ‚ãÇ i, C i) ‚Üí  (‚àÄ i, x ‚àà C i):= 
--     assume h, iff.elim_left set.mem_Inter h
    
--     -- Intersection of subuniverses is a subuniverse ---------------
--     lemma sub_of_sub_inter_sub {ùî∏: algebra œÉ} (C: Œ≥ ‚Üí set ùî∏): 
--     (‚àÄ i, Sub (C i)) ‚Üí Sub (‚ãÇi, C i):= 
--     assume h: (‚àÄ i, Sub (C i)), show Sub (‚ãÇi, C i), from
--     assume (f: Œ≤) (a: œÅ f ‚Üí ùî∏) (h‚ÇÅ: ‚àÄ x, a x ‚àà ‚ãÇi, C i),
--     show ùî∏.snd f a ‚àà ‚ãÇi, C i, from 
--       Inter.intro                -- x = (ùî∏ f a)
--       (Œª j, (h j) f a (Œª x, Inter.elim (h‚ÇÅ x) j))

--     -- X is a subset of Sg·¥¨(X) ----------------------------------------
--     lemma subset_X_of_SgX {ùî∏: algebra œÉ} (X : set ùî∏): X ‚äÜ Sg X:= 
--     assume x (h: x ‚àà X), 
--       show x ‚àà ‚ãÇ‚ÇÄ {U | Sub U ‚àß X ‚äÜ U}, from 
--         assume W (h‚ÇÅ: W ‚àà {U | Sub U ‚àß X ‚äÜ U}),  
--         show x ‚àà W, from 
--           have h‚ÇÇ: Sub W ‚àß X ‚äÜ W, from h‚ÇÅ, 
--         h‚ÇÇ.right h

--     -- A subuniverse that contains X also contains Sg·¥¨ X ------------------------
--     lemma sInter_mem {ùî∏: algebra œÉ} {X: set ùî∏}:
--     ‚àÄ R, Sub R ‚Üí X ‚äÜ R ‚Üí (Sg X ‚äÜ R) := 
--     assume R (h‚ÇÅ: Sub R) (h‚ÇÇ: X ‚äÜ R),
--     show Sg X ‚äÜ R, from 
--       assume x (h: x ‚àà Sg X), show x ‚àà R, from 
--         h R (and.intro h‚ÇÅ h‚ÇÇ)

--     lemma sInter_mem' {ùî∏: algebra œÉ} {X: set ùî∏}:
--     ‚àÄ R, Sub R ‚àß X ‚äÜ R ‚Üí (Sg X ‚äÜ R):= 
--     assume R (hc : Sub R ‚àß X ‚äÜ R),
--     have h‚ÇÅ: Sub R, from hc.left,
--     have h‚ÇÇ: X ‚äÜ R, from hc.right,
--     show Sg X ‚äÜ R, from 
--       assume x (h: x ‚àà Sg X), show x ‚àà R, from 
--         h R (and.intro h‚ÇÅ h‚ÇÇ)

--     lemma sInter_mem'' {ùî∏: algebra œÉ} {X: set ùî∏}:
--     ‚àÄ x, x ‚àà Sg X ‚Üí ‚àÄ R, Sub R ‚Üí X ‚äÜ R ‚Üí x ‚àà R:= 
--     assume x (h‚ÇÅ: x ‚àà Sg X) (R: set ùî∏) (h‚ÇÇ: Sub R) (h‚ÇÉ: X ‚äÜ R), 
--     show x ‚àà R, from h‚ÇÅ R (and.intro h‚ÇÇ h‚ÇÉ)

--     -- Sg·¥¨ X is a subuniverse of A --------------------------------------
--     lemma SgX_is_Sub {ùî∏: algebra œÉ} (X: set ùî∏): Sub (Sg X):= 
--     assume (f: Œ≤) (a: œÅ f ‚Üí ùî∏) (h‚ÇÄ: ‚àÄ i, a i ‚àà Sg X), 
--     show ùî∏.snd f a ‚àà Sg X, from 
--       assume W (h: Sub W ‚àß X ‚äÜ W), show ùî∏.snd f a ‚àà W, from 
--         have h‚ÇÅ: Sg X ‚äÜ W, from 
--           sInter_mem' W h,
--         have h': ‚àÄ i, a i ‚àà W, from assume i, h‚ÇÅ (h‚ÇÄ i),
--         (h.left f a h')

--     inductive Y {ùî∏: algebra œÉ} (X: set ùî∏): set ùî∏
--     | var (x : ùî∏) : x ‚àà X ‚Üí Y x
--     | app (f : Œ≤) (a : œÅ f ‚Üí ùî∏) : (‚àÄ i, Y (a i)) ‚Üí Y (ùî∏.snd f a)

--     -- Y X is a subuniverse
--     lemma Y_is_Sub {ùî∏: algebra œÉ} (X: set ùî∏): Sub (Y X):= 
--     assume f a (h: ‚àÄ i, Y X (a i)), show Y X (ùî∏.snd f a), from 
--     Y.app f a h 

--     -- Y A X is the subuniverse generated by X
--     theorem sg_inductive {ùî∏: algebra œÉ} (X: set ùî∏): Sg X = Y X :=
--       have h‚ÇÄ: X ‚äÜ Y X, from assume x (h: x ‚àà X), 
--         show x  ‚àà Y X, from Y.var x h,
--       have h‚ÇÅ: Sub (Y X), from assume f a (h : ‚àÄ x, Y X (a x)), 
--         show Y X (ùî∏.snd f a), from Y.app f a h,
--       have inc_l: Sg X ‚äÜ Y X, from sInter_mem (Y X) h‚ÇÅ h‚ÇÄ, 
--       have inc_r: Y X ‚äÜ Sg X, from assume a (h: a ‚àà Y X), 
--         show a ‚àà Sg X, from
--           have h‚ÇÇ: a ‚àà Y X ‚Üí a ‚àà Sg X, from 
--             Y.rec
--             --base: a = x ‚àà X
--             ( assume x (hr‚ÇÅ: x ‚àà X), 
--               show x ‚àà Sg X, from subset_X_of_SgX X hr‚ÇÅ )
--             --inductive: a = A f b for some b with ‚àÄ i, b i ‚àà Sg X
--             ( assume f b (hr‚ÇÇ: ‚àÄ i, b i ‚àà Y X) (hr‚ÇÉ: ‚àÄ i, b i ‚àà Sg X),
--               show ùî∏.snd f b ‚àà Sg X, from SgX_is_Sub X f b hr‚ÇÉ ),
--           h‚ÇÇ h,
--       set.subset.antisymm inc_l inc_r

--     definition index_of_sub_above_X {ùî∏: algebra œÉ} 
--     (X: set ùî∏) (C: Œ≥ ‚Üí set ùî∏): Œ≥ ‚Üí Prop:= 
--     Œª i, Sub (C i) ‚àß X ‚äÜ (C i) 

--     lemma sInter_mem_of_mem {ùî∏: algebra œÉ} {X: set ùî∏} (x: ùî∏): 
--     x ‚àà Sg X ‚Üî ‚àÄ {R: set ùî∏}, Sub R ‚Üí X ‚äÜ R ‚Üí x ‚àà R:= 
--     iff.intro
--       (assume (h: x ‚àà Sg X) (R: set ùî∏) (h‚ÇÅ: Sub R) (h‚ÇÇ: X ‚äÜ R), 
--         show x ‚àà R, from h R (and.intro h‚ÇÅ h‚ÇÇ))
--       (assume (h: ‚àÄ {R: set ùî∏}, Sub R ‚Üí X ‚äÜ R ‚Üí x ‚àà R), 
--         show x ‚àà Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))

--     -- Y is the smallest Sub containing X
--     lemma Y_is_min_Sub {ùî∏: algebra œÉ} (U X: set ùî∏): 
--     Sub U ‚Üí X ‚äÜ U ‚Üí Y X ‚äÜ U:=
--     assume (h‚ÇÅ: Sub U) (h‚ÇÇ : X ‚äÜ U),
--     assume (y: ùî∏)  (p: Y X y), show U y, from 
--       have q: Y X y ‚Üí Y X y ‚Üí U y, from 
--         Y.rec

--         --base step: y = x ‚àà X
--         ( assume y (h: X y) (h': Y X y), h‚ÇÇ h )

--         --induction step: y = A f a for some a with ‚àÄ i, a i ‚àà Y
--         ( assume f a,
--           assume h‚ÇÉ: ‚àÄ i, Y X (a i), 
--           assume h‚ÇÑ: ‚àÄ i, Y X (a i) ‚Üí U (a i),
--           assume h‚ÇÖ: Y X (ùî∏.snd f a),
--           have h‚ÇÜ: ‚àÄ i, a i ‚àà U, from 
--             assume i, h‚ÇÑ i (h‚ÇÉ i), show U (ùî∏.snd f a), from h‚ÇÅ f a h‚ÇÜ ),
--       q p p

--   end subuniverse

-- end ualib

-- -- Miscellaneous Notes

-- -- ‚ãÇ‚ÇÄ is notation for sInter (S : set (set Œ±)) : set Œ± := Inf S,
-- -- and Inf S is defined as follows:
-- --
-- --     Inf := Œªs, {a | ‚àÄ t ‚àà s, a ‚àà t },
-- --
-- -- So, if S : set (set Œ±) (i.e., a collection of sets of type Œ±),
-- -- then Inf S is the intersection of the sets in S.

-- namespace ualib
--   section homomorphism

--     parameter {Œ± : Sort u}
--     parameter {Œ≤ : Sort u}
--     parameter {Œ≥ : Type v}
--     parameter {œÉ : @signature Œ≥}

--     def homomorphic {ùî∏ : algebra œÉ} {ùîπ : algebra œÉ}
--     (h : ùî∏ ‚Üí ùîπ) := ‚àÄ f a, h (ùî∏.snd f a) = ùîπ.snd f (h ‚àò a)

--     -- The following versions merely demostrate 
--     -- syntax variations that are possible in Lean.
--     def homomorphic_terse {ùî∏: algebra œÉ} {ùîπ: algebra œÉ} (h: ùî∏ ‚Üí ùîπ) := 
--     ‚àÄ f a, h (ùî∏.snd f a) = ùîπ.snd f (h ‚àò a)

--     def homomorphic_show_types {ùî∏: algebra œÉ} {ùîπ: algebra œÉ} 
--     (h: ùî∏.fst ‚Üí ùîπ.fst) := 
--     ‚àÄ (f: Œ≥) (a : œÉ.œÅ f ‚Üí ùî∏.fst), h (ùî∏.snd f a) = ùîπ.snd f (h ‚àò a)

--   end homomorphism
-- end ualib



