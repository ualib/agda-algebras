--File: subuniverse.agda
--Author: William DeMeo
--Date: 10 Jan 2020
--Updated: 6 Feb 2020

{-# OPTIONS --without-K --exact-split #-}

open import Level

open import basic
open algebra
open signature

module subuniverse {â„“ : Level} {S : signature} where

open import preliminaries

open import Data.Empty
open import Data.Unit.Base using (âŠ¤)
open import Data.Product
open import Data.Sum using (_âŠ_; [_,_])
open import Function
open import Relation.Unary
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_â‰¡_; refl)
open import Data.Product using (Î£; _,_; âˆƒ; Î£-syntax; âˆƒ-syntax)

OpClosed : (A : algebra S) (B : Pred âŸ¦ A âŸ§áµ¤ â„“) -> Set â„“
OpClosed A B = âˆ€{ğ“¸ : S ğ“•}
               (args : â„• -> âŸ¦ A âŸ§áµ¤) 
  ->           âˆ€(i : â„•) -> (args i) âˆˆ B
              -------------------------------------------
  ->           (A âŸ¦ ğ“¸ âŸ§) args âˆˆ B
open algebraP

IsSubuniverse : (ğ‘¨ : algebraP S) -> Pred (S Î©) zero -> Set
IsSubuniverse ğ‘¨ B = âˆ€{ğ“¸ : S ğ“•}
                    (args : â„• -> (S Î©))
  ->                (âˆ€(i : â„•) -> (args i) âˆˆ B)
                   -------------------------------------------
  ->                ( (ğ‘¨ âŸ¦ ğ“¸ âŸ§â‚’) args âˆˆ B)

--Sub ğ‘¨ ğ‘© (asserts that ğ‘¨ is a subalgebra of ğ‘©)
Sub : (ğ‘¨ ğ‘© : algebraP S) -> Prp
Sub ğ‘¨ ğ‘© = âŸ¦ ğ‘¨ âŸ§â‚š âŠ† âŸ¦ ğ‘© âŸ§â‚š Ã— (âˆ€{ğ“¸ : S ğ“•} -> (args : â„• -> (S Î©))
           -> (âˆ€(i : â„•) -> (args i) âˆˆ âŸ¦ ğ‘¨ âŸ§â‚š)
          -------------------------------------------
           -> (ğ‘© âŸ¦ ğ“¸ âŸ§â‚’) args âˆˆ âŸ¦ ğ‘¨ âŸ§â‚š)

-- subuniverse generated by X ---------------------------------
--          â‹‚ : âˆ€ {â„“ i} (I : Set i) â†’ (I â†’ Pred A â„“) â†’ Pred A _
--          â‹‚ I P = Î» x â†’ (i : I) â†’ P i x
Sg : (ğ‘¨ : algebraP S)
  ->   (X : Pred (S Î©) zero)
  ->   (X âŠ† âŸ¦ ğ‘¨ âŸ§â‚š)
      -------------------  
  ->   Pred (S Î©) zero
Sg ğ‘¨ X p = {!â‹‚ _ (Î» U -> (IsSubuniverse ğ‘¨ U) Ã— (X âŠ† U))!} -- 



-- --subalgebra intersection
-- _âŠ“_ : âˆ€ {ğ‘¨ : algebraP S}
--   ->  (ğ‘© ğ‘ª : algebraP S)
--   ->  Sub ğ‘© ğ‘¨ -> Sub ğ‘ª ğ‘¨
--     -----------------------
--   ->   algebraP S
-- _âŠ“_ {ğ‘¨} ğ‘© ğ‘ª pb pc =
--   record {
--     âŸ¦_âŸ§â‚š = âŸ¦ ğ‘© âŸ§â‚š âˆ© âŸ¦ ğ‘ª âŸ§â‚š ;
--     _âŸ¦_âŸ§â‚’ =  ğ‘© âŸ¦_âŸ§â‚’ ;
--     cl = Î» ğ“¸ args argsâˆˆBâˆ©C -> ((cl ğ‘©) ğ“¸ args Î»{i -> projâ‚ (argsâˆˆBâˆ©C i)}) , {!!}
--     }

--interxection of subalgebras is a subalgebra
-- âŠ“-IsSubuniverse : {ğ‘¨ ğ‘© ğ‘ª : algebraP S} -> Sub ğ‘© ğ‘¨ -> Sub ğ‘ª ğ‘¨ -> Sub (ğ‘© âŠ“ ğ‘ª) ğ‘¨ 
-- ğ‘© âŠ“ ğ‘ª = record { âŸ¦_âŸ§â‚š = {!!} ; _âŸ¦_âŸ§â‚’ = {!!} ; cl = {!!} }


record subuniverse {A : algebra S} : Set (suc â„“) where

  field
    sset : Pred âŸ¦ A âŸ§áµ¤ â„“
    closed : OpClosed A sset    

--subalgebra type
record subalgebra (A : algebra S) : Set (suc â„“) where

  field

    subuniv : Pred âŸ¦ A âŸ§áµ¤ â„“
    _âŸ¦_âŸ§ : (ğ“¸ : S ğ“•)
      ->   (args : â„• -> âŸ¦ A âŸ§áµ¤)
      ->   ( âˆ€(i : â„•) -> (args i) âˆˆ subuniv )
         --------------------------------------------------
      ->   Set â„“
      
    closed : OpClosed A subuniv


open subuniverse

SubAlgebra : (A : algebra S)
  ->         (B : subuniverse {A})
           --------------------------
  ->         (subalgebra A)

SubAlgebra A B =
  record
    {
    subuniv = sset B ;
    _âŸ¦_âŸ§ = Î» ğ“¸ args p -> (sset B) ((A âŸ¦ ğ“¸ âŸ§) args) ;
    closed = closed B
    }

-- Recall (cf. Theorem 4.32 of Bergman), if A, B are algebras of signature S,
-- then the following hold:
--   (1) For every n-ary term t and homomorphism g: A â€”> B, 
--       g(tá´¬(aâ‚,...,aâ‚™)) = tá´®(g(aâ‚),...,g(aâ‚™)).
--   (2) For every term t âˆˆ T(X) and every Î¸ âˆˆ Con(A), 
--       a Î¸ b => t(a) Î¸ t(b).
--   (3) For every subset Y of A,
--       Sg(Y) = { t(aâ‚,...,aâ‚™) : t âˆˆ T(Xâ‚™), n < Ï‰, and aáµ¢ âˆˆ Y, for i â‰¤ n}.
--
-- (1) is proved in free.agda (see: comm-hom-term)
-- (2) is proved in free.agda (see: compatible-term and Compatible-Term)
--
-- PROOF of (3).
-- Recall,
--          â‹ƒ : âˆ€ {â„“ i} (I : Set i) â†’ (I â†’ Pred A â„“) â†’ Pred A _
--          â‹ƒ I P = Î» x â†’ Î£[ i âˆˆ I ] P i x
--          syntax â‹ƒ I (Î» i â†’ P) = â‹ƒ[ i âˆ¶ I ] P

--          â‹‚ : âˆ€ {â„“ i} (I : Set i) â†’ (I â†’ Pred A â„“) â†’ Pred A _
--          â‹‚ I P = Î» x â†’ (i : I) â†’ P i x
--          syntax â‹‚ I (Î» i â†’ P) = â‹‚[ i âˆ¶ I ] P
-- Pred : âˆ€ {a} â†’ Set a â†’ (â„“ : Level) â†’ Set (a âŠ” suc â„“)
-- Pred A â„“ = A â†’ Set â„“

-- closed-pred :  âˆ€ {A : algebra S} -> (X : Pred âŸ¦ A âŸ§áµ¤ zero) -> Prp
-- closed-pred X :  OpClosed âˆ€ {A : algebra S} -> Set


-- indexed-pred : âˆ€ {A : algebra S} -> Set (suc â„“)
-- indexed-pred {A} = â„• -> Pred âŸ¦ A âŸ§áµ¤ â„“

-- closed-preds : {A : algebra S} -> Pred (indexed-pred {A}) â„“
-- closed-preds = {!!}

-- sub-gen : {A : algebra S} (X : âŸ¦ A âŸ§áµ¤ -> Prp) -> subuniverse {A}
-- sub-gen X =
--   record {
--     sset = {!!} ;
--     closed = {!!}
--   }


-- Sg X =
--   record
--   {
--     subuniv = {!!} ;
--     _âŸ¦_âŸ§ = {!!} ;
--     closed = {!!}
--   }

-- Sg : {A : algebra S} (X : âŸ¦ A âŸ§áµ¤ -> Prp) -> subalgebra A
-- Sg X =
--   record
--   {
--     subuniv = {!!} ;
--     _âŸ¦_âŸ§ = {!!} ;
--     closed = {!!}
--   }
--     â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}

-- record subalgebra (A : algebra S) : Set (suc â„“) where
--   field
--     subuniv : Pred âŸ¦ A âŸ§áµ¤ â„“
--     _âŸ¦_âŸ§ : (ğ“¸ : âŸ¨ S âŸ©â‚’)
--       ->   (args : Fin (âŸ¨ S âŸ©â‚ ğ“¸) -> âŸ¦ A âŸ§áµ¤)
--       ->   ( âˆ€(i : Fin (âŸ¨ S âŸ©â‚ ğ“¸)) -> (args i) âˆˆ subuniv )
--          --------------------------------------------------
--       ->   Set â„“
--     closed : OpClosed A subuniv


-- _âŠ†_ : âˆ€ {â„“â‚ƒ â„“ â„“â‚‚} {Î£ : signature} {A : Algebra {â„“} {â„“â‚‚} Î£} â†’
--         Congruence {â„“â‚ƒ} A â†’ Congruence {â„“â‚ƒ} A â†’ Set _

-- Î¦ âŠ† Î¨ = âˆ€ s â†’ (rel Î¦ s) â‡’ (rel Î¨ s)


--     -- intersection introduction ----------------------------------
--     theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: 
--     (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
--     assume h, iff.elim_right set.mem_Inter h

--     theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: 
--     (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
--     assume h, iff.elim_right set.mem_Inter h

--     -- intersection elimination -------------------------------------
--     theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: 
--     (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= 
--     assume h, iff.elim_left set.mem_Inter h
    
--     -- Intersection of subuniverses is a subuniverse ---------------
--     lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): 
--     (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
--     assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
--     assume (f: Î²) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
--     show ğ”¸.snd f a âˆˆ â‹‚i, C i, from 
--       Inter.intro                -- x = (ğ”¸ f a)
--       (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

--     -- X is a subset of Sgá´¬(X) ----------------------------------------
--     lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= 
--     assume x (h: x âˆˆ X), 
--       show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
--         assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
--         show x âˆˆ W, from 
--           have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
--         hâ‚‚.right h

--     -- A subuniverse that contains X also contains Sgá´¬ X ------------------------
--     lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
--     âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
--     assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
--     show Sg X âŠ† R, from 
--       assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
--         h R (and.intro hâ‚ hâ‚‚)

--     lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
--     âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
--     assume R (hc : Sub R âˆ§ X âŠ† R),
--     have hâ‚: Sub R, from hc.left,
--     have hâ‚‚: X âŠ† R, from hc.right,
--     show Sg X âŠ† R, from 
--       assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
--         h R (and.intro hâ‚ hâ‚‚)

--     lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
--     âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
--     assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
--     show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

--     -- Sgá´¬ X is a subuniverse of A --------------------------------------
--     lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= 
--     assume (f: Î²) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
--     show ğ”¸.snd f a âˆˆ Sg X, from 
--       assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸.snd f a âˆˆ W, from 
--         have hâ‚: Sg X âŠ† W, from 
--           sInter_mem' W h,
--         have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
--         (h.left f a h')

--     inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
--     | var (x : ğ”¸) : x âˆˆ X â†’ Y x
--     | app (f : Î²) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)

--     -- Y X is a subuniverse
--     lemma Y_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Y X):= 
--     assume f a (h: âˆ€ i, Y X (a i)), show Y X (ğ”¸.snd f a), from 
--     Y.app f a h 

--     -- Y A X is the subuniverse generated by X
--     theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
--       have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), 
--         show x  âˆˆ Y X, from Y.var x h,
--       have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), 
--         show Y X (ğ”¸.snd f a), from Y.app f a h,
--       have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
--       have inc_r: Y X âŠ† Sg X, from assume a (h: a âˆˆ Y X), 
--         show a âˆˆ Sg X, from
--           have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from 
--             Y.rec
--             --base: a = x âˆˆ X
--             ( assume x (hrâ‚: x âˆˆ X), 
--               show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚ )
--             --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
--             ( assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X),
--               show ğ”¸.snd f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ ),
--           hâ‚‚ h,
--       set.subset.antisymm inc_l inc_r

--     definition index_of_sub_above_X {ğ”¸: algebra Ïƒ} 
--     (X: set ğ”¸) (C: Î³ â†’ set ğ”¸): Î³ â†’ Prop:= 
--     Î» i, Sub (C i) âˆ§ X âŠ† (C i) 

--     lemma sInter_mem_of_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸} (x: ğ”¸): 
--     x âˆˆ Sg X â†” âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
--     iff.intro
--       (assume (h: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚: Sub R) (hâ‚‚: X âŠ† R), 
--         show x âˆˆ R, from h R (and.intro hâ‚ hâ‚‚))
--       (assume (h: âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R), 
--         show x âˆˆ Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))

--     -- Y is the smallest Sub containing X
--     lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): 
--     Sub U â†’ X âŠ† U â†’ Y X âŠ† U:=
--     assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U),
--     assume (y: ğ”¸)  (p: Y X y), show U y, from 
--       have q: Y X y â†’ Y X y â†’ U y, from 
--         Y.rec

--         --base step: y = x âˆˆ X
--         ( assume y (h: X y) (h': Y X y), hâ‚‚ h )

--         --induction step: y = A f a for some a with âˆ€ i, a i âˆˆ Y
--         ( assume f a,
--           assume hâ‚ƒ: âˆ€ i, Y X (a i), 
--           assume hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i),
--           assume hâ‚…: Y X (ğ”¸.snd f a),
--           have hâ‚†: âˆ€ i, a i âˆˆ U, from 
--             assume i, hâ‚„ i (hâ‚ƒ i), show U (ğ”¸.snd f a), from hâ‚ f a hâ‚† ),
--       q p p

--   end subuniverse

-- end ualib

-- -- Miscellaneous Notes

-- -- â‹‚â‚€ is notation for sInter (S : set (set Î±)) : set Î± := Inf S,
-- -- and Inf S is defined as follows:
-- --
-- --     Inf := Î»s, {a | âˆ€ t âˆˆ s, a âˆˆ t },
-- --
-- -- So, if S : set (set Î±) (i.e., a collection of sets of type Î±),
-- -- then Inf S is the intersection of the sets in S.

-- namespace ualib
--   section homomorphism

--     parameter {Î± : Sort u}
--     parameter {Î² : Sort u}
--     parameter {Î³ : Type v}
--     parameter {Ïƒ : @signature Î³}

--     def homomorphic {ğ”¸ : algebra Ïƒ} {ğ”¹ : algebra Ïƒ}
--     (h : ğ”¸ â†’ ğ”¹) := âˆ€ f a, h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)

--     -- The following versions merely demostrate 
--     -- syntax variations that are possible in Lean.
--     def homomorphic_terse {ğ”¸: algebra Ïƒ} {ğ”¹: algebra Ïƒ} (h: ğ”¸ â†’ ğ”¹) := 
--     âˆ€ f a, h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)

--     def homomorphic_show_types {ğ”¸: algebra Ïƒ} {ğ”¹: algebra Ïƒ} 
--     (h: ğ”¸.fst â†’ ğ”¹.fst) := 
--     âˆ€ (f: Î³) (a : Ïƒ.Ï f â†’ ğ”¸.fst), h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)

--   end homomorphism
-- end ualib



