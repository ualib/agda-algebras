---
layout: default
title : "Base.Subalgebras.Subuniverses module (The Agda Universal Algebra Library)"
date : "2021-01-14"
author: "agda-algebras development team"
---

### <a id="subuniverses">Subuniverses</a>

This is the [Base.Subalgebras.Subuniverses][] module of the [Agda Universal Algebra Library][].

We start by defining a type that represents the important concept of *subuniverse*. Suppose ğ‘¨ is an algebra.  A subset B âŠ† âˆ£ ğ‘¨ âˆ£ is said to be *closed under the operations of* ğ‘¨ if for each ğ‘“ âˆˆ âˆ£ ğ‘† âˆ£ and all tuples ğ’ƒ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ ğµ the element (ğ‘“ Ì‚ ğ‘¨) ğ’ƒ belongs to B. If a subset B âŠ† ğ´ is closed under the operations of ğ‘¨, then we call B a *subuniverse* of ğ‘¨.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

open import Base.Algebras.Basic using ( ğ“ ; ğ“¥ ; Signature )

module Base.Subalgebras.Subuniverses {ğ‘† : Signature ğ“ ğ“¥} where

-- Imports from Agda and the Agda Standard Library -----------------------------
open import Agda.Primitive using ( _âŠ”_ ; lsuc ; Level ) renaming ( Set to Type )
open import Axiom.Extensionality.Propositional
                           using () renaming (Extensionality to funext)
open import Function.Base  using ( _âˆ˜_ )
open import Relation.Binary.PropositionalEquality
                           using ( module â‰¡-Reasoning ; _â‰¡_ )
open import Relation.Unary using ( Pred ; _âˆˆ_ ; _âŠ†_ ; â‹‚ )

-- Imports from the Agda Universal Algebra Library -----------------------------
open import Base.Overture.Preliminaries      using ( âˆ£_âˆ£ ; âˆ¥_âˆ¥ ; _â»Â¹ )
open import Base.Relations.Discrete          using ( Im_âŠ†_ )
open import Base.Equality.Welldefined        using ( swelldef )
open import Base.Algebras.Basic              using ( Algebra ; _Ì‚_ )
open import Base.Algebras.Products   {ğ‘† = ğ‘†} using ( ov )
open import Base.Terms.Basic         {ğ‘† = ğ‘†} using ( Term ; â„Š ; node )
open import Base.Terms.Operations    {ğ‘† = ğ‘†} using ( _âŸ¦_âŸ§ )
open import Base.Homomorphisms.Basic {ğ‘† = ğ‘†} using ( hom )

private variable Î± Î² ğ“§ : Level

\end{code}

We first show how to represent in [Agda][] the collection of subuniverses of an algebra `ğ‘¨`.  Since a subuniverse is viewed as a subset of the domain of `ğ‘¨`, we define it as a predicate on `âˆ£ ğ‘¨ âˆ£`.  Thus, the collection of subuniverses is a predicate on predicates on `âˆ£ ğ‘¨ âˆ£`.

\begin{code}

Subuniverses : (ğ‘¨ : Algebra Î± ğ‘†) â†’ Pred (Pred âˆ£ ğ‘¨ âˆ£ Î²) (ğ“ âŠ” ğ“¥ âŠ” Î± âŠ” Î²)

Subuniverses ğ‘¨ B = (ğ‘“ : âˆ£ ğ‘† âˆ£)(ğ‘ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£) â†’ Im ğ‘ âŠ† B â†’ (ğ‘“ Ì‚ ğ‘¨) ğ‘ âˆˆ B

\end{code}



#### <a id="subuniverses-as-records">Subuniverses as records</a>

Next we define a type to represent a single subuniverse of an algebra. If `ğ‘¨` is the algebra in question, then a subuniverse of `ğ‘¨` is a subset of (i.e., predicate over) the domain `âˆ£ ğ‘¨ âˆ£` that belongs to `Subuniverses ğ‘¨`.

\begin{code}

record Subuniverse {ğ‘¨ : Algebra Î± ğ‘†} : Type(ov Î² âŠ” Î±) where
 constructor mksub
 field       sset  : Pred âˆ£ ğ‘¨ âˆ£ Î²
             isSub : sset âˆˆ Subuniverses ğ‘¨

\end{code}


#### <a id="subuniverse-generation">Subuniverse Generation</a>

If `ğ‘¨` is an algebra and `X âŠ† âˆ£ ğ‘¨ âˆ£` a subset of the domain of `ğ‘¨`, then the *subuniverse of* `ğ‘¨` *generated by* `X` is typically denoted by `Sg`<sup>`ğ‘¨`</sup>`(X)` and defined to be the smallest subuniverse of `ğ‘¨` containing `X`.  Equivalently,

`Sg`<sup>`ğ‘¨`</sup>`(X)`  =  `â‹‚` { `U` : `U` is a subuniverse of `ğ‘¨` and  `B âŠ† U` }.

We define an inductive type, denoted by `Sg`, that represents the subuniverse generated by a given subset of the domain of a given algebra, as follows.

\begin{code}

data Sg (ğ‘¨ : Algebra Î± ğ‘†)(X : Pred âˆ£ ğ‘¨ âˆ£ Î²) : Pred âˆ£ ğ‘¨ âˆ£ (ğ“ âŠ” ğ“¥ âŠ” Î± âŠ” Î²)
 where
 var : âˆ€ {v} â†’ v âˆˆ X â†’ v âˆˆ Sg ğ‘¨ X
 app : âˆ€ f a â†’ Im a âŠ† Sg ğ‘¨ X â†’ (f Ì‚ ğ‘¨) a âˆˆ Sg ğ‘¨ X

\end{code}

(The inferred types in the `app` constructor are `f : âˆ£ ğ‘† âˆ£` and `a : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£`.)

Given an arbitrary subset `X` of the domain `âˆ£ ğ‘¨ âˆ£` of an `ğ‘†`-algebra `ğ‘¨`, the type `Sg X` does indeed represent a subuniverse of `ğ‘¨`. Proving this using the inductive type `Sg` is trivial, as we see here.

\begin{code}

sgIsSub : {ğ‘¨ : Algebra Î± ğ‘†}{X : Pred âˆ£ ğ‘¨ âˆ£ Î²} â†’ Sg ğ‘¨ X âˆˆ Subuniverses ğ‘¨
sgIsSub = app

\end{code}

Next we prove by structural induction that `Sg X` is the smallest subuniverse of `ğ‘¨` containing `X`.

\begin{code}

sgIsSmallest : {ğ“¡ : Level}(ğ‘¨ : Algebra Î± ğ‘†){X : Pred âˆ£ ğ‘¨ âˆ£ Î²}(Y : Pred âˆ£ ğ‘¨ âˆ£ ğ“¡)
 â†’             Y âˆˆ Subuniverses ğ‘¨  â†’  X âŠ† Y  â†’  Sg ğ‘¨ X âŠ† Y

sgIsSmallest _ _ _ XinY (var Xv) = XinY Xv
sgIsSmallest ğ‘¨ Y YsubA XinY (app f a SgXa) = Yfa
 where
 IH : Im a âŠ† Y
 IH i = sgIsSmallest ğ‘¨ Y YsubA XinY (SgXa i)

 Yfa : (f Ì‚ ğ‘¨) a âˆˆ Y
 Yfa = YsubA f a IH

\end{code}

When the element of `Sg X` is constructed as `app f a SgXa`, we may assume (the induction hypothesis) that the arguments in the tuple `a` belong to `Y`. Then the result of applying `f` to `a` also belongs to `Y` since `Y` is a subuniverse.



#### <a id="subuniverse-lemmas">Subuniverse Lemmas</a>

Here we formalize a few basic properties of subuniverses. First, the intersection of subuniverses is again a subuniverse.

\begin{code}

â‹‚s : {ğ“˜ : Level}{ğ‘¨ : Algebra Î± ğ‘†}{I : Type ğ“˜}{ğ’œ : I â†’ Pred âˆ£ ğ‘¨ âˆ£ Î²}
 â†’   (âˆ€ i â†’ ğ’œ i âˆˆ Subuniverses ğ‘¨) â†’ â‹‚ I ğ’œ âˆˆ Subuniverses ğ‘¨

â‹‚s Ïƒ f a Î½ = Î» i â†’ Ïƒ i f a (Î» x â†’ Î½ x i)

\end{code}

In the proof above, we assume the following typing judgments:

```
 Ïƒ : âˆ€ i â†’ ğ’œ i âˆˆ Subuniverses ğ‘¨
 f : âˆ£ ğ‘† âˆ£
 a : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£
 Î½ : Im ğ‘ âŠ† â‹‚ I ğ’œ
```
and we must prove `(f Ì‚ ğ‘¨) a âˆˆ â‹‚ I ğ’œ`. In this case, Agda will fill in the proof term `Î» i â†’ Ïƒ i f a (Î» x â†’ Î½ x i)` automatically with the command `C-c C-a`.

Next, subuniverses are closed under the action of term operations.

\begin{code}

sub-term-closed : {ğ“§ : Level}{X : Type ğ“§}(ğ‘¨ : Algebra Î± ğ‘†){B : Pred âˆ£ ğ‘¨ âˆ£ Î²}
 â†’                (B âˆˆ Subuniverses ğ‘¨) â†’ (t : Term X)(b : X â†’ âˆ£ ğ‘¨ âˆ£)
 â†’                ((x : X) â†’ (b x âˆˆ B)) â†’ (ğ‘¨ âŸ¦ t âŸ§)b âˆˆ B

sub-term-closed ğ‘¨ AB (â„Š x) b Bb = Bb x

sub-term-closed ğ‘¨{B} Ïƒ (node f t)b Î½ =
  Ïƒ f  (Î» z â†’ (ğ‘¨ âŸ¦ t z âŸ§) b) Î» x â†’ sub-term-closed ğ‘¨{B} Ïƒ (t x) b Î½

\end{code}

In the induction step of the foregoing proof, the typing judgments of the premise are the following:

```
ğ‘¨   : Algebra Î± ğ‘†
B   : Pred âˆ£ ğ‘¨ âˆ£ Î²
Ïƒ   : B âˆˆ Subuniverses ğ‘¨
f   : âˆ£ ğ‘† âˆ£
t   : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ Term X
b   : X â†’ âˆ£ ğ‘¨ âˆ£
Î½   : âˆ€ x â†’ b x âˆˆ B
```
and the given proof term establishes the goal `ğ‘¨ âŸ¦ node f t âŸ§ b âˆˆ B`.

Alternatively, we could express the preceeding fact using an inductive type representing images of terms.

\begin{code}

data TermImage (ğ‘¨ : Algebra Î± ğ‘†)(Y : Pred âˆ£ ğ‘¨ âˆ£ Î²) : Pred âˆ£ ğ‘¨ âˆ£ (ğ“ âŠ” ğ“¥ âŠ” Î± âŠ” Î²)
 where
 var : âˆ€ {y : âˆ£ ğ‘¨ âˆ£} â†’ y âˆˆ Y â†’ y âˆˆ TermImage ğ‘¨ Y
 app : âˆ€ ğ‘“ ğ‘¡ â†’  ((x : âˆ¥ ğ‘† âˆ¥ ğ‘“) â†’ ğ‘¡ x âˆˆ TermImage ğ‘¨ Y)  â†’ (ğ‘“ Ì‚ ğ‘¨) ğ‘¡ âˆˆ TermImage ğ‘¨ Y

\end{code}

By what we proved above, it should come as no surprise that `TermImage ğ‘¨ Y` is a subuniverse of ğ‘¨ that contains Y.

\begin{code}

TermImageIsSub : {ğ‘¨ : Algebra Î± ğ‘†}{Y : Pred âˆ£ ğ‘¨ âˆ£ Î²} â†’ TermImage ğ‘¨ Y âˆˆ Subuniverses ğ‘¨
TermImageIsSub = app

Y-onlyif-TermImageY : {ğ‘¨ : Algebra Î± ğ‘†}{Y : Pred âˆ£ ğ‘¨ âˆ£ Î²} â†’ Y âŠ† TermImage ğ‘¨ Y
Y-onlyif-TermImageY {a} Ya = var Ya

\end{code}

Since `Sg ğ‘¨ Y` is the smallest subuniverse containing Y, we obtain the following inclusion.

\begin{code}

SgY-onlyif-TermImageY : (ğ‘¨ : Algebra Î± ğ‘†)(Y : Pred âˆ£ ğ‘¨ âˆ£ Î²) â†’ Sg ğ‘¨ Y âŠ† TermImage ğ‘¨ Y
SgY-onlyif-TermImageY ğ‘¨ Y = sgIsSmallest ğ‘¨ (TermImage ğ‘¨ Y) TermImageIsSub Y-onlyif-TermImageY

\end{code}



Next we prove the important fact that homomorphisms are uniquely determined by their values on a generating set.

\begin{code}

open â‰¡-Reasoning

hom-unique : swelldef ğ“¥ Î² â†’ {ğ‘¨ : Algebra Î± ğ‘†}{ğ‘© : Algebra Î² ğ‘†}
             (X : Pred âˆ£ ğ‘¨ âˆ£ Î±)  (g h : hom ğ‘¨ ğ‘©)
 â†’           ((x : âˆ£ ğ‘¨ âˆ£) â†’ (x âˆˆ X â†’ âˆ£ g âˆ£ x â‰¡ âˆ£ h âˆ£ x))
             -------------------------------------------------
 â†’           (a : âˆ£ ğ‘¨ âˆ£) â†’ (a âˆˆ Sg ğ‘¨ X â†’ âˆ£ g âˆ£ a â‰¡ âˆ£ h âˆ£ a)

hom-unique _ _ _ _ Ïƒ a (var x) = Ïƒ a x

hom-unique wd {ğ‘¨}{ğ‘©} X g h Ïƒ fa (app ğ‘“ a Î½) = Goal
 where
 IH : âˆ€ x â†’ âˆ£ g âˆ£ (a x) â‰¡ âˆ£ h âˆ£ (a x)
 IH x = hom-unique wd{ğ‘¨}{ğ‘©} X g h Ïƒ (a x) (Î½ x)

 Goal : âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a) â‰¡ âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a)
 Goal = âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a)   â‰¡âŸ¨ âˆ¥ g âˆ¥ ğ‘“ a âŸ©
        (ğ‘“ Ì‚ ğ‘©)(âˆ£ g âˆ£ âˆ˜ a ) â‰¡âŸ¨ wd (ğ‘“ Ì‚ ğ‘©) (âˆ£ g âˆ£ âˆ˜ a) (âˆ£ h âˆ£ âˆ˜ a) IH âŸ©
        (ğ‘“ Ì‚ ğ‘©)(âˆ£ h âˆ£ âˆ˜ a)  â‰¡âŸ¨ ( âˆ¥ h âˆ¥ ğ‘“ a )â»Â¹ âŸ©
        âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a )  âˆ

\end{code}

In the induction step, the following typing judgments are assumed:

```
wd  : swelldef ğ“¥ Î²
ğ‘¨   : Algebra Î± ğ‘†
ğ‘©   : Algebra Î² ğ‘†
X   : Pred âˆ£ ğ‘¨ âˆ£ Î±
g h  : hom ğ‘¨ ğ‘©
Ïƒ   : Î  x ê‰ âˆ£ ğ‘¨ âˆ£ , (x âˆˆ X â†’ âˆ£ g âˆ£ x â‰¡ âˆ£ h âˆ£ x)
fa  : âˆ£ ğ‘¨ âˆ£
fa  = (ğ‘“ Ì‚ ğ‘¨) a
ğ‘“   : âˆ£ ğ‘† âˆ£
a   : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£
Î½   : Im a âŠ† Sg ğ‘¨ X
```

and, under these assumptions, we proved `âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a) â‰¡ âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) a)`.

---------------------------------

<span style="float:left;">[â†‘ Subalgebras](Base.Subalgebras.html)</span>
<span style="float:right;">[Base.Subalgebras.Subalgebras â†’](Base.Subalgebras.Base.Subalgebras.html)</span>

{% include UALib.Links.md %}
