---
layout: default
title : "Base.Complexity.CSP module (The Agda Universal Algebra Library)"
date : "2021-07-14"
author: "the agda-algebras development team"
---

### <a id="constraint-satisfaction-problems">Constraint Satisfaction Problems</a>

This is the [Base.Complexity.CSP][] module of the [Agda Universal Algebra Library][].

#### <a id="the-relational-formulation-of-csp">The relational formulation of CSP</a>

Let ğ’œ = (ğ´ , ğ‘…áµƒ) be a *relational structure* (or ğ‘…-structure), that is, a pair consisting
of a set ğ´ along with a collection ğ‘…áµƒ âŠ† â‹ƒâ‚™ ğ’«(ğ´â¿) of relations on ğ´.

We associate with ğ’œ a *constraint satisfaction problem* denoted by CSP(ğ’œ), which is the
decision problem that is solved by finding an algorithm or program that does the following:

Take as input

+ an *instance*, which is an ğ‘…-structure â„¬ = (ğµ , ğ‘…áµ‡) (in the same signature as ğ’œ)

Output

+ "yes" or "no" according as there is, or is not, a *solution*, which is a ğ‘…-structure
  homomorphism h : â„¬ â†’ ğ’œ.

If there is such an algorithm that takes at most a power of ğ‘› operations to process an
input structure â„¬ of size ğ‘› (i.e., ğ‘› bits of memory are required to encode â„¬), then
we say that CSP(ğ’œ) is *tractable*.  Otherwise, CSP(ğ’œ) is *intractable*.

Equivalently, if we define

  CSP(ğ’œ) := \{ â„¬ âˆ£ â„¬ an ğ‘…-structure and âˆƒ hom â„¬ â†’ ğ’œ \}

then the CSP problem described above is simply the membership problem for the subset
CSP(ğ’œ) of ğ‘… structures having homomorphisms into ğ’œ.

That is, our algorithm must take as input an ğ‘…-structure (a relational structure in the
signature of ğ’œ) and decide whether or not it belongs to the set CSP(ğ’œ).



#### <a id="connection-to-algebraic-csp">Connection to algebraic CSP</a>

Let A be a set, let Op(A) denote the set of all operations, Rel(A) the set of all
relations, on A.

Given R âŠ† Rel(A), define the set of operations on A that preserve all relations
in R as follows:

âˆ£: âƒ– R  =  \{ f âˆˆ Op(ğ´) âˆ£ âˆ€ r âˆˆ R, f âˆ£: r \}.

Recall, f âˆ£: r is our notation for `f Preserves r âŸ¶ r`, which means that r is a
subuniverse of a power of the algebra (A , {f}).

Equivalently, `f Preserves r âŸ¶ r means` the following: if f is ğ‘š-ary and r is
ğ‘›-ary, then for every size-ğ‘š collection ğ‘ğ‘  of ğ‘›-tuples from r (that is, âˆ£ ğ‘ğ‘  âˆ£ = ğ‘š
and âˆ€ a âˆˆ ğ‘ğ‘ , r a) we have r (f âˆ˜ (zip ğ‘ğ‘ )).


If ğ’œ = (A , R) is a relational structure, then the set âˆ£: âƒ–R of operations on A that
preserve all relations in R is called the set of *polymorphisms* of ğ’œ.

Conversely, starting with a collection F âŠ† Op(A) of operations on A, define
the set of all relations preserved by the functions in F as follows:

F âƒ— âˆ£:  =  \{ r âˆˆ Rel(A) âˆ£ âˆ€ f âˆˆ F, f âˆ£: r \}.

It is easy to see that for all F âŠ† Op(A) and all R âŠ† Rel(A), we have

  F âŠ†  âˆ£: âƒ– (F âƒ— âˆ£:)    and    R âŠ† (âˆ£: âƒ– R) âƒ— âˆ£:.

Let ğ‘¨(R) denote the algebraic structure with domain A and operations âˆ£: âƒ– R.

Then every r âˆˆ R is a subalgebra of a power of ğ‘¨(R).

Clearly (âˆ£: âƒ– R) âƒ— âˆ£: is the set ğ–² (ğ–¯fin ğ‘¨(R)) of subalgebras of finite powers of ğ‘¨(R).

The reason this Galois connection is useful is due to the following fact (observed by
Peter Jeavons in the late 1990's):

*Theorem*. Let ğ’œ = (A, R) be a finite relational structure.
           If R' âŠ† (âˆ£: âƒ– R) âƒ— âˆ£: is finite, then CSP((A, Î“'))
           is reducible in poly-time to CSP(ğ’œ)

In particular, the tractability of CSP(ğ’œ) depends only on its associated polymorphism
algebra, ğ‘¨(R) := (A , âˆ£: âƒ– R).

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

open import Base.Algebras.Basic using ( ğ“ ; ğ“¥ ; Signature )

module Base.Complexity.CSP {ğ‘† : Signature ğ“ ğ“¥} where

-- Imports from Agda and the Agda Standard Library ------------------------------
open import Agda.Primitive   using ( _âŠ”_ ; lsuc ; Level) renaming ( Set to Type )
open import Function.Base    using ( _âˆ˜_ )
open import Relation.Binary  using ( Setoid )

-- Imports from the Agda Universal Algebra Library ------------------------------
open import Base.Relations.Continuous       using ( REL ; REL-syntax )
open import Setoid.Algebras.Basic  {ğ‘† = ğ‘†}  using ( Algebra )

\end{code}

#### <a id="constraints">Constraints</a>

A constraint c consists of

1. a scope function,  s : I â†’ var, and

2. a constraint relation, i.e., a predicate over the function type I â†’ D

        I Â·Â·Â·> var
         .     .
          .   .
           âŒŸ âŒ
            D

The *scope* of a constraint is an indexed subset of the set of variable symbols.
We could define a type for this, e.g.,

```
 Scope : Type Î½ â†’ Type Î¹ â†’ _
 Scope V I = I â†’ V
```

but we omit this definition because it's so simple; to reiterate,
a scope of "arity" I on "variables" V is simply a map from I to V,
where,

* I denotes the "number" of variables involved in the scope
* V denotes a collection (type) of "variable symbols"

\begin{code}

module _                -- levels for...
         {Î¹ : Level}    -- ...arity (or argument index) types
         {Î½ : Level}    -- ...variable symbol types
         {Î± â„“ : Level}  -- ... domain types
         where
 open Setoid
 record Constraint (var : Type Î½) (dom : var â†’ Setoid Î± â„“) : Type (Î½ âŠ” Î± âŠ” lsuc Î¹) where
  field
   arity  : Type Î¹               -- The "number" of variables involved in the constraint.
   scope  : arity â†’ var          -- Which variables are involved in the constraint.
   rel    : REL[ i âˆˆ arity ] (Carrier (dom (scope i)))   -- The constraint relation.

  satisfies : (âˆ€ v â†’ Carrier (dom v)) â†’ Type  -- An assignment ğ‘“ : var â†’ dom of values to variables
  satisfies f = rel (f âˆ˜ scope)      -- *satisfies* the constraint ğ¶ = (Ïƒ , ğ‘…) provided
                                    -- ğ‘“ âˆ˜ Ïƒ âˆˆ ğ‘…, where Ïƒ is the scope of the constraint.
\end{code}


#### <a id="csp-templates-and-instances">CSP templates and instances</a>

A CSP "template" restricts the relations that may occur in instances of the problem.
A convenient way to specify a template is to give an indexed family
ğ’œ : var â†’ Algebra Î± Ï of algebras (one for each variable symbol in var)
and require that relations be subalgebras of the product â¨… var ğ’œ.

To construct a CSP instance, then, we just have to give a family ğ’œ of algebras, specify
the number (ar) of constraints, and for each i : ar, define a constraint as a relation
over (some of) the members of ğ’œ.

An instance of a constraint satisfaction problem is a triple ğ‘ƒ = (ğ‘‰, ğ·, ğ¶) where

* ğ‘‰ denotes a set of "variables"
* ğ· denotes a "domain",
* ğ¶ denotes an indexed collection of constraints.

\begin{code}

 open Algebra
 open Setoid
 record CSPInstance (var : Type Î½)(ğ’œ : var â†’ Algebra Î± â„“) : Type (Î½ âŠ” Î± âŠ” lsuc Î¹) where
  field
   ar : Type Î¹       -- ar indexes the contraints in the instance
   cs : (i : ar) â†’ Constraint var (Î» v â†’ Domain (ğ’œ v))

  isSolution : (âˆ€ v â†’ Carrier (Domain (ğ’œ v))) â†’ Type _  -- An assignment *solves* the instance
  isSolution f = âˆ€ i â†’ (Constraint.satisfies (cs i)) f  -- if it satisfies all the constraints.

\end{code}

--------------------------------

<span>[â† Base.Complexity.Basic](Base.Complexity.Basic.html)</span>
<span style="float:right;">[Top â†‘](index.html)</span>

{% include UALib.Links.md %}
