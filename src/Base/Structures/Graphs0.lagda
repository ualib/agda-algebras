---
layout: default
title : "Base.Structures.Graphs0"
date : "2021-06-22"
author: "agda-algebras development team"
---

### <a id="graph-structures-again">Graph Structures (again)</a>

This is the [Base.Structures.Graphs0][] module of the [Agda Universal Algebra Library][].

N.B. This module differs from Graphs.lagda in that here we assume some universes are level zero (i.e., â„“â‚€). This simplifies some things; e.g., we avoid having to use lift and lower (cf. [Base/Structures/Graphs.lagda][])

Definition [Graph of a structure]. Let ğ‘¨ be an (ğ‘…,ğ¹)-structure (relations from ğ‘… and operations from ğ¹).
The *graph* of ğ‘¨ is the structure Gr ğ‘¨ with the same domain as ğ‘¨ with relations from ğ‘… and together with a (k+1)-ary relation symbol G ğ‘“ for each ğ‘“ âˆˆ ğ¹ of arity k, which is interpreted in Gr ğ‘¨ as all tuples (t , y) âˆˆ AáµâºÂ¹ such that ğ‘“ t â‰¡ y. (See also Definition 2 of https://arxiv.org/pdf/2010.04958v2.pdf)


\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

module Base.Structures.Graphs0 where

-- Imports from Agda and the Agda Standard Library -------------------------------------------
open import Agda.Primitive using ( _âŠ”_ ; Level ) renaming ( Set to Type ; lzero to â„“â‚€ )
open import Data.Product   using ( _,_ ; _Ã—_ ; Î£-syntax )
open import Data.Sum.Base  using ( _âŠ_ ) renaming ( injâ‚ to inl ; injâ‚‚ to inr )
open import Data.Fin.Base  using ( Fin )
open import Data.Nat       using ( â„• )
open import Data.Unit.Base using ( âŠ¤ ; tt )
open import Function.Base  using ( _âˆ˜_ )
open import Relation.Unary using ( Pred ; _âˆˆ_ )
open import Relation.Binary.PropositionalEquality
                           using ( _â‰¡_ ; module â‰¡-Reasoning ; cong ; sym ; refl )

-- Imports from the Agda Universal Algebra Library ---------------------------------------------
open import Base.Overture.Preliminaries     using ( âˆ£_âˆ£ ; âˆ¥_âˆ¥ )
open import Base.Relations.Continuous       using ( Rel )
open import Base.Structures.Basic           using ( signature ; structure )
open import Base.Structures.Homs            using ( hom ; is-hom-rel ; is-hom-op )
open import Examples.Structures.Signatures  using ( Sâˆ… )


open signature
open structure
open _âŠ_

Gr-sig : signature â„“â‚€ â„“â‚€ â†’ signature â„“â‚€ â„“â‚€ â†’ signature â„“â‚€ â„“â‚€

Gr-sig ğ¹ ğ‘… = record { symbol = symbol ğ‘… âŠ symbol ğ¹
                    ; arity  = ar }
 where
 ar : symbol ğ‘… âŠ symbol ğ¹ â†’ Type â„“â‚€
 ar (inl ğ‘Ÿ) = (arity ğ‘…) ğ‘Ÿ
 ar (inr ğ‘“) = (arity ğ¹) ğ‘“ âŠ âŠ¤


private variable
 ğ¹ ğ‘… : signature â„“â‚€ â„“â‚€

Gr : structure ğ¹ ğ‘… {â„“â‚€} {â„“â‚€} â†’ structure Sâˆ… (Gr-sig ğ¹ ğ‘…) {â„“â‚€} {â„“â‚€}
Gr {ğ¹}{ğ‘…} ğ‘¨ = record { carrier = carrier ğ‘¨ ; op = Î» () ; rel = split }
  where
  split : (s : symbol ğ‘… âŠ symbol ğ¹) â†’ Rel (carrier ğ‘¨) (arity (Gr-sig ğ¹ ğ‘…) s) {â„“â‚€}
  split (inl ğ‘Ÿ) arg = rel ğ‘¨ ğ‘Ÿ arg
  split (inr ğ‘“) args = op ğ‘¨ ğ‘“ (args âˆ˜ inl) â‰¡ args (inr tt)


open â‰¡-Reasoning

module _ {ğ‘¨ ğ‘© : structure ğ¹ ğ‘… {â„“â‚€}{â„“â‚€}} where

 homâ†’Grhom : hom ğ‘¨ ğ‘© â†’ hom (Gr ğ‘¨) (Gr ğ‘©)
 homâ†’Grhom (h , hhom) = h , (i , ii)
  where
  i : is-hom-rel (Gr ğ‘¨) (Gr ğ‘©) h
  i (inl ğ‘Ÿ) a x = âˆ£ hhom âˆ£ ğ‘Ÿ a x
  i (inr ğ‘“) a x = goal
   where
   homop : h (op ğ‘¨ ğ‘“ (a âˆ˜ inl)) â‰¡ op ğ‘© ğ‘“ (h âˆ˜ (a âˆ˜ inl))
   homop = âˆ¥ hhom âˆ¥ ğ‘“ (a âˆ˜ inl)

   goal : op ğ‘© ğ‘“ (h âˆ˜ (a âˆ˜ inl)) â‰¡ h (a (inr tt))
   goal = op ğ‘© ğ‘“ (h âˆ˜ (a âˆ˜ inl)) â‰¡âŸ¨ sym homop âŸ©
          h (op ğ‘¨ ğ‘“ (a âˆ˜ inl))   â‰¡âŸ¨ cong h x âŸ©
          h (a (inr tt))         âˆ

  ii : is-hom-op (Gr ğ‘¨) (Gr ğ‘©) h
  ii = Î» ()


 Grhomâ†’hom : hom (Gr ğ‘¨) (Gr ğ‘©) â†’ hom ğ‘¨ ğ‘©
 Grhomâ†’hom (h , hhom) = h , (i , ii)
  where
  i : is-hom-rel ğ‘¨ ğ‘© h
  i R a x = âˆ£ hhom âˆ£ (inl R) a x
  ii : is-hom-op ğ‘¨ ğ‘© h
  ii f a = goal
   where
   split : arity ğ¹ f âŠ âŠ¤ â†’ carrier ğ‘¨
   split (inl x) = a x
   split (inr y) = op ğ‘¨ f a
   goal : h (op ğ‘¨ f a) â‰¡ op ğ‘© f (Î» x â†’ h (a x))
   goal = sym (âˆ£ hhom âˆ£ (inr f) split refl)

\end{code}

**Lemma III.1**. Let `ğ‘†` be a signature and `ğ‘¨` be an `ğ‘†`-structure.
Let `â„°` be a finite set of identities such that `ğ‘¨ âŠ§ â„°`. For every
instance `ğ‘¿` of CSP(`ğ‘¨`), one can compute in polynomial time an
instance `ğ’€` of CSP(`ğ‘¨`) such that `ğ’€ âŠ§ â„°` and `| hom ğ‘¿ ğ‘¨ | = | hom ğ’€ ğ‘¨ |`.

**Proof**. `âˆ€ s â‰ˆ t` in `â„°` and each tuple `b` such that `ğ‘© âŸ¦ s âŸ§ b â‰¢ ğ‘© âŸ¦ t âŸ§ b`, one can compute
the congruence `Î¸ = Cg (ğ‘© âŸ¦ s âŸ§ b , ğ‘© âŸ¦ t âŸ§ b)` generated by `ğ‘© âŸ¦ s âŸ§ b` and `ğ‘© âŸ¦ t âŸ§ b`.
Let `ğ‘©â‚ := ğ‘© / Î¸`, and note that `| ğ‘©â‚ | < | ğ‘© |`.

We show there exists a bijection from `hom ğ‘© ğ‘¨` to `hom ğ‘©â‚ ğ‘¨`.
Fix an `h : hom ğ‘© ğ‘¨`. For all `s â‰ˆ t` in `â„°`, we have

`h (ğ‘© âŸ¦ s âŸ§ b) = ğ‘¨ âŸ¦ s âŸ§ (h b) = ğ‘¨ âŸ¦ t âŸ§ (h b) = h (ğ‘© âŸ¦ t âŸ§ b)`.

Therefore, `Î¸ âŠ† ker h`, so `h` factors uniquely as `h = h' âˆ˜ Ï€ : ğ‘© â†’ (ğ‘© / Î¸) â†’ ğ‘¨`,
where `Ï€` is the canonical projection onto `ğ‘© / Î¸`.

Thus the mapping `Ï† : hom ğ‘© ğ‘¨ â†’ hom ğ‘©â‚ ğ‘¨` that takes each `h` to `h'` such that `h = h' âˆ˜ Ï€`
is injective.  It is also surjective since each `g' : ğ‘© / Î¸ â†’ ğ‘¨` is mapped back to
a `g : ğ‘© â†’ ğ‘¨` such that `g = g' âˆ˜ Ï€`. Iterating over all identities in `â„°`, possibly
several times, at the final step we obtain a structure `ğ‘©â‚™` that satisfies `â„°`
and is such that `âˆ£ hom ğ‘© ğ‘¨ âˆ£ = âˆ£ hom ğ‘©â‚™ ğ‘¨ âˆ£`. Moreover, since the number of elements
in the intermediate structures decreases at each step, `| ğ‘©áµ¢â‚Šâ‚ | < | ğ‘©áµ¢ |`, the process
finishes in time that is bounded by a polynomial in the size of `ğ‘©`.

\begin{code}

record _â‡›_â‡š_ (ğ‘© ğ‘¨ ğ‘ª : structure ğ¹ ğ‘…) : Type â„“â‚€ where
 field
  to   : hom ğ‘© ğ‘¨ â†’ hom ğ‘ª ğ‘¨
  from : hom ğ‘ª ğ‘¨ â†’ hom ğ‘© ğ‘¨
  toâˆ¼from : âˆ€ h â†’ (to âˆ˜ from) h â‰¡ h
  fromâˆ¼to : âˆ€ h â†’ (from âˆ˜ to) h â‰¡ h

 -- TODO: formalize Lemma III.1
 -- module _ {Ï‡ : Level}{X : Type Ï‡}
 --          {ğ‘¨ : structure ğ¹ ğ‘… {â„“â‚€} {â„“â‚€}} where
 -- LEMMAIII1 : {n : â„•}(â„° : Fin n â†’ (Term X Ã— Term X))(ğ‘¨ âˆˆ fMod â„°)
 --  â†’          âˆ€(ğ‘© : structure ğ¹ ğ‘…) â†’ Î£[ ğ‘ª âˆˆ structure ğ¹ ğ‘… ] (ğ‘ª âˆˆ fMod â„° Ã— (ğ‘© â‡› ğ‘¨ â‡š ğ‘ª))
 -- LEMMAIII1 â„° ğ‘¨âŠ§â„° ğ‘© = {!!} , {!!}
\end{code}

--------------------------------

<span style="float:left;">[â† Base.Structures.Graphs](Base.Structures.Graphs.html)</span>
<span style="float:right;">[Base.Structures.Products â†’](Base.Structures.Products.html)</span>

{% include UALib.Links.md %}
