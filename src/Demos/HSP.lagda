---
layout: default
title : "Demos.HSP module"
date : "2022-04-27"
author: "the agda-algebras development team"
---

### <a id="introduction">Introduction</a>

The Agda Universal Algebra Library ([agda-algebras][]) formalizes the foundations of universal 
algebra in intensional Martin-L√∂f type theory ([MLTT][]) using [Agda][] () ¬†[@Norell:2007; @agdaref].
The library includes a collection of definitions and verified theorems originated in classical 
(set-theory based) universal algebra and equational logic, but adapted to [MLTT][].

The first major milestone of the project is a complete formalization of *Birkhoff's variety
theorem* (also known as the *HSP theorem*)¬†[@Birkhoff:1935]. To the best of our knowledge, this
is the first time Birkhoff's celebrated 1935 result has been formalized in [MLTT][].[^1]

Our first attempt to formalize Birkhoff's theorem suffered from two flaws.[^2] First, we 
assumed function extensionality in [MLTT][]; consequently, it was unclear whether the
formalization was fully constructive. Second, an inconsistency could be contrived by taking the
type `X`, representing an arbitrary collection of variable symbols, to be the two element type
(see ¬ß[7](#sec:discuss){reference-type="ref" reference="sec:discuss"} for details). To resolve
these issues, we developed a new formalization of the HSP theorem based on *setoids* and
rewrote much of the [agda-algebras][] library to support this approach. This enabled us to
avoid function extensionality altogether. Moreover, the type `X` of variable symbols was
treated with more care using the *context* and *environment* types that Andreas Abel uses
in¬†[@Abel:2021] to formalize Birkhoff's completeness theorem. These design choices are
discussed further in ¬ß[2.2](#setoids){reference-type="ref"
reference="setoids"}--[2.3](#setoid-functions){reference-type="ref"
reference="setoid-functions"}.

What follows is a self-contained formal proof of the HSP theorem in [Agda][]. This is achieved
by extracting a subset of the library, including only the pieces needed for the proof, into a
single literate file.[^3] For spaces reasons, we elide some inessential parts, but strive to
preserve the essential content and character of the development. Specifically, routine or
overly technical components, as well as anything that does not seem to offer insight into the
central ideas of the proof are omitted. (The file [[src/Demos/HSP.lagda]{.sans-serif}](https://github.com/ualib/agda-algebras/blob/master/src/Demos/HSP.lagda) mentioned above includes the full proof.)

<!-- We include here every line of code of our new proof of Birkhoff's theorem in a single module, -->
<!-- presented as a literate document,[^4]. Apart from a few dozen imports from the , the module is self-contained. -->

In this paper, we highlight some of the more challenging aspects of formalizing universal algebra in type theory. To some extent, this is a sobering glimpse of the significant technical hurdles that must be overcome to do mathematics in dependent type theory. Nonetheless, we hope to demonstrate that [MLTT][] is a relatively natural language for formalizing universal algebra. Indeed, we believe that researchers with sufficient patience and resolve can reap the substantial rewards of deeper insight and greater confidence in their results by using type
theory and a proof assistant like [Agda][]. On the other hand, this paper is probably not the best place to learn about the latter, since we assume the reader is already familiar with [MLTT][] and [Agda][]. In summary, our main contribution is to show that a straightforward but very general representation of algebraic structures in dependent type theory is quite practical, as we demonstrate by formalizing a major seminal result of universal algebra.

### <a id="preliminaries">Preliminaries</a>

#### <a id="logical-foundations">Logical foundations</a>

To best emulate [MLTT][], we use
\begin{code}[inline]
{-# OPTIONS --without-K --exact-split --safe #-}
\end{code}
 disables [Streicher's K axiom](https://ncatlab.org/nlab/show/axiom+K+%28type+theory%29); 
directs [Agda][] to accept only definitions behaving like *judgmental* equalities;
**safe** ensures that nothing is postulated outright.
(See¬†[@agdaref-axiomk; @agdaref-safeagda; @agdatools-patternmatching].)

Here are brief descriptions of these options, accompanied by links to
related documentation.

*  **without-K** disables [Streicher's K axiom](https://ncatlab.org/nlab/show/axiom+K+%28type+theory%29). See
   the [section on axiom K](https://agda.readthedocs.io/en/v2.6.1/language/without-k.html) in the [Agda Language Reference Manual](https://agda.readthedocs.io/en/v2.6.1.3/language)¬†[@agdaref-axiomk].

*  **exact-split** directs [Agda][] to accept only definitions behaving like *judgmental* equalities. See the [Pattern matching and equality](https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#pattern-matching-and-equality) section of the [Agda Tools](https://agda.readthedocs.io/en/v2.6.1.3/tools/) documentation¬†[@agdatools-patternmatching].

*  **safe** ensures that nothing is postulated outright---every non-axiom has to be an explicit assumption (e.g., an argument to a function or module). See the [cmdoption-safe](https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html#cmdoption-safe) section of¬†[@agdaref-safeagda].

We also make use of the following definitions from [Agda][]'s standard library (ver.¬†1.7).

\begin{code}
-- Import universe levels and Signature type (described below) from the agda-algebras library.
open import Overture using ( ùìû ; ùì• ; Signature )
module Demos.HSP {ùëÜ : Signature ùìû ùì•} where

-- Import 16 definitions from the Agda Standard Library.
open import Data.Unit.Polymorphic  using  ( ‚ä§ ; tt )
open import Function               using  ( id ; _‚àò_ ; flip )
open import Level                  using  ( Level ;  _‚äî_ ; suc )
open import Relation.Binary        using  ( Rel ; Setoid ; IsEquivalence
                                          ; Reflexive ; Symmetric ; Transitive
                                          ; Sym ; Trans )
open import Relation.Unary         using  ( Pred ; _‚äÜ_ ; _‚àà_ )

open import Relation.Binary.PropositionalEquality using ( _‚â°_ )

-- Import 23 definitions from the Agda Standard Library and rename 12 of them.
open import Agda.Primitive  using () renaming ( Set to Type )
open import Data.Product    using ( _√ó_ ; _,_ ; Œ£ ; Œ£-syntax )
                            renaming ( proj‚ÇÅ to fst ; proj‚ÇÇ to snd )
open import Function        using () renaming ( Func to _‚ü∂_ )

open  _‚ü∂_           using ( cong ) renaming ( to to _‚ü®$‚ü©_ )
open IsEquivalence  using ()
                    renaming ( refl to refl·µâ ; sym to sym·µâ ; trans to trans·µâ )
open Setoid         using ( Carrier ; isEquivalence ) renaming ( _‚âà_ to _‚âàÀ¢_ )
                    renaming ( refl to reflÀ¢ ; sym to symÀ¢ ; trans to transÀ¢ )

-- Assign handles to 3 modules of the Agda Standard Library.
import Function.Definitions                   as FD
import Relation.Binary.PropositionalEquality  as ‚â°
import Relation.Binary.Reasoning.Setoid       as SetoidReasoning

private variable
 Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà œÅ œá ‚Ñì : Level
 Œì Œî : Type œá

\end{code}

The above imports include some adjustments to "standard" [Agda][] syntax; in particular, we use `Type` in place of `Set`, the infix long arrow symbol, `_‚ü∂_`, in place of `Func` (the type of "setoid functions," discussed in
¬ß[2.3](#setoid-functions){reference-type="ref"
reference="setoid-functions"} below), and the symbol `_‚ü®$‚ü©_` in place of `f` (application of the map of a setoid function); we use `fst` and `snd`, and sometimes `‚à£_‚à£` and `‚à•_‚à•`, to denote the first and second projections out of the product type `_√ó_`.

\begin{code}
module _ {A : Type Œ± }{B : A ‚Üí Type Œ≤} where
 ‚à£_‚à£ : Œ£[ x ‚àà A ] B x ‚Üí A
 ‚à£_‚à£ = fst
 ‚à•_‚à• : (z : Œ£[ a ‚àà A ] B a) ‚Üí B ‚à£ z ‚à£
 ‚à•_‚à• = snd
\end{code}


#### <a id="setoids">Setoids</a>

A *setoid* is a pair consisting of a type and an equivalence relation on that type. Setoids are useful for representing a set with an explicit, "local" notion of equivalence, instead of relying on an implicit, "global" one as is more common in set theory. In reality, informal mathematical practice relies on equivalence relations quite pervasively, taking great care to define only functions that preserve equivalences, while eliding the details. To be properly formal, such details must be made explicit. While there are many different workable approaches, the one that requires no additional meta-theory is based on setoids, which is why we adopt it here. While in some settings setoids are found by others to be burdensome, we have not found them to be so for universal algebra.

The [agda-algebras][] library was first developed without setoids, relying on propositional equality instead, along with some experimental, domain-specific types for equivalence classes, quotients, etc. This
required postulating function extensionality,[^4] which is known to be independent from [MLTT][]¬†[@MHE; @MHE:2019]; this was unsatisfactory as we aimed to show that the theorems hold directly in [MLTT][] without extra axioms. The present work makes no appeal to functional extensionality or classical axioms like Choice or Excluded Middle.[^5]

##### <a id="setoid-functions">Setoid functions</a>

A *setoid function* is a function from one setoid to another that respects the underlying equivalences. If [ùë®]{.ab} and [ùë©]{.ab} are setoids, we use [ùë®]{.ab}_[‚ü∂]{.aor}_[ùë©]{.ab} to denote the type of setoid functions from [ùë®]{.ab} to [ùë©]{.ab}.

An example of a setoid function is the identity function from a setoid to itself. We define it, along with a binary composition operation for setoid functions, `_‚ü®‚àò‚ü©_`, as follows.

\begin{code}

ùëñùëë : {A : Setoid Œ± œÅ·µÉ} ‚Üí A ‚ü∂ A
ùëñùëë {A} = record { to = id ; cong = id }

_‚ü®‚àò‚ü©_ :  {A : Setoid Œ± œÅ·µÉ} {B : Setoid Œ≤ œÅ·µá} {C : Setoid Œ≥ œÅ·∂ú}
 ‚Üí       B ‚ü∂ C  ‚Üí  A ‚ü∂ B  ‚Üí  A ‚ü∂ C

f ‚ü®‚àò‚ü© g = record  { to = (_‚ü®$‚ü©_ f) ‚àò (_‚ü®$‚ü©_ g)
                  ; cong = (cong f) ‚àò (cong g) }
\end{code}


#### <a id="inverses">Inverses</a>
<!-- {#inverses .unnumbered} -->

We define the *inverse* of a setoid function in terms of the image of the function's domain, as follows.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë© using ( _‚âà_ ; sym ) renaming ( Carrier to B )

 data Image_‚àã_ (f : ùë® ‚ü∂ ùë©) : B ‚Üí Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  eq : {b : B} ‚Üí ‚àÄ a ‚Üí b ‚âà f ‚ü®$‚ü© a ‚Üí Image f ‚àã b

\end{code}

An inhabitant of the `Image f ‚àã b` type is a point `a : Carrier ùë®`, along with a proof `p : b ‚âà f a`, that `f` maps `a` to `b`. Since a proof of `Image f ‚àã b` must include a concrete witness `a : Carrier ùë®`, we can actually *compute* a range-restricted right-inverse of `f`. Here is the definition of `Inv` which, for extra
certainty, is accompanied by a proof that it gives such a right-inverse.

\begin{code}

 Inv : (f : ùë® ‚ü∂ ùë©){b : B} ‚Üí Image f ‚àã b ‚Üí Carrier ùë®
 Inv _ (eq a _) = a

 InvIsInverse ≥ : {f : ùë® ‚ü∂ ùë©}{b : B}(q : Image f ‚àã b) ‚Üí f ‚ü®$‚ü© (Inv f q) ‚âà b
 InvIsInverse ≥ (eq _ p) = sym p
\end{code}


#### <a id="injective-and-surjective-setoid-functions">Injective and surjective setoid functions</a>
<!-- {#injective-and-surjective-setoid-functions .unnumbered} -->

If `f : ùë® ‚ü∂ ùë©` then we call `f` *injective* provided `‚àÄ(a‚ÇÄ a‚ÇÅ : A)`, `f ‚ü®$‚ü© a‚ÇÄ ‚âà·¥Æ f ‚ü®$‚ü© a‚ÇÅ` implies `a‚ÇÄ ‚âà·¥¨ a‚ÇÅ`; we call `f` *surjective* provided `‚àÄ(b : B) ‚àÉ(a : A)` such that `f ‚ü®$‚ü© a ‚âà·¥Æ b`.

We represent injective functions on bare types by the type `Injective`, and use this to define the `IsInjective` type representing the property of being an injective setoid function. Similarly, the type `IsSurjective`
represents the property of being a surjective setoid function and `SurjInv` represents the *right-inverse* of a surjective function.

We reproduce the definitions and prove some of their properties inside the next submodule where we first set the stage by declaring two setoids `ùë®` and `ùë©` and naming their equality relations.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where
 open Setoid ùë® using () renaming ( _‚âà_ to _‚âà·¥¨_ )
 open Setoid ùë© using () renaming ( _‚âà_ to _‚âà·¥Æ_ )
 open FD

 IsInjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá)
 IsInjective f = Injective _‚âà·¥¨_ _‚âà·¥Æ_ (_‚ü®$‚ü©_ f)

 IsSurjective : (ùë® ‚ü∂ ùë©) ‚Üí  Type (Œ± ‚äî Œ≤ ‚äî œÅ·µá)
 IsSurjective F = ‚àÄ {y} ‚Üí Image F ‚àã y

 SurjInv : (f : ùë® ‚ü∂ ùë©) ‚Üí IsSurjective f ‚Üí Carrier ùë© ‚Üí Carrier ùë®
 SurjInv f fonto b = Inv f (fonto {b})

\end{code}

Proving that the composition of injective setoid functions is again injective is simply a matter of composing the two assumed witnesses to injectivity. Proving that surjectivity is preserved under composition is only slightly more involved.

\begin{code}

module _  {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá}{ùë™ : Setoid Œ≥ œÅ·∂ú}
          (f : ùë® ‚ü∂ ùë©)(g : ùë© ‚ü∂ ùë™) where

 ‚àò-IsInjective : IsInjective f ‚Üí IsInjective g ‚Üí IsInjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsInjective finj ginj = finj ‚àò ginj

 ‚àò-IsSurjective : IsSurjective f ‚Üí IsSurjective g ‚Üí IsSurjective (g ‚ü®‚àò‚ü© f)
 ‚àò-IsSurjective fonto gonto {y} = Goal where
  mp : Image g ‚àã y ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
  mp (eq c p) = Œ∑ fonto where
   open Setoid ùë™ using ( trans )
   Œ∑ : Image f ‚àã c ‚Üí Image g ‚ü®‚àò‚ü© f ‚àã y
   Œ∑ (eq a q) = eq a (trans p (cong g q))

  Goal : Image g ‚ü®‚àò‚ü© f ‚àã y
  Goal = mp gonto
\end{code}



#### <a id="factorization-of-setoid-functions">Factorization of setoid functions[^6]</a>
<!-- {#factorization-of-setoid-functions .unnumbered} -->

Every (setoid) function `f : A ‚ü∂ B` factors as a surjective map `toIm : A ‚ü∂ Im f` followed
by an injective map `fromIm : Im f ‚ü∂ B`.

\begin{code}

module _ {ùë® : Setoid Œ± œÅ·µÉ}{ùë© : Setoid Œ≤ œÅ·µá} where

 Im : (f : ùë® ‚ü∂ ùë©) ‚Üí Setoid _ _
 Carrier (Im f) = Carrier ùë®
 _‚âàÀ¢_ (Im f) b1 b2 = f ‚ü®$‚ü© b1 ‚âà f ‚ü®$‚ü© b2 where open Setoid ùë©

 isEquivalence (Im f) = record { refl = refl ; sym = sym; trans = trans }
  where open Setoid ùë©

 toIm : (f : ùë® ‚ü∂ ùë©) ‚Üí ùë® ‚ü∂ Im f
 toIm f = record { to = id ; cong = cong f }

 fromIm : (f : ùë® ‚ü∂ ùë©) ‚Üí Im f ‚ü∂ ùë©
 fromIm f = record { to = Œª x ‚Üí f ‚ü®$‚ü© x ; cong = id }

 fromIm-inj : (f : ùë® ‚ü∂ ùë©) ‚Üí IsInjective (fromIm f)
 fromIm-inj _ = id

 toIm-surj : (f : ùë® ‚ü∂ ùë©) ‚Üí IsSurjective (toIm f)
 toIm-surj _ = eq _ (reflÀ¢ ùë©)
\end{code}


### <a id="basic-universal-algebra">Basic Universal Algebra</a>

We now develop a working vocabulary in [MLTT][] corresponding to classical, single-sorted, set-based universal algebra. We cover a number of important concepts, but limit ourselves to those required to prove Birkhoff's HSP theorem. In each case, we give a type-theoretic version of the informal definition, followed by its implementation in [Agda][].

This section is organized into the following subsections:
¬ß[3.1](#signatures){reference-type="ref" reference="signatures"} defines
a general type of *signatures* of algebraic structures;
¬ß[3.2](#algebras){reference-type="ref" reference="algebras"} does the
same for structures and their products;
¬ß[3.3](#homomorphisms){reference-type="ref" reference="homomorphisms"}
defines *homomorphisms*, *monomorphisms*, and *epimorphisms*, presents
types that codify these concepts, and formally verifies some of their
basic properties; ¬ß[3.5](#subalgebras){reference-type="ref"
reference="subalgebras"}--[3.6](#terms){reference-type="ref"
reference="terms"} do the same for *subalgebras* and *terms*,
respectively.

#### <a id="signatures">Signatures</a>

An (algebraic) *signature* is a pair `ùëÜ = (F, œÅ)` where `F` is a collection of *operation symbols* and `œÅ : F ‚Üí N` is an *arity function* which maps each operation symbol to its arity. Here, `N` denotes the *arity type*. Heuristically, the arity of an operation symbol may be thought of as the number of arguments that takes as
"input."  We represent signatures as inhabitants of the following dependent pair type.

```agda
Signature : (ùí™ ùí± : Level) ‚Üí Type (lsuc (ùí™ ‚äî ùí±))
Signature ùí™ ùí± = Œ£[ F ‚àà Type ùí™ ] (F ‚Üí Type ùí±)
```

Recalling our syntax for the first and second projections, if `ùëÜ` is a signature, then `‚à£ ùëÜ ‚à£` denotes the set of operation symbols and `‚à• ùëÜ ‚à•` denotes the arity function. Thus, if `f : ‚à£ ùëÜ ‚à£` is an operation symbol in the signature `ùëÜ`, then `‚à• ùëÜ ‚à• f` is the arity of `f`.

We need to augment our `Signature` type so that it supports algebras over setoid domains. To do so, following Abel¬†[@Abel:2021], we define an operator that translates an ordinary signature into a *setoid signature*, that is, a signature over a setoid domain. This raises a minor technical issue: given operations `f` and `g`, with arguments `u : ‚à• ùëÜ ‚à• f ‚Üí A` and `v : ‚à• ùëÜ ‚à• g ‚Üí A`, respectively, and a proof of `f ‚â° g` (*intensional* equality), we ought to be able to check whether `u` and `v` are *pointwise* equal. Technically, `u` and `v` appear to inhabit different types; of course, this is reconciled by the hypothesis `f ‚â° g`, as we see in the next definition (borrowed from¬†[@Abel:2021]).

\begin{code}

EqArgs :  {ùëÜ : Signature ùìû ùì•}{Œæ : Setoid Œ± œÅ·µÉ}
 ‚Üí        ‚àÄ {f g} ‚Üí f ‚â° g ‚Üí (‚à• ùëÜ ‚à• f ‚Üí Carrier Œæ) ‚Üí (‚à• ùëÜ ‚à• g ‚Üí Carrier Œæ) ‚Üí Type (ùì• ‚äî œÅ·µÉ)
EqArgs {Œæ = Œæ} ‚â°.refl u v = ‚àÄ i ‚Üí u i ‚âà v i where open Setoid Œæ using ( _‚âà_ )

\end{code}

This makes it possible to define an operator which translates a signature for algebras over bare types into a signature for algebras over setoids. We denote this operator by `‚ü®_‚ü©` and define it as follows.

\begin{code}

‚ü®_‚ü© : Signature ùìû ùì• ‚Üí Setoid Œ± œÅ·µÉ ‚Üí Setoid _ _

Carrier  (‚ü® ùëÜ ‚ü© Œæ)                = Œ£[ f ‚àà ‚à£ ùëÜ ‚à£ ] (‚à• ùëÜ ‚à• f ‚Üí Œæ .Carrier)
_‚âàÀ¢_     (‚ü® ùëÜ ‚ü© Œæ)(f , u)(g , v)  = Œ£[ eqv ‚àà f ‚â° g ] EqArgs{Œæ = Œæ} eqv u v

refl·µâ   (isEquivalence (‚ü® ùëÜ ‚ü© Œæ))                           = ‚â°.refl , Œª i ‚Üí reflÀ¢   Œæ
sym·µâ    (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)              = ‚â°.refl , Œª i ‚Üí symÀ¢    Œæ (g i)
trans·µâ  (isEquivalence (‚ü® ùëÜ ‚ü© Œæ)) (‚â°.refl , g)(‚â°.refl , h)  = ‚â°.refl , Œª i ‚Üí transÀ¢  Œæ (g i) (h i)
\end{code}


#### <a id="algebras">Algebras</a>

An *algebraic structure* `ùë® = (A, F·¥¨)` *in the signature* `ùëÜ = (F, œÅ)`, or `ùëÜ`-*algebra*, consists of
*  a type `A`, called the *domain* of the algebra;
*  a collection `F·¥¨ := {f·¥¨ ‚à£ f ‚àà F, f·¥¨ : (œÅ f ‚Üí A) ‚Üí A}` of *operations* on `A`;
*  a (potentially empty) collection of *identities* satisfied by elements and operations of `ùë®`.
Our [Agda][] implementation represents algebras as inhabitants of a record type with two fields---a `Domain` setoid denoting the domain of the algebra, and an `Interp` function denoting the interpretation in the algebra of each operation symbol in `ùëÜ`. We postpone introducing identities until¬†¬ß[4](#equational-logic){reference-type="ref" reference="equational-logic"}.

\begin{code}

record Algebra Œ± œÅ : Type (ùìû ‚äî ùì• ‚äî suc (Œ± ‚äî œÅ)) where
 field  Domain  : Setoid Œ± œÅ
        Interp  : ‚ü® ùëÜ ‚ü© Domain ‚ü∂ Domain

\end{code}

Thus, for each operation symbol in `ùëÜ` we have a setoid function `f` whose domain is a power of `Domain` and whose codomain is `Domain`. Further, we define some syntactic sugar to make our formalizations easier to read and reason about. Specifically, if `ùë®` is an algebra, then
*  `ùîª[ ùë® ]` denotes the `Domain` setoid of `ùë®`,
*  `ùïå[ ùë® ]` is the underlying carrier of (the `Domain` setoid of) `ùë®`, and
*  `f ÃÇ ùë®` denotes the interpretation of the operation symbol `f` in the algebra `ùë®`.

\begin{code}

open Algebra
ùîª[_] : Algebra Œ± œÅ·µÉ ‚Üí  Setoid Œ± œÅ·µÉ
ùîª[ ùë® ] = Domain ùë®

ùïå[_] : Algebra Œ± œÅ·µÉ ‚Üí  Type Œ±
ùïå[ ùë® ] = Carrier (Domain ùë®)

_ÃÇ_ : (f : ‚à£ ùëÜ ‚à£)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí (‚à• ùëÜ ‚à• f  ‚Üí  ùïå[ ùë® ]) ‚Üí ùïå[ ùë® ]
f ÃÇ ùë® = Œª a ‚Üí (Interp ùë®) ‚ü®$‚ü© (f , a)
\end{code}

#### <a id="universe-levels-of-algebra-types">Universe levels of algebra types</a>
<!-- {#universe-levels-of-algebra-types .unnumbered} -->

Types belong to *universes*, which are structured in [Agda][] as follows: 
`Type ‚Ñì : Type (suc ‚Ñì)`, `Type (suc ‚Ñì) : Type (suc (suc ‚Ñì))`.[^7] 
While this means that `Type ‚Ñì` has type `Type (suc ‚Ñì)`, it does *not* imply that `Type ‚Ñì` 
has type `Type (suc (suc ‚Ñì))`. In other words, [Agda][]'s universes are *non-cumulative*. 
This can be advantageous as it becomes possible to treat size issues more generally and precisely. 
However, dealing with explicit universe levels can be daunting, and the standard literature
(in which uniform smallness is typically assumed) offers little guidance. While in some settings, 
such as category theory, formalizing in [Agda][] works smoothly with respect to universe levels 
(see¬†[@agda-categories]), in universal algebra the terrain is bumpier. Thus, it seems worthwhile to 
explain how we make use of universe lifting and lowering functions, available in the 
[Agda Standard Library][], to develop domain-specific tools for dealing with [Agda][]'s non-cumulative 
universe hierarchy.

<!-- Let us be more concrete about what is at issue by considering a typical example. frequently encounters problems during the type-checking process and responds by printing a message like the following. Here informs us that it encountered universe level on line 498 of the HSP module, where it was expecting level ¬†¬†¬†¬†( ). In this case, we tried to use an algebra inhabiting the type whereas expected an inhabitant of the type ( ( )) . The operation of the standard library embeds a type into a higher universe. Specializing to our situation, we define a function ¬†with the following interface. -2mm . -->

The `Lift` operation of the standard library embeds a type into a higher universe. Specializing `Lift` to our situation, we define a function `Lift-Alg`.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans ) ; open Level
 Lift-AlgÀ° : (‚Ñì : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì) œÅ·µÉ
 Domain (Lift-AlgÀ° ‚Ñì) =
  record  { Carrier        = Lift ‚Ñì ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí lower x ‚âà lower y
          ; isEquivalence  = record { refl = refl ; sym = sym ; trans = trans }
          }
 Interp (Lift-AlgÀ° ‚Ñì) ‚ü®$‚ü© (f , la) = lift ((f ÃÇ ùë®) (lower ‚àò la))
 cong (Interp (Lift-AlgÀ° ‚Ñì)) (‚â°.refl , lab) = cong (Interp ùë®) ((‚â°.refl , lab))

 Lift-Alg ≥ : (‚Ñì : Level) ‚Üí Algebra Œ± (œÅ·µÉ ‚äî ‚Ñì)
 Domain (Lift-Alg ≥ ‚Ñì) =
  record  { Carrier        = ùïå[ ùë® ]
          ; _‚âà_            = Œª x y ‚Üí Lift ‚Ñì (x ‚âà y)
          ; isEquivalence  = record  { refl  = lift refl
                                     ; sym   = lift ‚àò sym ‚àò lower
                                     ; trans = Œª x y ‚Üí lift (trans (lower x)(lower y))
                                     }
          }
 Interp (Lift-Alg ≥ ‚Ñì ) ‚ü®$‚ü© (f , la) = (f ÃÇ ùë®) la
 cong (Interp (Lift-Alg ≥ ‚Ñì))(‚â°.refl , lab) =
  lift ( cong (Interp ùë®) ( ‚â°.refl , Œª i ‚Üí lower (lab i) ) )

Lift-Alg : Algebra Œ± œÅ·µÉ ‚Üí (‚Ñì‚ÇÄ ‚Ñì‚ÇÅ : Level) ‚Üí Algebra (Œ± ‚äî ‚Ñì‚ÇÄ) (œÅ·µÉ ‚äî ‚Ñì‚ÇÅ)
Lift-Alg ùë® ‚Ñì‚ÇÄ ‚Ñì‚ÇÅ = Lift-Alg ≥ (Lift-AlgÀ° ùë® ‚Ñì‚ÇÄ) ‚Ñì‚ÇÅ

\end{code}

Recall that our `Algebra` type has two universe level parameters corresponding to
those of the domain setoid. Concretely, an algebra of type `Algebra Œ± œÅ·µÉ` has a
`Domain` of type `Setoid Œ± œÅ·µÉ`. This packages a  "carrier set" (`Carrier`),
inhabiting `Type Œ±`, with an equality on `Carrier` of type `Rel Carrier œÅ·µÉ`.
`Lift-Alg` takes an algebra parametrized by levels `Œ±` and `œÅ·µÉ` and constructs a
new algebra whose carrier  inhabits `Type (Œ± ‚äî ‚Ñì‚ÇÄ)` and whose equivalence inhabits
`Rel Carrier (œÅ·µÉ ‚äî ‚Ñì‚ÇÅ)`. To be useful, this lifting operation should result in an
algebra with the same semantic properties as the one we started with. We will see
in ¬ß[3.4](#sec:lift-alg){reference-type="ref" reference="sec:lift-alg"} that this
is indeed the case.


#### <a id="product-algebras">Product Algebras</a>
 <!-- {#product-algebras .unnumbered} -->

We define the *product* of a family of algebras as follows. Let `Œπ` be a universe
and `I : Type Œπ` a type (the "indexing type"). Then `ùíú : I ‚Üí Algebra Œ± œÅ·µÉ`
represents an *indexed family of algebras*. Denote by `‚®Ö ùíú` the *product of
algebras* in `ùíú` (or *product algebra*), by which we mean the algebra whose domain
is the Cartesian product `‚àè[i ‚àà I] ùîª[ ùíú i ]` of the domains of the algebras in
`ùíú`, and whose operations are those arising from the point-wise interpretation of
the operation symbols in the obvious way: if `f` is a `J`-ary operation symbol and
if `a : Œ†[ i ‚àà I ] J ‚Üí ùîª[ ùíú i ]` is, for each `i : I`, a `J`-tuple of elements of
the domain `ùîª[ ùíú i ]`, then we define the interpretation of `f` in `‚®Ö ùíú` by

`(f ÃÇ ‚®Ö ùíú) a := Œª (i : I) ‚Üí (f ÃÇ ùíú i)(a i)`.

Here is the formal definition of the product algebra type in [Agda][].

\begin{code}

module _ {Œπ : Level}{I : Type Œπ } where

 ‚®Ö : (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) ‚Üí Algebra (Œ± ‚äî Œπ) (œÅ·µÉ ‚äî Œπ)
 Domain (‚®Ö ùíú) =
  record  { Carrier = ‚àÄ i ‚Üí ùïå[ ùíú i ]
          ; _‚âà_ = Œª a b ‚Üí ‚àÄ i ‚Üí (_‚âàÀ¢_ ùîª[ ùíú i ]) (a i)(b i)
          ; isEquivalence =
             record  { refl = Œª i ‚Üí refl·µâ (isEquivalence ùîª[ ùíú i ])
                     ; sym = Œª x i ‚Üí sym·µâ (isEquivalence ùîª[ ùíú i ])(x i)
                     ; trans = Œª x y i ‚Üí trans·µâ (isEquivalence ùîª[ ùíú i ])(x i)(y i)
                     }
          }

 Interp (‚®Ö ùíú) ‚ü®$‚ü© (f , a) = Œª i ‚Üí (f ÃÇ (ùíú i)) (flip a i)
 cong (Interp (‚®Ö ùíú)) (‚â°.refl , f=g ) = Œª i ‚Üí cong  ( Interp (ùíú i) )
                                                   ( ‚â°.refl , flip f=g i )

\end{code}

Evidently, the carrier of the product algebra type is indeed the (dependent)
product of the carriers in the indexed family. The rest of the definitions are the
point-wise versions of the underlying ones.

#### <a id="structure-preserving-maps-and-isomorphism">Structure preserving maps and isomorphism</a>

Throughout the rest of the paper, unless stated otherwise, `ùë®` and `ùë©` will denote
`ùëÜ`-algebras inhabiting the types `Algebra Œ± œÅ·µÉ` and `Algebra Œ≤ œÅ·µá`, respectively.

A *homomorphism* (or "hom") from `ùë®` to `ùë©` is a setoid function
`h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]` that is *compatible* with all basic operations; that is, for
every operation symbol `f : ‚à£ ùëÜ ‚à£` and all tuples `a : ‚à• ùëÜ ‚à• f ‚Üí ùïå[ ùë® ]`, we have
`h ‚ü®$‚ü© (f ÃÇ ùë®) a ‚âà (f ÃÇ ùë©) Œª x ‚Üí h ‚ü®$‚ü© (a x)`.

It is convenient to first formalize "compatible" (`compatible-map-op`),
representing the assertion that a given setoid function `h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]`
commutes with a given operation symbol `f`, and then generalize over operation
symbols to yield the type (`compatible-map`) of compatible maps from (the domain
of) `ùë®` to (the domain of) `ùë©`.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where

 compatible-map-op : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí ‚à£ ùëÜ ‚à£ ‚Üí Type _
 compatible-map-op h f = ‚àÄ {a} ‚Üí h ‚ü®$‚ü© (f ÃÇ ùë®) a ‚âà (f ÃÇ ùë©) Œª x ‚Üí h ‚ü®$‚ü© (a x)
  where open Setoid ùîª[ ùë© ] using ( _‚âà_ )

 compatible-map : (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) ‚Üí Type _
 compatible-map h = ‚àÄ {f} ‚Üí compatible-map-op h f

\end{code}

Using these we define the property (`IsHom`) of being a homomorphism, and
finally the type (`hom`) of homomorphisms from `ùë®` to `ùë©`.

\begin{code}

 record IsHom (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µá) where
  constructor  mkhom
  field        compatible : compatible-map h

 hom : Type _
 hom = Œ£ (ùîª[¬†ùë® ] ‚ü∂ ùîª[ ùë© ]) IsHom

\end{code}

Thus, an inhabitant of `hom ùë® ùë©` is a pair `(h , p)` consisting of a setoid
function `h`, from the domain of `ùë®` to that of `ùë©`, along with a proof `p` that
`h` is a homomorphism.

A *monomorphism* (resp. *epimorphism*) is an injective (resp. surjective)
homomorphism. The [agda-algebras][] library defines predicates and for these, as
well as and for the corresponding types.

\begin{code}

 record IsMon (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî œÅ·µá) where
  field  isHom : IsHom h
         isInjective : IsInjective h
  HomReduct : hom
  HomReduct = h , isHom

 mon : Type _
 mon = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsMon

\end{code}

As with `hom`, the type `mon` is a dependent product type; each inhabitant is a
pair consisting of a setoid function, say, `h`, along with a proof that `h` is a
monomorphism.

\begin{code}

 record IsEpi (h : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî Œ≤ ‚äî œÅ·µá) where
  field  isHom : IsHom h
         isSurjective : IsSurjective h
  HomReduct : hom
  HomReduct = h , isHom

 epi : Type _
 epi = Œ£ (ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]) IsEpi

\end{code}

Here are two utilities that are useful for translating between types.

\begin{code}

open IsHom ; open IsMon ; open IsEpi
module _ (ùë® : Algebra Œ± œÅ·µÉ)(ùë© : Algebra Œ≤ œÅ·µá) where
 mon‚Üíintohom : mon ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£
 mon‚Üíintohom (hh , hhM) = (hh , isHom hhM) , isInjective hhM

 epi‚Üíontohom : epi ùë® ùë© ‚Üí Œ£[ h ‚àà hom ùë® ùë© ] IsSurjective ‚à£ h ‚à£
 epi‚Üíontohom (hh , hhE) = (hh , isHom hhE) , isSurjective hhE
\end{code}

##### <a id="composition-of-homomorphisms">Composition of homomorphisms</a>
 <!-- {#composition-of-homomorphisms .unnumbered} -->

The composition of homomorphisms is again a homomorphism, and similarly
for epimorphisms and monomorphisms. The proofs of these facts are
straightforward.

\begin{code}

module _  {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú}
          {g : ùîª[ ùë® ] ‚ü∂ ùîª[ ùë© ]}{h : ùîª[ ùë© ] ‚ü∂ ùîª[ ùë™ ]} where
  open Setoid ùîª[ ùë™ ] using ( trans )
  ‚àò-is-hom : IsHom ùë® ùë© g ‚Üí IsHom ùë© ùë™ h ‚Üí IsHom ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-hom ghom hhom = mkhom c where
   c : compatible-map ùë® ùë™ (h ‚ü®‚àò‚ü© g)
   c = trans (cong h (compatible ghom)) (compatible hhom)

  ‚àò-is-epi : IsEpi ùë® ùë© g ‚Üí IsEpi ùë© ùë™ h ‚Üí IsEpi ùë® ùë™ (h ‚ü®‚àò‚ü© g)
  ‚àò-is-epi gE hE =
    record  { isHom = ‚àò-is-hom (isHom gE) (isHom hE)
            ; isSurjective = ‚àò-IsSurjective g h (isSurjective gE) (isSurjective hE)
            }

module _ {ùë® : Algebra Œ± œÅ·µÉ} {ùë© : Algebra Œ≤ œÅ·µá} {ùë™ : Algebra Œ≥ œÅ·∂ú} where
  ‚àò-hom : hom ùë® ùë© ‚Üí hom ùë© ùë™  ‚Üí hom ùë® ùë™
  ‚àò-hom (h , hhom) (g , ghom) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-hom hhom ghom

  ‚àò-epi : epi ùë® ùë© ‚Üí epi ùë© ùë™  ‚Üí epi ùë® ùë™
  ‚àò-epi (h , hepi) (g , gepi) = (g ‚ü®‚àò‚ü© h) , ‚àò-is-epi hepi gepi
\end{code}

##### <a id="universe-lifting-of-homomorphisms">Universe lifting of homomorphisms</a>
 <!-- {#universe-lifting-of-homomorphisms .unnumbered} -->

Here we define the identity homomorphism for setoid algebras. Then we prove that
the operations of lifting and lowering of a setoid algebra are homomorphisms.

\begin{code}

ùíæùíπ : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí hom ùë® ùë®
ùíæùíπ {ùë® = ùë®} =  ùëñùëë , mkhom (reflexive ‚â°.refl)
              where open Setoid ( Domain ùë® ) using ( reflexive )

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 open Setoid ùîª[ ùë® ] using ( reflexive ) renaming ( _‚âà_ to _‚âà‚ÇÅ_ ; refl to refl‚ÇÅ )
 open Setoid ùîª[ Lift-AlgÀ° ùë® ‚Ñì ]  using () renaming ( _‚âà_ to _‚âàÀ°_ ; refl to reflÀ°)
 open Setoid ùîª[ Lift-Alg ≥ ùë® ‚Ñì ]  using () renaming ( _‚âà_ to _‚âà ≥_ ; refl to refl ≥)
 open Level

 ToLiftÀ° : hom ùë® (Lift-AlgÀ° ùë® ‚Ñì)
 ToLiftÀ° = record { to = lift ; cong = id } , mkhom (reflexive ‚â°.refl)

 FromLiftÀ° : hom (Lift-AlgÀ° ùë® ‚Ñì) ùë®
 FromLiftÀ° = record { to = lower ; cong = id } , mkhom reflÀ°

 ToFromLiftÀ° : ‚àÄ b ‚Üí  ‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© b) ‚âàÀ° b
 ToFromLiftÀ° b = refl‚ÇÅ

 FromToLiftÀ° : ‚àÄ a ‚Üí ‚à£ FromLiftÀ° ‚à£ ‚ü®$‚ü© (‚à£ ToLiftÀ° ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLiftÀ° a = refl‚ÇÅ

 ToLift ≥ : hom ùë® (Lift-Alg ≥ ùë® ‚Ñì)
 ToLift ≥ = record { to = id ; cong = lift } , mkhom (lift (reflexive ‚â°.refl))

 FromLift ≥ : hom (Lift-Alg ≥ ùë® ‚Ñì) ùë®
 FromLift ≥ = record { to = id ; cong = lower } , mkhom reflÀ°

 ToFromLift ≥ : ‚àÄ b ‚Üí ‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© b) ‚âà ≥ b
 ToFromLift ≥ b = lift refl‚ÇÅ

 FromToLift ≥ : ‚àÄ a ‚Üí ‚à£ FromLift ≥ ‚à£ ‚ü®$‚ü© (‚à£ ToLift ≥ ‚à£ ‚ü®$‚ü© a) ‚âà‚ÇÅ a
 FromToLift ≥ a = refl‚ÇÅ


module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì r : Level} where
 open  Setoid ùîª[ ùë® ]               using ( refl )
 open  Setoid ùîª[ Lift-Alg ùë® ‚Ñì r ]  using ( _‚âà_ )
 open  Level
 ToLift : hom ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift = ‚àò-hom ToLiftÀ° ToLift ≥

 FromLift : hom (Lift-Alg ùë® ‚Ñì r) ùë®
 FromLift = ‚àò-hom FromLift ≥ FromLiftÀ°

 ToFromLift : ‚àÄ b ‚Üí ‚à£ ToLift ‚à£ ‚ü®$‚ü© (‚à£ FromLift ‚à£ ‚ü®$‚ü© b) ‚âà b
 ToFromLift b = lift refl

 ToLift-epi : epi ùë® (Lift-Alg ùë® ‚Ñì r)
 ToLift-epi =
  ‚à£ ToLift ‚à£ , record  { isHom = ‚à• ToLift ‚à•
                       ; isSurjective = Œª{y} ‚Üí eq(‚à£ FromLift ‚à£ ‚ü®$‚ü© y)(ToFromLift y)
                       }
\end{code}


##### <a id="homomorphisms-of-product-algebras">Homomorphisms of product algebras</a>
 <!-- {#homomorphisms-of-product-algebras .unnumbered} -->

Suppose we have an algebra `ùë®`, a type `I : Type ùìò`, and a family
`‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá` of algebras. We sometimes refer to the inhabitants of `I`
as *indices*, and call `‚Ñ¨` an *indexed family of algebras*. If in addition we have
a family `ùíΩ : (i : I) ‚Üí hom ùë® (‚Ñ¨ i)` of homomorphisms, then we can construct a
homomorphism from `ùë®` to the product `‚®Ö ‚Ñ¨` in the natural way.  We codify the
latter in dependent type theory as follows.

\begin{code}

module _ {Œπ : Level}{I : Type Œπ}{ùë® : Algebra Œ± œÅ·µÉ}(‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá) where
 ‚®Ö-hom-co : (‚àÄ(i : I) ‚Üí hom ùë® (‚Ñ¨ i)) ‚Üí hom ùë® (‚®Ö ‚Ñ¨)
 ‚®Ö-hom-co ùíΩ = h , hhom where  h : ùîª[ ùë® ] ‚ü∂ ùîª[ ‚®Ö ‚Ñ¨ ]
                              h ‚ü®$‚ü© a = Œª i ‚Üí ‚à£ ùíΩ i ‚à£ ‚ü®$‚ü© a
                              cong h xy i = cong ‚à£ ùíΩ i ‚à£ xy
                              hhom : IsHom ùë® (‚®Ö ‚Ñ¨) h
                              compatible hhom = Œª i ‚Üí compatible ‚à• ùíΩ i ‚à•
\end{code}

Two structures are *isomorphic* provided there are homomorphisms from each to the
other that compose to the identity. We define the following record type to
represent this concept. Note that the definition, shown below, includes a proof of
the fact that the maps `to` and `from` are bijective, which makes this fact more
accessible.

\begin{code}

module _ (ùë® : Algebra Œ± œÅ·µÉ) (ùë© : Algebra Œ≤ œÅ·µá) where
 open Setoid ùîª[ ùë® ]  using ()  renaming ( _‚âà_ to _‚âà·¥¨_ )
 open Setoid ùîª[ ùë© ]  using ()  renaming ( _‚âà_ to _‚âà·¥Æ_ )

 record _‚âÖ_ : Type (ùìû ‚äî ùì• ‚äî Œ± ‚äî œÅ·µÉ ‚äî Œ≤ ‚äî œÅ·µá ) where
  constructor  mkiso
  field        to    : hom ùë® ùë©
               from  : hom ùë© ùë®
               to‚àºfrom : ‚àÄ b ‚Üí ‚à£ to ‚à£    ‚ü®$‚ü© (‚à£ from ‚à£  ‚ü®$‚ü© b)  ‚âà·¥Æ b
               from‚àºto : ‚àÄ a ‚Üí ‚à£ from ‚à£  ‚ü®$‚ü© (‚à£ to ‚à£    ‚ü®$‚ü© a)  ‚âà·¥¨ a

  toIsInjective : IsInjective ‚à£ to ‚à£
  toIsInjective {x}{y} xy = trans (sym (from‚àºto x)) (trans Œæ (from‚àºto y))
   where  open Setoid ùîª[ ùë® ] using ( sym ; trans )
          Œæ : ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© x) ‚âà·¥¨ ‚à£ from ‚à£ ‚ü®$‚ü© (‚à£ to ‚à£ ‚ü®$‚ü© y)
          Œæ = cong ‚à£ from ‚à£ xy

  fromIsSurjective : IsSurjective ‚à£ from ‚à£
  fromIsSurjective {x} = eq (‚à£ to ‚à£ ‚ü®$‚ü© x) (sym (from‚àºto x))
   where open Setoid ùîª[ ùë® ] using ( sym )

open _‚âÖ_

\end{code}

It is easy to prove that \ar{\au{}‚âÖ\au{}} is an equivalence relation, as follows.

\begin{code}

‚âÖ-refl : Reflexive (_‚âÖ_ {Œ±}{œÅ·µÉ})
‚âÖ-refl {Œ±}{œÅ·µÉ}{ùë®} =
 mkiso ùíæùíπ ùíæùíπ (Œª b ‚Üí refl) Œª a ‚Üí refl where open Setoid ùîª[ ùë® ] using ( refl )

‚âÖ-sym : Sym (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ})
‚âÖ-sym œÜ = mkiso (from œÜ) (to œÜ) (from‚àºto œÜ) (to‚àºfrom œÜ)

‚âÖ-trans : Trans (_‚âÖ_ {Œ±}{œÅ·µÉ}) (_‚âÖ_{Œ≤}{œÅ·µá}) (_‚âÖ_{Œ±}{œÅ·µÉ}{Œ≥}{œÅ·∂ú})
‚âÖ-trans {œÅ·∂ú = œÅ·∂ú}{ùë®}{ùë©}{ùë™} ab bc = mkiso f g œÑ ŒΩ where
  f : hom ùë® ùë™                ;  g : hom ùë™ ùë®
  f = ‚àò-hom (to ab) (to bc)  ;  g = ‚àò-hom (from bc) (from ab)

  open Setoid ùîª[ ùë® ] using ( _‚âà_ ; trans )
  open Setoid ùîª[ ùë™ ] using () renaming ( _‚âà_ to _‚âà·∂ú_ ; trans to trans·∂ú )
  œÑ : ‚àÄ b ‚Üí ‚à£ f ‚à£ ‚ü®$‚ü© (‚à£ g ‚à£ ‚ü®$‚ü© b) ‚âà·∂ú b
  œÑ b = trans·∂ú (cong ‚à£ to bc ‚à£ (to‚àºfrom ab (‚à£ from bc ‚à£ ‚ü®$‚ü© b))) (to‚àºfrom bc b)

  ŒΩ : ‚àÄ a ‚Üí ‚à£ g ‚à£ ‚ü®$‚ü© (‚à£ f ‚à£ ‚ü®$‚ü© a) ‚âà a
  ŒΩ a = trans (cong ‚à£ from ab ‚à£ (from‚àºto bc (‚à£ to ab ‚à£ ‚ü®$‚ü© a))) (from‚àºto ab a)
\end{code}

##### <a id="homomorphic-images">Homomorphic images</a>
 <!-- {#homomorphic-images .unnumbered} -->

We have found that a useful way to encode the concept of *homomorphic image* is to
produce a witness, that is, a surjective hom. Thus we define the type of
surjective homs and also record the fact that an algebra is its own homomorphic
image via the identity hom.

\begin{code}

ov : Level ‚Üí Level         -- shorthand for a common level transformation
ov Œ± = ùìû ‚äî ùì• ‚äî suc Œ±

_IsHomImageOf_ : (ùë© : Algebra Œ≤ œÅ·µá)(ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Type _
ùë© IsHomImageOf ùë® = Œ£[ œÜ ‚àà hom ùë® ùë© ] IsSurjective ‚à£ œÜ ‚à£

IdHomImage : {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® IsHomImageOf ùë®
IdHomImage {Œ± = Œ±}{ùë® = ùë®} = ùíæùíπ , Œª {y} ‚Üí Image_‚àã_.eq y refl
 where open Setoid ùîª[ ùë® ] using ( refl )
\end{code}


##### <a id="factorization-of-homomorphisms">Factorization of homomorphisms</a>
 <!-- {#factorization-of-homomorphisms .unnumbered} -->

Another theorem in the [agda-algebras][] library, called `HomFactor`, formalizes
the following factorization result: if `g : hom ùë® ùë©`, `h : hom ùë® ùë™`, `h` is
surjective, and `ker h ‚äÜ ker g`, then there exists `œÜ : hom ùë™ ùë©` such that `g = œÜ
‚àò h`. A special case of this result that we use below is the fact that the setoid
function factorization we saw above lifts to factorization of homomorphisms.
Moreover, we associate a homomorphism `h` with its image---which is (the domain
of) a subalgebra of the codomain of `h`---using the function `HomIm` defined
below.[^8]

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} where

 HomIm : (h : hom ùë® ùë©) ‚Üí Algebra _ _
 Domain (HomIm h) = Im ‚à£ h ‚à£
 Interp (HomIm h) ‚ü®$‚ü© (f , la) = (f ÃÇ ùë®) la
 cong (Interp (HomIm h)) {x1 , x2} {.x1 , y2} (‚â°.refl , e) =
  begin
      ‚à£ h ‚à£  ‚ü®$‚ü©         (Interp ùë®  ‚ü®$‚ü© (x1 , x2))  ‚âà‚ü® h-compatible                  ‚ü©
   Interp ùë©  ‚ü®$‚ü© (x1 , Œª x ‚Üí ‚à£ h ‚à£  ‚ü®$‚ü© x2 x)       ‚âà‚ü® cong (Interp ùë©) (‚â°.refl , e)  ‚ü©
   Interp ùë©  ‚ü®$‚ü© (x1 , Œª x ‚Üí ‚à£ h ‚à£  ‚ü®$‚ü© y2 x)       ‚âàÀò‚ü® h-compatible                 ‚ü©
      ‚à£ h ‚à£  ‚ü®$‚ü©         (Interp ùë®  ‚ü®$‚ü© (x1 , y2))  ‚àé
   where  open Setoid ùîª[ ùë© ] ; open SetoidReasoning ùîª[ ùë© ]
          open IsHom ‚à• h ‚à• renaming (compatible to h-compatible)

 toHomIm : (h : hom ùë® ùë©) ‚Üí hom ùë® (HomIm h)
 toHomIm h = toIm ‚à£ h ‚à£ , mkhom (reflÀ¢ ùîª[ ùë© ])

 fromHomIm : (h : hom ùë® ùë©) ‚Üí hom (HomIm h) ùë©
 fromHomIm h = fromIm ‚à£ h ‚à£ , mkhom (IsHom.compatible ‚à• h ‚à•)
\end{code}


##### <a id="sec:lift-al">Lift-Alg is an algebraic invariant</a>
 <!-- {#sec:lift-alg} -->

The `Lift-Alg` operation neatly resolves the technical problem of universe
non-cumulativity because isomorphism classes of algebras are closed under
`Lift-Alg`. 

\begin{code}

module _ {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì : Level} where
 Lift-‚âÖÀ° : ùë® ‚âÖ (Lift-AlgÀ° ùë® ‚Ñì)
 Lift-‚âÖÀ° = mkiso ToLiftÀ° FromLiftÀ° (ToFromLiftÀ°{ùë® = ùë®}) (FromToLiftÀ°{ùë® = ùë®}{‚Ñì})
 Lift-‚âÖ ≥ : ùë® ‚âÖ (Lift-Alg ≥ ùë® ‚Ñì)
 Lift-‚âÖ ≥ = mkiso ToLift ≥ FromLift ≥ (ToFromLift ≥{ùë® = ùë®}) (FromToLift ≥{ùë® = ùë®}{‚Ñì})

Lift-‚âÖ : {ùë® : Algebra Œ± œÅ·µÉ}{‚Ñì œÅ : Level} ‚Üí ùë® ‚âÖ (Lift-Alg ùë® ‚Ñì œÅ)
Lift-‚âÖ = ‚âÖ-trans Lift-‚âÖÀ° Lift-‚âÖ ≥
\end{code}

#### <a id="subalgebras">Subalgebras</a>

We say that `ùë®` is a *subalgebra* of `ùë©` and write `ùë® ‚â§ ùë©` just in case `ùë®` can be *homomorphically
embedded* in `ùë©`; in other terms, `ùë® ‚â§ ùë©` iff there exists an injective hom from `ùë®` to `ùë©`.

\begin{code}

_‚â§_ : Algebra Œ± œÅ·µÉ ‚Üí Algebra Œ≤ œÅ·µá ‚Üí Type _
ùë® ‚â§ ùë© = Œ£[ h ‚àà hom ùë® ùë© ] IsInjective ‚à£ h ‚à£

\end{code}
The subalgebra relation is reflexive, by the identity monomorphism (and transitive by composition of monomorphisms, hence, a *preorder*, though we won't need this fact here).

\begin{code}

‚â§-reflexive   :  {ùë® : Algebra Œ± œÅ·µÉ} ‚Üí ùë® ‚â§ ùë®
‚â§-reflexive = ùíæùíπ , id

\end{code}

<!-- If `ùíú : I ‚Üí Algebra Œ± œÅ·µÉ`, `‚Ñ¨ : I ‚Üí Algebra Œ≤ œÅ·µá` (families of -algebras) and if `‚Ñ¨ i ‚â§ ùíú i` for all `i : I`, then `‚®Ö ‚Ñ¨` is a subalgebra of `‚®Ö ùíú`. Below we will use to denote this fact. -->

We conclude this section with a definition that will be useful later; it simply converts a monomorphism into a proof of a subalgebra relationship.

\begin{code}

mon‚Üí‚â§ : {ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá} ‚Üí mon ùë® ùë© ‚Üí ùë® ‚â§ ùë©
mon‚Üí‚â§ {ùë® = ùë®}{ùë©} x = mon‚Üíintohom ùë® ùë© x
\end{code}

#### <a id="terms">Terms</a>

Fix a signature `ùëÜ` and let `X` denote an arbitrary nonempty collection of variable symbols. Such a collection is called a *context*. Assume the symbols in `X` are distinct from the operation symbols of `ùëÜ`, that is `X ‚à© ‚à£ ùëÜ ‚à£ = ‚àÖ`. A *word* in the language of `ùëÜ` is a finite sequence of members of `X ‚à™ ‚à£ ùëÜ ‚à£`. We denote the
concatenation of such sequences by simple juxtaposition. Let `S‚ÇÄ` denote the set of nullary operation symbols of `ùëÜ`. We define by induction on `n` the sets `T‚Çô` of *words* over `X ‚à™ ‚à£ ùëÜ ‚à£` as follows: `T‚ÇÄ := X ‚à™ S‚ÇÄ` and 
`T‚Çô‚Çä‚ÇÅ := T‚Çô ‚à™ ùíØ‚Çô`, where `ùíØ‚Çô` is the collection of all `f t` such that `f : ‚à£ ùëÜ ‚à£` and `t : ‚à• ùëÜ ‚à• f ‚Üí ùëá‚Çô`.
(Recall, `‚à• ùëÜ ‚à• f` is the arity of the operation symbol `f`.)
An `ùëÜ`-*term* is a term in the language of `ùëÜ` and the collection of all `ùëÜ`-terms in the context `X` is `Term X := ‚ãÉ‚Çô T‚Çô`.

In type theory, this translates to two cases: variable injection and applying an operation symbol to a tuple of terms. This represents each term as a tree with an operation symbol at each `node` and a variable symbol at
each leaf `‚Ñä`; hence the constructor names (`‚Ñä` for "generator" and `node` for "node") in the following inductively defined type.

\begin{code}

data Term (X : Type œá) : Type (ov œá)  where
 ‚Ñä : X ‚Üí Term X
 node : (f : ‚à£ ùëÜ ‚à£)(t : ‚à• ùëÜ ‚à• f ‚Üí Term X) ‚Üí Term X
\end{code}

##### <a id="the-term-algebra">The term algebra</a>
 <!-- {#the-term-algebra .unnumbered} -->

We enrich the `Term` type to a setoid of `ùëÜ`-terms, which will ultimately be the domain of an algebra, called the *term algebra in the signature* `ùëÜ`. For this we need an equivalence relation on terms.

\begin{code}

module _ {X : Type œá } where

 data _‚âÉ_ : Term X ‚Üí Term X ‚Üí Type (ov œá) where
  rfl : {x y : X} ‚Üí x ‚â° y ‚Üí (‚Ñä x) ‚âÉ (‚Ñä y)
  gnl : ‚àÄ {f}{s t : ‚à• ùëÜ ‚à• f ‚Üí Term X} ‚Üí (‚àÄ i ‚Üí (s i) ‚âÉ (t i)) ‚Üí (node f s) ‚âÉ (node f t)

\end{code}

It is easy to show that `_‚âÉ_` is an equivalence relation as follows.

\begin{code}

 ‚âÉ-isRefl   : Reflexive      _‚âÉ_
 ‚âÉ-isRefl {‚Ñä _} = rfl ‚â°.refl
 ‚âÉ-isRefl {node _ _} = gnl Œª _ ‚Üí ‚âÉ-isRefl

 ‚âÉ-isSym    : Symmetric      _‚âÉ_
 ‚âÉ-isSym (rfl x) = rfl (‚â°.sym x)
 ‚âÉ-isSym (gnl x) = gnl Œª i ‚Üí ‚âÉ-isSym (x i)

 ‚âÉ-isTrans  : Transitive     _‚âÉ_
 ‚âÉ-isTrans (rfl x) (rfl y) = rfl (‚â°.trans x y)
 ‚âÉ-isTrans (gnl x) (gnl y) = gnl Œª i ‚Üí ‚âÉ-isTrans (x i) (y i)

 ‚âÉ-isEquiv  : IsEquivalence  _‚âÉ_
 ‚âÉ-isEquiv = record { refl = ‚âÉ-isRefl ; sym = ‚âÉ-isSym ; trans = ‚âÉ-isTrans }
\end{code}

For a given signature `ùëÜ` and context `X`, we define the algebra `ùëª X`, known as the *term algebra in* 
`ùëÜ` *over* `X`. The domain of `ùëª X` is `Term X` and, for each operation symbol `f : ‚à£ ùëÜ ‚à£`, we define 
`f ÃÇ ùëª X` to be the operation which maps each tuple `t : ‚à• ùëÜ ‚à• f ‚Üí Term X` of terms to the formal
term `f t`.

\begin{code}

TermSetoid : (X : Type œá) ‚Üí Setoid _ _
TermSetoid X = record { Carrier = Term X ; _‚âà_ = _‚âÉ_ ; isEquivalence = ‚âÉ-isEquiv }

ùëª : (X : Type œá) ‚Üí Algebra (ov œá) (ov œá)
Algebra.Domain (ùëª X) = TermSetoid X
Algebra.Interp (ùëª X) ‚ü®$‚ü© (f , ts) = node f ts
cong (Algebra.Interp (ùëª X)) (‚â°.refl , ss‚âÉts) = gnl ss‚âÉts
\end{code}

##### <a id="environments-and-interpretation-of-terms">Environments and interpretation of terms</a>
 <!-- {#environments-and-interpretation-of-terms .unnumbered} -->

Fix a signature `ùëÜ` and a context `X`. An *environment* for `ùë®` and `X` is a setoid whose carrier
is a mapping from the variable symbols `X` to the domain `ùïå[ ùê¥ ]` and whose equivalence relation is 
point-wise equality. Our formalization of this concept is the same as that of¬†[@Abel:2021], which 
Abel uses to formalize Birkhoff's completeness theorem.

\begin{code}

module Environment (ùë® : Algebra Œ± ‚Ñì) where
 open Setoid ùîª[ ùë® ] using ( _‚âà_ ; refl ; sym ; trans )

 Env : Type œá ‚Üí Setoid _ _
 Env X = record  { Carrier = X ‚Üí ùïå[ ùë® ]
                 ; _‚âà_ = Œª œÅ œÑ ‚Üí (x : X) ‚Üí œÅ x ‚âà œÑ x
                 ; isEquivalence = record  { refl   = Œª _      ‚Üí refl
                                           ; sym    = Œª h x    ‚Üí sym (h x)
                                           ; trans  = Œª g h x  ‚Üí trans (g x)(h x) }}

\end{code}
The *interpretation* of a term *evaluated* in a particular environment is defined as follows.

\begin{code}

 ‚ü¶_‚üß : {X : Type œá}(t : Term X) ‚Üí (Env X) ‚ü∂ ùîª[ ùë® ]
 ‚ü¶ ‚Ñä x ‚üß          ‚ü®$‚ü© œÅ    = œÅ x
 ‚ü¶ node f args ‚üß  ‚ü®$‚ü© œÅ    = (Interp ùë®) ‚ü®$‚ü© (f , Œª i ‚Üí ‚ü¶ args i ‚üß ‚ü®$‚ü© œÅ)
 cong ‚ü¶ ‚Ñä x ‚üß u‚âàv          = u‚âàv x
 cong ‚ü¶ node f args ‚üß x‚âày  = cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí cong ‚ü¶ args i ‚üß x‚âày )

\end{code}
Two terms are proclaimed *equal* if they are equal for all environments.

\begin{code}

 Equal : {X : Type œá}(s t : Term X) ‚Üí Type _
 Equal {X = X} s t = ‚àÄ (œÅ : Carrier (Env X)) ‚Üí ‚ü¶ s ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ t ‚üß ‚ü®$‚ü© œÅ

\end{code}
Proof that `Equal` is an equivalence relation, and that the implication `s ‚âÉ t ‚Üí Equal s t` holds for all terms `s` and `t`, are also found in¬†[@Abel:2021]. We reproduce them here to keep the presentation self-contained.

\begin{code}

 ‚âÉ‚ÜíEqual : {X : Type œá}(s t : Term X) ‚Üí s ‚âÉ t ‚Üí Equal s t
 ‚âÉ‚ÜíEqual .(‚Ñä _) .(‚Ñä _) (rfl ‚â°.refl) = Œª _ ‚Üí refl
 ‚âÉ‚ÜíEqual (node _ s)(node _ t)(gnl x) =
  Œª œÅ ‚Üí cong (Interp ùë®)(‚â°.refl , Œª i ‚Üí ‚âÉ‚ÜíEqual(s i)(t i)(x i)œÅ )

 EqualIsEquiv : {Œì : Type œá} ‚Üí IsEquivalence (Equal {X = Œì})
 refl·µâ   EqualIsEquiv = Œª _        ‚Üí refl
 sym·µâ    EqualIsEquiv = Œª x=y œÅ    ‚Üí sym (x=y œÅ)
 trans·µâ  EqualIsEquiv = Œª ij jk œÅ  ‚Üí trans (ij œÅ) (jk œÅ)
\end{code}



##### <a id="compatibility-of-terms">Compatibility of terms</a>
 <!-- {#compatibility-of-terms .unnumbered} -->

We need to formalize two more concepts involving terms.
The first (`comm-hom-term`) is the assertion that every term commutes with every homomorphism, and
the second (`interp-prod`) is the interpretation of a term in a product algebra.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}(hh : hom ùë® ùë©) where
 open Environment ùë®  using ( ‚ü¶_‚üß )
 open Environment ùë©  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥Æ )
 open Setoid ùîª[ ùë© ]  using ( _‚âà_ ; refl  )
 private hfunc = ‚à£ hh ‚à£ ; h = _‚ü®$‚ü©_ hfunc

 comm-hom-term : (t : Term X) (a : X ‚Üí ùïå[ ùë® ]) ‚Üí h (‚ü¶ t ‚üß ‚ü®$‚ü© a) ‚âà ‚ü¶ t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)
 comm-hom-term (‚Ñä x) a = refl
 comm-hom-term (node f t) a =  begin
   h(‚ü¶ node f t ‚üß ‚ü®$‚ü© a)            ‚âà‚ü® compatible ‚à• hh ‚à• ‚ü©
   (f ÃÇ ùë©)(Œª i ‚Üí h(‚ü¶ t i ‚üß ‚ü®$‚ü© a))  ‚âà‚ü® cong(Interp ùë©)(‚â°.refl , Œª i ‚Üí comm-hom-term(t i) a) ‚ü©
   ‚ü¶ node f t ‚üß·¥Æ ‚ü®$‚ü© (h ‚àò a)   ‚àé where open SetoidReasoning ùîª[ ùë© ]

module _ {X : Type œá}{Œπ : Level} {I : Type Œπ} (ùíú : I ‚Üí Algebra Œ± œÅ·µÉ) where
 open Setoid ùîª[ ‚®Ö ùíú ]  using ( _‚âà_ )
 open Environment      using ( ‚ü¶_‚üß ; ‚âÉ‚ÜíEqual )

 interp-prod : (p : Term X) ‚Üí ‚àÄ œÅ ‚Üí  (‚ü¶ ‚®Ö ùíú ‚üß p) ‚ü®$‚ü© œÅ   ‚âà   Œª i ‚Üí (‚ü¶ ùíú i ‚üß p) ‚ü®$‚ü© Œª x ‚Üí (œÅ x) i
 interp-prod (‚Ñä x)       = Œª œÅ i  ‚Üí ‚âÉ‚ÜíEqual (ùíú i) (‚Ñä x) (‚Ñä x) ‚âÉ-isRefl Œª _ ‚Üí (œÅ x) i
 interp-prod (node f t)  = Œª œÅ    ‚Üí cong (Interp (‚®Ö ùíú)) ( ‚â°.refl , Œª j k ‚Üí interp-prod (t j) œÅ k )
\end{code}

### <a id="equational-logic">Equational Logic</a>

#### <a id="term-identities-equational-theories-and-the-relation">Term identities, equational theories, and the ‚äß relation</a>
 <!-- {#term-identities-equational-theories-and-the-relation .unnumbered} -->

An `ùëÜ`-*term equation* (or `ùëÜ`-*term identity*) is an ordered pair `(p , q)` of `ùëÜ`-terms, also denoted by `p ‚âà q`. They are often simply called *equations* or *identities*, especially when the signature `ùëÜ` is evident.
We define an *equational theory* (or *algebraic theory*) to be a pair `T = (ùëÜ , ‚Ñ∞)` consisting of a signature `ùëÜ` and a collection `‚Ñ∞` of `ùëÜ`-term equations.[^9]

We say that the algebra `ùë®` *models* the identity `p ‚âà q` and we write `ùë® ‚äß p ‚âà q`
if for all `œÅ : X ‚Üí ùîª[ ùë® ]` we have `‚ü¶ p ‚üß ‚ü®$‚ü© œÅ ‚âà ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ`.
In other words, when interpreted in the algebra `ùë®`, the terms `p` and `q` are equal no matter what values are assigned to variable symbols occurring in `p` and `q`.

If `ùí¶` is a class of algebras of a given signature, then we write `ùí¶ ‚ä´ p ‚âà q` and say that `ùí¶` *models* the identity `p ‚âà q` provided `ùë® ‚äß p ‚âà q` for every `ùë® ‚àà ùí¶`.

\begin{code}

module _ {X : Type œá} where
 _‚äß_‚âà_ : Algebra Œ± œÅ·µÉ ‚Üí Term X ‚Üí Term X ‚Üí Type _
 ùë® ‚äß p ‚âà q = Equal p q where open Environment ùë®

 _‚ä´_‚âà_ : Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Term X ‚Üí Term X ‚Üí Type _
 ùí¶ ‚ä´ p ‚âà q = ‚àÄ ùë® ‚Üí ùí¶ ùë® ‚Üí ùë® ‚äß p ‚âà q

\end{code}
We represent a set of term identities as a predicate over pairs of terms, say, `‚Ñ∞ :  Pred(Term X √ó Term X)`, and we denote by `ùë® ‚ä® ‚Ñ∞` the assertion that `ùë®` models `p ‚âà q` for all `(p, q) ‚àà ‚Ñ∞`.

\begin{code}

 _‚ä®_ : (ùë® : Algebra Œ± œÅ·µÉ) ‚Üí Pred(Term X √ó Term X)(ov œá) ‚Üí Type _
 ùë® ‚ä® ‚Ñ∞ = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®

\end{code}
(The symbol `‚ä®` is a stretched version of the models symbol `‚äß`,
so [Agda][] can distinguish between the two and parse expressions involving the types
`_‚ä®_` and `_‚äß_‚âà_`. In Emacs `agda2-mode`, the symbol `‚ä®` is produced by typing
`\|=`, while `‚äß` is produced with `\models`.)

An important property of the binary relation `‚äß` is *algebraic invariance* (i.e.,
invariance under isomorphism).  We formalize this property as follows.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(ùë© : Algebra Œ≤ œÅ·µá)(p q : Term X) where
 ‚äß-I-invar : ùë® ‚äß p ‚âà q  ‚Üí  ùë® ‚âÖ ùë©  ‚Üí  ùë© ‚äß p ‚âà q
 ‚äß-I-invar Apq (mkiso fh gh f‚àºg g‚àºf) œÅ = begin
  ‚ü¶ p ‚üß     ‚ü®$‚ü©             œÅ    ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß (f‚àºg ‚àò œÅ)        ‚ü©
  ‚ü¶ p ‚üß     ‚ü®$‚ü© (f ‚àò  (g ‚àò  œÅ))  ‚âàÀò‚ü®  comm-hom-term fh p (g ‚àò œÅ)  ‚ü©
  f(‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü©       (g ‚àò  œÅ))  ‚âà‚ü®   cong ‚à£ fh ‚à£ (Apq (g ‚àò œÅ))   ‚ü©
  f(‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü©       (g ‚àò  œÅ))  ‚âà‚ü®   comm-hom-term fh q (g ‚àò œÅ)  ‚ü©
  ‚ü¶ q ‚üß     ‚ü®$‚ü© (f ‚àò  (g ‚àò  œÅ))  ‚âà‚ü®   cong ‚ü¶ q ‚üß (f‚àºg ‚àò œÅ)        ‚ü©
  ‚ü¶ q ‚üß     ‚ü®$‚ü©             œÅ    ‚àé
  where  private f = _‚ü®$‚ü©_ ‚à£ fh ‚à£ ; g = _‚ü®$‚ü©_ ‚à£ gh ‚à£
         open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨ )
         open Environment ùë©  using ( ‚ü¶_‚üß ) ; open SetoidReasoning ùîª[ ùë© ]

\end{code}
If `ùí¶` is a class of `ùëÜ`-algebras, the set of identities modeled by `ùí¶`, denoted `Th ùí¶`, is called the *equational theory* of `ùí¶`. If `‚Ñ∞` is a set of `ùëÜ`-term identities,
the class of algebras modeling `‚Ñ∞`, denoted `Mod ‚Ñ∞`, is called the *equational class axiomatized* by `‚Ñ∞`. We codify these notions in the next two definitions.

\begin{code}

Th : {X : Type œá} ‚Üí Pred (Algebra Œ± œÅ·µÉ) ‚Ñì ‚Üí Pred(Term X √ó Term X) _
Th ùí¶ = Œª (p , q) ‚Üí ùí¶ ‚ä´ p ‚âà q

Mod : {X : Type œá} ‚Üí Pred(Term X √ó Term X) ‚Ñì ‚Üí Pred (Algebra Œ± œÅ·µÉ) _
Mod ‚Ñ∞ ùë® = ‚àÄ {p q} ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí Equal p q where open Environment ùë®
\end{code}

#### <a id="the-closure-operators-h-s-p-and-v">The Closure Operators H, S, P and V</a>
 <!-- {#the-closure-operators-h-s-p-and-v .unnumbered} -->

Fix a signature `ùëÜ`, let `ùí¶` be a class of `ùëÜ`-algebras, and define
* `H ùí¶` := the class of all homomorphic images of members of `ùí¶`;
* `S ùí¶` := the class of all subalgebras of members of `ùí¶`;
* `P ùí¶` := the class of all products of members of `ùí¶`.

`H`, `S`, and `P` are *closure operators* (expansive, monotone, and idempotent).  
A class `ùí¶` of `ùëÜ`-algebras is said to be *closed under the taking of homomorphic images* 
provided `H ùí¶ ‚äÜ ùí¶`. Similarly, `ùí¶` is *closed under the taking of subalgebras* (resp., *arbitrary products*) provided `S ùí¶ ‚äÜ ùí¶` (resp., `P ùí¶ ‚äÜ ùí¶`). The operators `H`, `S`, and `P` can be composed with one another repeatedly, forming yet more closure operators. We represent these three closure operators in type theory as follows.

\begin{code}

module _ {Œ± œÅ·µÉ Œ≤ œÅ·µá : Level} where
 private a = Œ± ‚äî œÅ·µÉ
 H : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 H _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© IsHomImageOf ùë®

 S : ‚àÄ ‚Ñì ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 S _ ùí¶ ùë© = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó ùë© ‚â§ ùë®

 P : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí Pred(Algebra Œ≤ œÅ·µá) _
 P _ Œπ ùí¶ ùë© = Œ£[ I ‚àà Type Œπ ] (Œ£[ ùíú ‚àà (I ‚Üí Algebra Œ± œÅ·µÉ) ] (‚àÄ i ‚Üí ùíú i ‚àà ùí¶) √ó (ùë© ‚âÖ ‚®Ö ùíú))

\end{code}
Identities modeled by an algebra `ùë®` are also modeled by every homomorphic image of
`ùë®` and by every subalgebra of `ùë®`. These facts are formalized in [Agda][] as follows.

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}{ùë© : Algebra Œ≤ œÅ·µá}{p q : Term X} where
 ‚äß-H-invar : ùë® ‚äß p ‚âà q ‚Üí ùë© IsHomImageOf ùë® ‚Üí ùë© ‚äß p ‚âà q
 ‚äß-H-invar Apq (œÜh , œÜE) œÅ = begin
       ‚ü¶ p ‚üß   ‚ü®$‚ü©               œÅ    ‚âàÀò‚ü®  cong ‚ü¶ p ‚üß(Œª _ ‚Üí InvIsInverse ≥ œÜE)  ‚ü©
       ‚ü¶ p ‚üß   ‚ü®$‚ü© (œÜ ‚àò  œÜ‚Åª¬π  ‚àò  œÅ)   ‚âàÀò‚ü®  comm-hom-term œÜh p (œÜ‚Åª¬π ‚àò œÅ)        ‚ü©
   œÜ(  ‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü© (     œÜ‚Åª¬π  ‚àò  œÅ))  ‚âà‚ü®   cong ‚à£ œÜh ‚à£ (Apq (œÜ‚Åª¬π ‚àò œÅ))         ‚ü©
   œÜ(  ‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü© (     œÜ‚Åª¬π  ‚àò  œÅ))  ‚âà‚ü®   comm-hom-term œÜh q (œÜ‚Åª¬π ‚àò œÅ)        ‚ü©
       ‚ü¶ q ‚üß   ‚ü®$‚ü© (œÜ ‚àò  œÜ‚Åª¬π  ‚àò  œÅ)   ‚âà‚ü®   cong ‚ü¶ q ‚üß(Œª _ ‚Üí InvIsInverse ≥ œÜE)  ‚ü©
       ‚ü¶ q ‚üß   ‚ü®$‚ü©               œÅ    ‚àé where
   œÜ‚Åª¬π : ùïå[ ùë© ] ‚Üí ùïå[ ùë® ]
   œÜ‚Åª¬π = SurjInv ‚à£ œÜh ‚à£ œÜE
   private œÜ = (_‚ü®$‚ü©_ ‚à£ œÜh ‚à£)
   open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨)
   open Environment ùë©  using ( ‚ü¶_‚üß ) ; open SetoidReasoning ùîª[ ùë© ]

 ‚äß-S-invar : ùë® ‚äß p ‚âà q ‚Üí ùë© ‚â§ ùë® ‚Üí ùë© ‚äß p ‚âà q
 ‚äß-S-invar Apq B‚â§A b = ‚à• B‚â§A ‚à•
  ( begin
    h (  ‚ü¶ p ‚üß   ‚ü®$‚ü©       b)  ‚âà‚ü®   comm-hom-term hh p b  ‚ü©
         ‚ü¶ p ‚üß·¥¨  ‚ü®$‚ü© (h ‚àò  b)  ‚âà‚ü®   Apq (h ‚àò b)           ‚ü©
         ‚ü¶ q ‚üß·¥¨  ‚ü®$‚ü© (h ‚àò  b)  ‚âàÀò‚ü®  comm-hom-term hh q b  ‚ü©
    h (  ‚ü¶ q ‚üß   ‚ü®$‚ü©       b)  ‚àé )
  where
  open SetoidReasoning ùîª[ ùë® ]
  open Setoid ùîª[ ùë® ]  using ( _‚âà_ )
  open Environment ùë®  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß·¥¨ )
  open Environment ùë©  using ( ‚ü¶_‚üß )
  private hh = ‚à£ B‚â§A ‚à£ ; h = _‚ü®$‚ü©_ ‚à£ hh ‚à£

\end{code}
An identity satisfied by all algebras in an indexed collection is also satisfied by the product of algebras in the collection.

\begin{code}

module _ {X : Type œá}{I : Type ‚Ñì}(ùíú : I ‚Üí Algebra Œ± œÅ·µÉ){p q : Term X} where
 ‚äß-P-invar : (‚àÄ i ‚Üí ùíú i ‚äß p ‚âà q) ‚Üí ‚®Ö ùíú ‚äß p ‚âà q
 ‚äß-P-invar ùíúpq a = begin
   ‚ü¶ p ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚âà‚ü®   interp-prod ùíú p a            ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß p)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âà‚ü® (Œª i ‚Üí ùíúpq i (Œª x ‚Üí (a x) i))  ‚ü©
   ( Œª i ‚Üí (‚ü¶ ùíú i ‚üß q)  ‚ü®$‚ü©  Œª x ‚Üí (a x) i )  ‚âàÀò‚ü®  interp-prod ùíú q a            ‚ü©
   ‚ü¶ q ‚üß‚ÇÅ               ‚ü®$‚ü©  a                ‚àé where
  open Environment (‚®Ö ùíú)  using () renaming ( ‚ü¶_‚üß to ‚ü¶_‚üß‚ÇÅ )
  open Environment        using ( ‚ü¶_‚üß )
  open Setoid ùîª[ ‚®Ö ùíú ]    using ( _‚âà_ )
  open SetoidReasoning ùîª[ ‚®Ö ùíú ]

\end{code}

A *variety* is a class of `ùëÜ`-algebras that is closed under the taking of homomorphic images, subalgebras, and arbitrary products. If we define `V ùí¶ := H (S (P ùí¶))`, then `ùí¶` is a variety iff `V ùí¶  ‚äÜ ùí¶`.
(The converse inclusion holds by virtue of the fact that `V` is a composition of closure operators.)
The class `V ùí¶` is called the *varietal closure* of `ùí¶`. Here is how we define `V` in type theory.
(The explicit universe level declarations that appear in the definition are needed for disambiguation.)

\begin{code}

module _  {Œ± œÅ·µÉ Œ≤ œÅ·µá Œ≥ œÅ·∂ú Œ¥ œÅ·µà : Level} where
 private a = Œ± ‚äî œÅ·µÉ ; b = Œ≤ ‚äî œÅ·µá
 V : ‚àÄ ‚Ñì Œπ ‚Üí Pred(Algebra Œ± œÅ·µÉ) (a ‚äî ov ‚Ñì) ‚Üí  Pred(Algebra Œ¥ œÅ·µà) _
 V ‚Ñì Œπ ùí¶ = H{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} (a ‚äî b ‚äî ‚Ñì ‚äî Œπ) (S{Œ≤}{œÅ·µá} (a ‚äî ‚Ñì ‚äî Œπ) (P ‚Ñì Œπ ùí¶))

\end{code}

The classes `H ùí¶`, `S ùí¶`, `P ùí¶`, and `V ùí¶` all satisfy the
same term identities.  We will only use a subset of the inclusions needed to prove this
assertion. (The others are included in the `Setoid.Varieties.Preservation` module of the [agda-algebras][] library.) First, the closure operator `H` preserves the identities modeled by the given class; this follows almost immediately from the invariance lemma `‚äß-H-invar`.

\begin{code}

module _  {X : Type œá}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
 H-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí H{Œ≤ = Œ±}{œÅ·µÉ}‚Ñì ùí¶ ‚ä´ p ‚âà q
 H-id1 œÉ ùë© (ùë® , kA , BimgA) = ‚äß-H-invar{p = p}{q} (œÉ ùë® kA) BimgA

\end{code}
The analogous preservation result for `S` is a consequence of the invariance lemma `‚äß-S-invar`; the converse, which we call `S-id2`, has an equally straightforward proof.

\begin{code}

 S-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí S{Œ≤ = Œ±}{œÅ·µÉ}‚Ñì ùí¶ ‚ä´ p ‚âà q
 S-id1 œÉ ùë© (ùë® , kA , B‚â§A) = ‚äß-S-invar{p = p}{q} (œÉ ùë® kA) B‚â§A

 S-id2 : S ‚Ñì ùí¶ ‚ä´ p ‚âà q ‚Üí ùí¶ ‚ä´ p ‚âà q
 S-id2 Spq ùë® kA = Spq ùë® (ùë® , (kA , ‚â§-reflexive))

\end{code}
The [agda-algebras][] library includes analogous pairs of implications for `P`, `H`, and `V`, called `P-id1`, `P-id2`, `H-id1`, etc. Here we only need the first implication in each case, so we omit the others.

\begin{code}

 P-id1 : ‚àÄ{Œπ} ‚Üí ùí¶ ‚ä´ p ‚âà q ‚Üí P{Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶ ‚ä´ p ‚âà q
 P-id1 œÉ ùë® (I , ùíú , kA , A‚âÖ‚®ÖA) = ‚äß-I-invar ùë® p q IH (‚âÖ-sym A‚âÖ‚®ÖA) where
  IH : ‚®Ö ùíú ‚äß p ‚âà q
  IH = ‚äß-P-invar ùíú {p}{q} Œª i ‚Üí œÉ (ùíú i) (kA i)

module _ {X : Type œá}{Œπ : Level}(‚Ñì : Level){ùí¶ : Pred(Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)}{p q : Term X} where
 private a‚ÑìŒπ = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ‚äî Œπ
 V-id1 : ùí¶ ‚ä´ p ‚âà q ‚Üí V ‚Ñì Œπ ùí¶ ‚ä´ p ‚âà q
 V-id1 œÉ ùë© (ùë® , (‚®ÖA , p‚®ÖA , A‚â§‚®ÖA) , BimgA) =
  H-id1{‚Ñì = a‚ÑìŒπ}{ùí¶ = S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)}{p = p}{q} spK‚äßpq ùë© (ùë® , (spA , BimgA)) where
   spA : ùë® ‚àà S a‚ÑìŒπ (P {Œ≤ = Œ±}{œÅ·µÉ}‚Ñì Œπ ùí¶)
   spA = ‚®ÖA , (p‚®ÖA , A‚â§‚®ÖA)
   spK‚äßpq : S a‚ÑìŒπ (P ‚Ñì Œπ ùí¶) ‚ä´ p ‚âà q
   spK‚äßpq = S-id1{‚Ñì = a‚ÑìŒπ}{p = p}{q} (P-id1{‚Ñì = ‚Ñì} {ùí¶ = ùí¶}{p = p}{q} œÉ)
\end{code}


### <a id="free-algebras">Free Algebras</a>

#### <a id="the-absolutely-free-algebra">The absolutely free algebra</a>
 <!-- {#the-absolutely-free-algebra .unnumbered} -->

The term algebra `ùëª X` is the *absolutely free* `ùëÜ`-algebra over `X`.
That is, for every `ùëÜ`-algebra `ùë®`, the following hold.
* Every function from `X` to `ùïå[ ùë® ]` lifts to a homomorphism from `ùëª X` to `ùë®`.
* That homomorphism is unique.
Here we formalize the first of these properties by defining the lifting function `free-lift`
and its setoid analog `free-lift-func`, and then proving the latter is a homomorphism.
(For the proof of uniqueness, see the `Setoid.Terms.Properties` module of the [agda-algebras][] library.)

\begin{code}

module _ {X : Type œá}{ùë® : Algebra Œ± œÅ·µÉ}(h : X ‚Üí ùïå[ ùë® ]) where
 free-lift : ùïå[ ùëª X ] ‚Üí ùïå[ ùë® ]
 free-lift (‚Ñä x)       = h x
 free-lift (node f t)  = (f ÃÇ ùë®) Œª i ‚Üí free-lift (t i)

 free-lift-func : ùîª[ ùëª X ] ‚ü∂ ùîª[ ùë® ]
 free-lift-func ‚ü®$‚ü© x = free-lift x
 cong free-lift-func = flcong where
  open Setoid ùîª[ ùë® ] using ( _‚âà_ ) renaming ( reflexive to reflexive·¥¨ )
  flcong : ‚àÄ {s t} ‚Üí s ‚âÉ t ‚Üí free-lift s ‚âà free-lift t
  flcong (_‚âÉ_.rfl x) = reflexive·¥¨ (‚â°.cong h x)
  flcong (_‚âÉ_.gnl x) = cong (Interp ùë®) (‚â°.refl , Œª i ‚Üí flcong (x i))

 lift-hom : hom (ùëª X) ùë®
 lift-hom = free-lift-func ,
   mkhom Œª{_}{a} ‚Üí cong (Interp ùë®) (‚â°.refl , Œª i ‚Üí (cong free-lift-func){a i} ‚âÉ-isRefl)

\end{code}

It turns out that the interpretation of a term `p` in an environment `Œ∑` is the same
as the free lift of `Œ∑` evaluated at `p`. We apply this fact a number of times in the sequel.

\begin{code}

module _  {X : Type œá} {ùë® : Algebra Œ± œÅ·µÉ}   where
 open Setoid ùîª[ ùë® ]  using ( _‚âà_ ; refl )
 open Environment ùë®  using ( ‚ü¶_‚üß )

 free-lift-interp : (Œ∑ : X ‚Üí ùïå[ ùë® ])(p : Term X) ‚Üí ‚ü¶ p ‚üß ‚ü®$‚ü© Œ∑ ‚âà (free-lift{ùë® = ùë®} Œ∑) p
 free-lift-interp Œ∑ (‚Ñä x)       = refl
 free-lift-interp Œ∑ (node f t)  = cong (Interp ùë®) (‚â°.refl , (free-lift-interp Œ∑) ‚àò t)
\end{code}

#### <a id="the-relatively-free-algebra">The relatively free algebra</a>
 <!-- {#the-relatively-free-algebra .unnumbered} -->

Given an arbitrary class `ùí¶` of `ùëÜ`-algebras, we cannot expect that `ùëª X` belongs to `ùí¶`.
Indeed, there may be no free algebra in `ùí¶`.
Nonetheless, it is always possible to construct an algebra that is free for `ùí¶` and belongs to the class `S (P ùí¶`).
Such an algebra is called a *relatively free algebra over* `X` (relative to `ùí¶`).
There are several informal approaches to defining this algebra.
We now describe the approach on which our formal construction is based and then we present the formalization.

Let `ùîΩ[ X ]` denote the relatively free algebra over `X`.  We represent `ùîΩ[ X ]` as the quotient `ùëª X / ‚âà` where `x ‚âà y` if and only if `h x = h y` for every homomorphism `h` from `ùëª X` into a member of `ùí¶`.
More precisely, if `ùë® ‚àà ùí¶` and `h : hom (ùëª X) ùë®`, then `h` factors as `ùëª X ‚Üí HomIm h  ‚Üí ùë®` and `ùëª X / ker h ‚âÖ HomIm h ‚â§ ùë®`; that is, `ùëª X / ker h` is (isomorphic to) an algebra in `S ùí¶`. Letting

`‚âà := ‚ãÇ \{Œ∏ ‚àà Con(ùëª X) ‚à£ ùëª X / Œ∏ ‚àà S ùí¶\}`,

observe that `ùîΩ[ X ] := ùëª X / ‚âà` is a subdirect product of the algebras `ùëª X / ker h`
as `h` ranges over all homomorphisms from `ùëª X` to algebras in `ùí¶`.  Thus, `ùîΩ[ X ] ‚àà P (S ùí¶) ‚äÜ S (P ùí¶)`.
As we have seen, every map `œÅ : X ‚Üí ùïå[ ùë® ]` extends uniquely to a homomorphism `h : hom (ùëª X) ùë®` and `h`
factors through the natural projection `ùëª X ‚Üí ùîΩ[ X ]` (since `‚âà ‚äÜ ker h`) yielding a unique homomorphism from `ùîΩ[ X ]` to `ùë®` extending `œÅ`.

In [Agda][] we construct `ùîΩ[ X ]` as a homomorphic image of `ùëª X` in the following way.
First, given `X` we define `ùë™` as the product of pairs `(ùë®, œÅ)` of
algebras `ùë® ‚àà ùí¶` along with environments `œÅ : X ‚Üí ùïå[ ùë® ]`.
To do so, we contrive an index type for the product; each index is a triple `(ùë®, p, œÅ)` where `ùë®` is an algebra, `p` is proof of `ùë® ‚àà ùí¶`, and `œÅ : X ‚Üí ùïå[ ùë® ]` is an arbitrary environment.

\begin{code}

module FreeAlgebra (ùí¶ : Pred (Algebra Œ± œÅ·µÉ) ‚Ñì) where
 private c = Œ± ‚äî œÅ·µÉ ; Œπ = ov c ‚äî ‚Ñì
 ‚Ñë : {œá : Level} ‚Üí Type œá ‚Üí Type (Œπ ‚äî œá)
 ‚Ñë X = Œ£[ ùë® ‚àà Algebra Œ± œÅ·µÉ ] ùë® ‚àà ùí¶ √ó (X ‚Üí ùïå[ ùë® ])

 ùë™ : {œá : Level} ‚Üí Type œá ‚Üí Algebra (Œπ ‚äî œá)(Œπ ‚äî œá)
 ùë™ X = ‚®Ö {I = ‚Ñë X} ‚à£_‚à£

\end{code}
We then define `ùîΩ[ X ]` to be the image of a homomorphism from `ùëª X` to `ùë™` as follows.

\begin{code}

 homC : (X : Type œá) ‚Üí hom (ùëª X) (ùë™ X)
 homC X = ‚®Ö-hom-co _ (Œª i ‚Üí lift-hom (snd ‚à• i ‚à•))

 ùîΩ[_] : {œá : Level} ‚Üí Type œá ‚Üí Algebra (ov œá) (Œπ ‚äî œá)
 ùîΩ[ X ] = HomIm (homC X)

\end{code}
Observe that if the identity `p ‚âà q` holds in all `ùë® ‚àà ùí¶` (for all environments), then `p ‚âà q` holds in `ùîΩ[ X ]`; equivalently, the pair `(p , q)` belongs to the kernel of the natural homomorphism from `ùëª X` onto `ùîΩ[ X ]`. This natural epimorphism from `ùëª X` onto `ùîΩ[ X ]`
is defined as follows.

\begin{code}

module FreeHom {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ; Œπ = ov c ‚äî ‚Ñì
 open FreeAlgebra ùí¶ using ( ùîΩ[_] ; homC )

 epiF[_] : (X : Type c) ‚Üí epi (ùëª X) ùîΩ[ X ]
 epiF[ X ] = ‚à£ toHomIm (homC X) ‚à£ , record  { isHom = ‚à• toHomIm (homC X) ‚à•
                                            ; isSurjective = toIm-surj ‚à£ homC X ‚à£ }

 homF[_] : (X : Type c) ‚Üí hom (ùëª X) ùîΩ[ X ]
 homF[ X ] = IsEpi.HomReduct ‚à• epiF[ X ] ‚à•

\end{code}

Before formalizing the HSP theorem in the next section, we need to prove the following important property of the relatively free algebra: For every algebra `ùë®`, if `ùë® ‚ä® Th (V ùí¶)`,
then there exists an epimorphism from `ùîΩ[ A ]` onto `ùë®`, where `A` denotes the carrier of `ùë®`.

\begin{code}

module _ {ùë® : Algebra (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)(Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)}{ùí¶ : Pred(Algebra Œ± œÅ·µÉ)(Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c
 open FreeAlgebra ùí¶ using ( ùîΩ[_] ; ùë™ )
 open Setoid ùîª[ ùë® ] using ( refl ; sym ; trans ) renaming ( Carrier to A ; _‚âà_ to _‚âà·¥¨_ )

 F-ModTh-epi : ùë® ‚àà Mod (Th ùí¶) ‚Üí epi ùîΩ[ A ]  ùë®
 F-ModTh-epi A‚ààModThK = œÜ , isEpi where

  œÜ : ùîª[ ùîΩ[ A ] ] ‚ü∂ ùîª[ ùë® ]
  _‚ü®$‚ü©_ œÜ            = free-lift{ùë® = ùë®} id
  cong œÜ {p} {q} pq  = Goal
   where
   lift-pq : (p , q) ‚àà Th ùí¶
   lift-pq ùë© x œÅ = begin
    ‚ü¶ p ‚üß ‚ü®$‚ü© œÅ    ‚âà‚ü® free-lift-interp {ùë® = ùë©} œÅ p  ‚ü©
    free-lift œÅ p  ‚âà‚ü® pq (ùë© , x , œÅ)                ‚ü©
    free-lift œÅ q  ‚âàÀò‚ü® free-lift-interp{ùë® = ùë©} œÅ q  ‚ü©
    ‚ü¶ q ‚üß ‚ü®$‚ü© œÅ    ‚àé
     where open SetoidReasoning ùîª[ ùë© ] ; open Environment ùë© using ( ‚ü¶_‚üß )

   Goal : free-lift id p ‚âà·¥¨ free-lift id q
   Goal = begin
    free-lift id p  ‚âàÀò‚ü® free-lift-interp {ùë® = ùë®} id p   ‚ü©
    ‚ü¶ p ‚üß ‚ü®$‚ü© id    ‚âà‚ü® A‚ààModThK {p = p} {q} lift-pq id  ‚ü©
    ‚ü¶ q ‚üß ‚ü®$‚ü© id    ‚âà‚ü® free-lift-interp {ùë® = ùë®} id q    ‚ü©
    free-lift id q  ‚àé
     where open SetoidReasoning ùîª[ ùë® ] ; open Environment ùë® using ( ‚ü¶_‚üß )

  isEpi : IsEpi ùîΩ[ A ] ùë® œÜ
  isEpi = record { isHom = mkhom refl ; isSurjective = eq (‚Ñä _) refl }

 F-ModThV-epi : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ A ]  ùë®
 F-ModThV-epi A‚ààModThVK = F-ModTh-epi Œª {p}{q} ‚Üí Goal {p}{q}
  where
  Goal : ùë® ‚àà Mod (Th ùí¶)
  Goal {p}{q} x œÅ = A‚ààModThVK{p}{q} (V-id1 ‚Ñì {p = p}{q} x) œÅ

\end{code}
Actually, we will need the following lifted version of this result.

\begin{code}

 F-ModTh-epi-lift : ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí epi ùîΩ[ A ] (Lift-Alg ùë® Œπ Œπ)
 F-ModTh-epi-lift A‚ààModThK = ‚àò-epi (F-ModThV-epi Œª {p q} ‚Üí A‚ààModThK{p = p}{q} ) ToLift-epi
\end{code}


### <a id="birkhoffs-variety-theorem">Birkhoff's Variety Theorem</a>

Let `ùí¶` be a class of algebras and recall that `ùí¶` is a *variety* provided
it is closed under homomorphisms, subalgebras and products; equivalently,
`V ùí¶ ‚äÜ ùí¶`.
(Observe that `ùí¶ ‚äÜ V ùí¶` holds for all `ùí¶` since `V` is a closure operator.)
We call `ùí¶` an *equational class* if it is the class of all models of some set of identities.

Birkhoff's variety theorem, also known as the HSP theorem, asserts that `ùí¶` is an equational class if and only if it is a variety.  In this section, we present the statement and proof of this theorem---first in a style similar to what one finds in textbooks (e.g.,¬†[@Bergman:2012 Theorem 4.41]), and then formally in the language of [MLTT][].


#### <a id="informal-proof">Informal proof</a>
 <!-- {#informal-proof .unnumbered} -->

(‚áí) *Every equational class is a variety*. Indeed, suppose `ùí¶` is an equational class axiomatized by term identities `‚Ñ∞`; that is, `ùë® ‚àà ùí¶` iff `ùë® ‚ä® ‚Ñ∞`. Since the classes `H ùí¶`, `S ùí¶`, `P ùí¶` and `ùí¶` all satisfy the same set of equations, we have `V ùí¶ ‚ä´ p ‚âà q` for all `(p , q) ‚àà ‚Ñ∞`, so `V ùí¶ ‚äÜ ùí¶`.

(‚áê) *Every variety is an equational class*.[^10] Let `ùí¶` be an arbitrary variety.  We will describe a set of equations that axiomatizes `ùí¶`.  A natural choice is to take `Th ùí¶` and try to prove that `ùí¶ = Mod (Th ùí¶)`. Clearly, `ùí¶ ‚äÜ Mod (Th ùí¶)`.  To prove the converse inclusion, let `ùë® ‚àà Mod (Th ùí¶)`. It suffices to find an algebra `ùë≠ ‚àà S (P ùí¶)` such that `ùë®` is a homomorphic image of `ùë≠`, as this will show that `ùë® ‚àà H (S (P ùí¶)) = ùí¶`.

Let `X` be such that there exists a surjective environment `œÅ : X ‚Üí ùïå[ ùë® ]`.[^11]
By the `lift-hom` lemma, there is an epimorphism `h : ùëª X ‚Üí ùïå[ ùë® ]` that extends `œÅ`. Put  `ùîΩ[ X ] := ùëª X / ‚âà` and let `g : ùëª X  ‚Üí ùîΩ[ X ]` be the natural epimorphism with kernel `‚âà`. We claim `ker g ‚äÜ ker h`. 
If the claim is true, then there is a map `f : ùîΩ[ X ] ‚Üí ùë®` such that `f ‚àò g = h`, and since `h`
is surjective so is `f`. Therefore, `ùë® ‚àà ùñß (ùîΩ[ X ]) ‚äÜ Mod (Th ùí¶)` completing the proof.

It remains to prove the claim `ker g ‚äÜ ker h`. Let `u`, `v` be terms and assume `g u = g v`. Since `ùëª X` is generated by `X`, there are terms `p`, `q` such that `u = ‚ü¶ ùëª X ‚üß p` and `v = ‚ü¶ ùëª X ‚üß q`.[^12]
Therefore, `‚ü¶ ùîΩ[ X ] ‚üß p = g (‚ü¶ ùëª X ‚üß p) = g u = g v = g (‚ü¶ ùëª X ‚üß q) = ‚ü¶ ùîΩ[ X ]‚üß q`,
so `ùí¶ ‚ä´ p ‚âà q`; thus, `(p , q) ‚àà Th ùí¶`. Since `ùë® ‚àà Mod (Th ùí¶)`, we obtain `ùë® ‚äß p ‚âà q`, which implies
that `h u = (‚ü¶ ùë® ‚üß p) ‚ü®$‚ü© œÅ = (‚ü¶ ùë® ‚üß q) ‚ü®$‚ü© œÅ = h v`, as desired.

#### <a id="formal-proof">Formal proof</a>
 <!-- {#formal-proof .unnumbered} -->

(‚áí) *Every equational class is a variety*.
We need an arbitrary equational class, which we obtain by starting with an arbitrary collection `‚Ñ∞` of equations and then defining `ùí¶ = Mod ‚Ñ∞`, the class axiomatized by `‚Ñ∞`. We prove that `ùí¶` is a variety by showing that `ùí¶ = V ùí¶`. The inclusion `ùí¶ ‚äÜ V ùí¶`, which holds for all classes `ùí¶`, is called the *expansive* property of `V`.

\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)) where
 V-expa : ùí¶ ‚äÜ V ‚Ñì (ov (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)) ùí¶
 V-expa {x = ùë®}kA = ùë® , (ùë® , (‚ä§ , (Œª _ ‚Üí ùë®), (Œª _ ‚Üí kA), Goal), ‚â§-reflexive), IdHomImage
  where
  open Setoid ùîª[ ùë® ]            using ( refl )
  open Setoid ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ]  using () renaming ( refl to refl‚®Ö )
  to‚®Ö    : ùîª[ ùë® ]            ‚ü∂ ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ]
  to‚®Ö    = record { to = Œª x _ ‚Üí x   ; cong = Œª xy _ ‚Üí xy }
  from‚®Ö  : ùîª[ ‚®Ö (Œª _ ‚Üí ùë®) ]  ‚ü∂ ùîª[ ùë® ]
  from‚®Ö  = record { to = Œª x ‚Üí x tt  ; cong = Œª xy ‚Üí xy tt }
  Goal   : ùë® ‚âÖ ‚®Ö (Œª x ‚Üí ùë®)
  Goal   = mkiso (to‚®Ö , mkhom refl‚®Ö) (from‚®Ö , mkhom refl) (Œª _ _ ‚Üí refl) (Œª _ ‚Üí refl)

\end{code}
Observe how `ùë®` is expressed as (isomorphic to) a product with just one factor (itself), that is, the product
`‚®Ö (Œª x ‚Üí ùë®)` indexed over the one-element type `‚ä§`.

For the inclusion `V ùí¶ ‚äÜ ùí¶`, recall lemma `V-id1` which asserts that `ùí¶ ‚ä´ p ‚âà q` implies
`V ‚Ñì Œπ ùí¶ ‚ä´ p ‚âà q`; whence, if `ùí¶` is an equational class, then `V ùí¶ ‚äÜ ùí¶`, as we now confirm.

\begin{code}

module _ {‚Ñì : Level}{X : Type ‚Ñì}{‚Ñ∞ : {Y : Type ‚Ñì} ‚Üí Pred (Term Y √ó Term Y) (ov ‚Ñì)} where
 private ùí¶ = Mod{Œ± = ‚Ñì}{‚Ñì}{X} ‚Ñ∞     -- an arbitrary equational class

 EqCl‚áíVar : V ‚Ñì (ov ‚Ñì) ùí¶ ‚äÜ ùí¶
 EqCl‚áíVar {ùë®} vA {p} {q} p‚Ñ∞q œÅ = V-id1 ‚Ñì {ùí¶} {p} {q} (Œª _ x œÑ ‚Üí x p‚Ñ∞q œÑ) ùë® vA œÅ

\end{code}
By `V-expa` and `Eqcl‚áíVar`, every equational class is a variety.

(‚áê) *Every variety is an equational class*.
To fix an arbitrary variety, start with an arbitrary class `ùí¶` of `ùëÜ`-algebras and take the *varietal closure*, `V ùí¶`. We prove that `V ùí¶` is precisely the collection of algebras that model `Th (V ùí¶)`; that is, `V ùí¶ = Mod (Th (V ùí¶))`.  The inclusion `V ùí¶ ‚äÜ Mod (Th (V ùí¶))` is a consequence of the fact that `Mod Th` is a closure operator.

\begin{code}

module _ (ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)){X : Type (Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c

 ModTh-closure : V{Œ≤ = Œ≤}{œÅ·µá}{Œ≥}{œÅ·∂ú}{Œ¥}{œÅ·µà} ‚Ñì Œπ ùí¶ ‚äÜ Mod{X = X} (Th (V ‚Ñì Œπ ùí¶))
 ModTh-closure {x = ùë®} vA {p} {q} x œÅ = x ùë® vA œÅ

\end{code}

Our proof of the inclusion `Mod( Th( V ùí¶)) ‚äÜ V ùí¶` is carried out in two steps.

* Prove  `ùîΩ[ X ] ‚â§ ùë™ X`.
* Prove that every algebra in `Mod (Th (V ùí¶))` is a homomorphic image of `ùîΩ[ X ]`.

From the first item we have `ùîΩ[ X ] ‚àà S( P ùí¶))`, since `ùë™ X` is a product of algebras in `ùí¶`. From this and the second item will follow `Mod (Th (V ùí¶)) ‚äÜ H (S (P ùí¶))` (= `V ùí¶`), as desired.

To prove `ùîΩ[ X ] ‚â§ ùë™ X`, we construct a homomorphism from `ùîΩ[ X ]` to `ùë™ X` and then show it is injective,
so `ùîΩ[ X ]` is (isomorphic to) a subalgebra of `ùë™ X`.

\begin{code}

 open FreeHom {‚Ñì = ‚Ñì}{ùí¶}
 open FreeAlgebra ùí¶ using (homC ;  ùîΩ[_] ; ùë™ )
 homFC : hom ùîΩ[ X ] (ùë™ X)
 homFC = fromHomIm (homC X)

 monFC : mon ùîΩ[ X ] (ùë™ X)
 monFC = ‚à£ homFC ‚à£ , record { isHom = ‚à• homFC ‚à•
                            ; isInjective =  Œª {x}{y}‚Üí fromIm-inj ‚à£ homC X ‚à£ {x}{y}   }
 F‚â§C : ùîΩ[ X ] ‚â§ ùë™ X
 F‚â§C = mon‚Üí‚â§ monFC

 open FreeAlgebra ùí¶ using ( ‚Ñë )

 SPF : ùîΩ[ X ] ‚àà S Œπ (P ‚Ñì Œπ ùí¶)
 SPF = ùë™ X , ((‚Ñë X) , (‚à£_‚à£ , ((Œª i ‚Üí fst ‚à• i ‚à•) , ‚âÖ-refl))) ,  F‚â§C
\end{code}

Next we prove that every algebra in `Mod (Th (V ùí¶))` is a homomorphic image of `ùîΩ[ X ]`. Indeed,

\begin{code}

module _ {ùí¶ : Pred(Algebra Œ± œÅ·µÉ) (Œ± ‚äî œÅ·µÉ ‚äî ov ‚Ñì)} where
 private c = Œ± ‚äî œÅ·µÉ ‚äî ‚Ñì ; Œπ = ov c

 Var‚áíEqCl : ‚àÄ ùë® ‚Üí ùë® ‚àà Mod (Th (V ‚Ñì Œπ ùí¶)) ‚Üí ùë® ‚àà V ‚Ñì Œπ ùí¶
 Var‚áíEqCl ùë® ModThA = ùîΩ[ ùïå[ ùë® ] ] , (SPF{‚Ñì = ‚Ñì} ùí¶ , Aim)
  where
  open FreeAlgebra ùí¶ using ( ùîΩ[_] )
  epiFlA : epi ùîΩ[ ùïå[ ùë® ] ] (Lift-Alg ùë® Œπ Œπ)
  epiFlA = F-ModTh-epi-lift{‚Ñì = ‚Ñì} Œª {p q} ‚Üí ModThA{p = p}{q}

  œÜ : Lift-Alg ùë® Œπ Œπ IsHomImageOf ùîΩ[ ùïå[ ùë® ] ]
  œÜ = epi‚Üíontohom ùîΩ[ ùïå[ ùë® ] ] (Lift-Alg ùë® Œπ Œπ) epiFlA

  Aim : ùë® IsHomImageOf ùîΩ[ ùïå[ ùë® ] ]
  Aim = ‚àò-hom ‚à£ œÜ ‚à£(from Lift-‚âÖ), ‚àò-IsSurjective _ _ ‚à• œÜ ‚à•(fromIsSurjective(Lift-‚âÖ{ùë® = ùë®}))

\end{code}
By `ModTh-closure` and `Var‚áíEqCl`, we have `V ùí¶ = Mod (Th (V ùí¶))` for every class `ùí¶` of `ùëÜ`-algebras.
Thus, every variety is an equational class.

This completes the formal proof of Birkhoff's variety theorem. ‚àé

### <a id="discussion">Discussion</a>
 <!-- {#sec:discussion} -->


How do we differ from the classical, set-theoretic approach? Most noticeable is our avoidance of all *size* issues. By using universe levels and level polymorphism, we always make sure we are in a *large enough* universe. So we can easily talk about "all algebras such that..." because these are always taken from a bounded (but arbitrary) universe.

Our use of setoids introduces nothing new: all the equivalence relations we use were already present in the classical proofs. The only "new" material is that we have to prove that functions respect those equivalences.

Our first attempt to formalize Birkhoff's theorem was not sufficiently careful in its handling of variable symbols `X`. Specifically, this type was unconstrained; it is meant to represent the informal notion of a "sufficiently large" collection of variable symbols. Consequently, we postulated surjections from `X` onto the domains of all algebras in the class under consideration. But then, given a signature `ùë∫` and a one-element `ùëÜ`-algebra `ùë®`, by choosing `X` to be the empty type `‚ä•`, our surjectivity postulate gives a map from `‚ä•` onto the singleton domain of `ùë®`. (For details, see the [Demos.ContraX](https://github.com/ualib/agda-algebras/blob/master/src/Demos/ContraX.lagda) module which constructs the counterexample in [Agda][].)

### <a id="related-work">Related work</a>

There have been a number of efforts to formalize parts of universal algebra in type theory besides ours. The Coq proof assistant, based on the Calculus of Inductive Constructions, was used by Capretta, in¬†[@Capretta:1999], and Spitters and Van der Weegen, in¬†[@Spitters:2011], to formalized the basics of universal algebra and some classical algebraic structures. In¬†[@Gunther:2018] Gunther et al developed what seemed (prior to the library) the most extensive libraryof formalized universal algebra to date. Like ,¬†[@Gunther:2018] is based on dependent type theory, is programmed in , and goes beyond the basic isomorphism theorems to include some equational logic. Although their coverage is less extensive than that of , Gunther et al do treat *multi-sorted* algebras, whereas is currently limited to single-sorted structures.

As noted by Abel¬†[@Abel:2021], Amato et al, in [@Amato:2021], have formalized multi-sorted algebras with finitary operators in UniMath. The restriction to finitary operations was due to limitations of the UniMath type theory, which does not have W-types nor user-defined inductive types. Abel also notes that Lynge and Spitters, in¬†[@Lynge:2019], formalize multi-sorted algebras with finitary operators in *Homotopy type theory* ([@HoTT]) using Coq. HoTT's higher inductive types enable them to define quotients as types, without the need for setoids. Lynge and Spitters prove three isomorphism theorems concerning subalgebras and quotient algebras, but do not formalize universal algebras nor varieties. Finally, in¬†[@Abel:2021], Abel gives a new formal proof of the soundness and completeness theorem for multi-sorted algebraic structures.

-----------------------------------

### <a id="footnotes">Footnotes</a>

[^1]: An alternative formalization based on classical set-theory was achieved in¬†[@birkhoff-in-mizar:1999].

[^2]: See the [[Birkhoff.lagda]{.sans-serif}](https://github.com/ualib/ualib.github.io/blob/71f173858701398d56224dd79d152c380c0c2b5e/src/lagda/UALib/Birkhoff.lagda) file in the [[ualib/ualib.gitlab.io]{.sans-serif}](https://github.com/ualib/ualib.github.io) repository ([15 Jan 2021 commit 71f1738](https://github.com/ualib/ualib.github.io/commit/71f173858701398d56224dd79d152c380c0c2b5e))¬†[@ualib_v1.0.0].

[^3]: [[src/Demos/HSP.lagda]{.sans-serif}](https://github.com/ualib/agda-algebras/blob/master/src/Demos/HSP.lagda) in the [agda-algebras][] repository: [[github.com/ualib/agda-algebras]{.sans-serif}](https://github.com/ualib/agda-algebras).

[^4]: the axiom asserting that two point-wise equal functions are equal

[^5]: All submodules of the module in the library are also fully constructive in this sense.

[^6]: The code in this paragraph was suggested by an anonymous referee.

[^7]: `suc ‚Ñì` denotes the successor of `‚Ñì` in the universe hierarchy.

[^8]: The definition of was provided by an anonymous referee; it is indeed simpler than trying to apply the general `HomFactor` theorem found in the [agda-algebras][] library.

[^9]: Some authors reserve the term for a *deductively closed* set of equations, that is, a set of equations that is closed under entailment.

[^10]: The proof we present here is based on¬†[@Bergman:2012 Theorem 4.41].

[^11]: Informally, this is done by assuming `X` has cardinality at least `max(| ùïå[ ùë® ] |, œâ)`. Later we will see how to construct an `X` with the required property in type theory.

[^12]: `‚ü¶ ùë® ‚üß t` denotes the interpretation of the term `t` in the algebra `ùë®`.


{% include UALib.Links.md %}

