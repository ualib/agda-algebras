.. FILE      : closure.lagda.rst
.. AUTHOR    : William DeMeo and Siva Somayyajula
.. DATE      : 2 Jul 2020
.. UPDATE    : 29 Jul 2020
.. COPYRIGHT : (c) 2020 William DeMeo


.. _equational logic in agda:

Equational Logic in Agda
===========================

This chapter describes the `closure module`_ of the `agda-ualib`_.

-------------------------------------------

Preliminaries
---------------

As usual, the development begins by satisfying dependencies, although this time we postpone some imports until the start of the `closure module`_ so that these later imports can share the same signature with the module.

::

  {-# OPTIONS --without-K --exact-split --safe #-}

  open import basic
  open import prelude using (global-dfunext; dfunext; im)

----------------------------------------------------

Closure operators
-----------------

Fix a signature ğ‘†.

Let ğ’¦ be a class of ğ‘†-algebras. Define

  * H(ğ’¦) = homomorphic images of members of ğ’¦;
  * S(ğ’¦) = algebras isomorphic to a subalgebra of a member of ğ’¦;
  * P(ğ’¦) = algebras isomorphic to a direct product of members of ğ’¦.

As a straight-forward verification confirms, H, S, and P are closure operators. A class ğ’¦ of ğ‘†-algebras is said to be *closed under the formation of homomorphic images* if H(ğ’¦) âŠ† ğ’¦. Similarly, ğ’¦ is *closed under the formation of subalgebras* (resp., *products*) provided S(ğ’¦) âŠ† ğ’¦ (resp., P(ğ’¦) âŠ† ğ’¦).

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class H(ğ’¦) (resp., S(ğ’¦); resp., P(ğ’¦)) is closed under isomorphism.

The operators H, S, and P can be composed with one another repeatedly, forming yet more closure operators. If Câ‚ and Câ‚‚ are closure operators on classes of structures, let us say that Câ‚ â‰¤ Câ‚‚ if for every class ğ’¦ we have Câ‚(ğ’¦) âŠ† Câ‚‚(ğ’¦).

.. _lem 3.41:

.. proof:lemma:: Lem. 3.41 of :cite:`Bergman:2012`

   SH â‰¤ HS, PS â‰¤ SP.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let C âˆˆ SH(ğ’¦). Then C â‰¤ B for some B âˆˆ H(A), where A âˆˆ ğ’¦.  Let Î¸ be such that B â‰… A/Î¸.  Then C is isomorphic to a subalgebra, say, T, of A/Î¸.  By the correspondence theorem, there is a subalgebra S â‰¤ A such that S/Î¸ = T.  Thus, C âˆˆ HS(A) âŠ† HS(ğ’¦), as desired.

      Let C âˆˆ PS(ğ’¦). Then C = Î  Báµ¢ for some Báµ¢ â‰¤ Aáµ¢ âˆˆ ğ’¦. Clearly, C = Î  Báµ¢ â‰¤ Î  Aáµ¢, so C âˆˆ SP(ğ’¦), as desired. âˆ

---------------------------------------------

Equational classes
---------------------

A class ğ’¦ of ğ‘†-algebras is called a **variety** if it is closed under each of the closure operators H, S, and P introduced above; the corresponding closure operator is often denoted ğ•. Thus, if ğ’¦ is a class of similar algebras, then the **variety generated by** ğ’¦ is denoted by ğ•(ğ’¦) and defined to be the smallest class that contains ğ’¦ and is closed under H, S, and P.

.. The class of all varieties of ğ‘†-algebras is ordered by inclusion, and closed under arbitrary intersection; thus, the class of varieties is a complete lattice.

We would like to know how to construct ğ•(ğ’¦) directly from ğ’¦, but it's not immediately obvious how many times we would have to apply the operators H, S, P before the result stabilizes to form a variety---the **variety generated by** ğ’¦.  Fortunately, Garrett Birkhoff proved that if we apply the operators in the correct order, then it suffices to apply each one only once.

.. proof:theorem:: Thm 3.43 of :cite:`Bergman:2012`

   ğ• = HSP.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let ğ’¦ be a class of algebras. To see that HSP(ğ’¦) is a variety, we use :numref:`Lemma %s <lem 3.41>` to compute H(HSP) = HSP, S(HSP) â‰¤ HSÂ²P = HSP, P(HSP) â‰¤ HSPÂ² = HSP. Thus HSP â‰¥ ğ•.

      On the other hand, HSP(ğ’¦) âŠ† HSP(ğ•(ğ’¦)) = ğ•(ğ’¦) so HSP â‰¤ ğ•.

-------------------------------

Types for identities
----------------------

In his treatment of Birhoff's HSP theorem, Cliff Bergman (at the start of Section 4.4 of his universal algebra textbook :cite:`Bergman:2012`) proclaims, "Now, finally, we can formalize the idea we have been using since the first page of this text."  He then proceeds to define **identities of terms** as follows (paraphrasing for notational consistency):

Let ğ‘† be a signature.  An **identity** or **equation** in ğ‘† is an ordered pair of terms, written ğ‘ â‰ˆ ğ‘, from the term algebra ğ‘»(X). If A is an ğ‘†-algebra we say that A **satisfies** ğ‘ â‰ˆ ğ‘ if ğ‘ Ì‡ A â‰¡ ğ‘ Ì‡ A.  In this  situation,  we  write A âŠ§ ğ‘ â‰ˆ ğ‘.

If ğ’¦ is a class of ğ‘†-algebras, we write ğ’¦ âŠ§ ğ‘ â‰‹ ğ‘ if, for every A âˆˆ ğ’¦, A âŠ§ ğ‘ â‰ˆ ğ‘. Finally, if ğ“” is a set of equations, we write ğ’¦ âŠ§ ğ“” if every member of ğ’¦ satisfies every member of ğ“”.

We formalize these notions in Agda in the `closure module`_, which begins as follows. (Note the imports that were postponed until after the start of the closure module so that the imports share the same signature ğ‘† with the `closure module`_.

::

  module closure
   {ğ‘† : Signature ğ“ ğ“¥}
   {X : ğ“¤ Ì‡ }
   {gfe : global-dfunext}
   {dfe : dfunext ğ“¤ ğ“¤}
   {ğ• : (ğ‘¨ : Algebra ğ“¤ ğ‘†) â†’ X â†  ğ‘¨} where

  open import homomorphisms {ğ‘† = ğ‘†} public
  open import terms {ğ‘† = ğ‘†} renaming (generator to â„Š) public
  open import subuniverses {ğ‘† = ğ‘†} public
  open import congruences public

::

Our first definition in the `closure module`_ is notation that represents the satisfaction of equations.

The standard notation is ``ğ‘¨ âŠ§ p â‰ˆ q``, which means that the identity ``p â‰ˆ q`` is satisfied in ğ‘¨. In otherwords, for all assignments ``a : X â†’ âˆ£ ğ‘¨ âˆ£`` of values to variables, we have ``(p Ì‡ ğ‘¨) a â‰¡ (q Ì‡ ğ‘¨) a``.

If ğ’¦ is a class of structures, it is standard to write ``ğ’¦ âŠ§ p â‰ˆ q`` just in case all structures in the class ğ’¦ model the identity p â‰ˆ q.  However, because a class of structures has a different type than a single structure, we will need different notation, so we have settled on writing ``ğ’¦ âŠ§ p â‰‹ q`` to denote this concept.

::

  _âŠ§_â‰ˆ_ : Algebra ğ“¤ ğ‘†
   â†’      Term{X = X} â†’ Term â†’ ğ“¤ Ì‡

  ğ‘¨ âŠ§ p â‰ˆ q = (p Ì‡ ğ‘¨) â‰¡ (q Ì‡ ğ‘¨)

  _âŠ§_â‰‹_ : Pred (Algebra ğ“¤ ğ‘†) ğ“¦
   â†’      Term{X = X} â†’ Term â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤ âº Ì‡

  _âŠ§_â‰‹_ ğ’¦ p q = {ğ‘¨ : Algebra _ ğ‘†} â†’ ğ’¦ ğ‘¨ â†’ ğ‘¨ âŠ§ p â‰ˆ q

---------------------------------------------

Compatibility of identities
------------------------------

Identities are compatible with the formation of subalgebras, homomorphic images and products. More precisely, for every class ğ’¦ of structures, each of the classes S(ğ’¦), H(ğ’¦), P(ğ’¦), ğ•(ğ’¦) satisfies the same set of identities as does ğ’¦.

Here we formalize the notion of closure under the taking of products, subalgebras, and homomorphic images, and we prove that each of these closures preserves identities.

.. _obs 13 in agda:

Closure under Products
~~~~~~~~~~~~~~~~~~~~~~~

First a data type that represents a class of algebraic structures that is closed under the taking of products of algebras in the class can be defined in Agda_ as follows.

::

  data PClo (ğ’¦ : Pred (Algebra ğ“¤ ğ‘†)(ğ“¤ âº)) : Pred (Algebra ğ“¤ ğ‘†) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº ) where
   pbase : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ ğ’¦ â†’ ğ‘¨ âˆˆ PClo ğ’¦
   prod : {I : ğ“¤ Ì‡ }{ğ’œ : I â†’ Algebra _ ğ‘†}
    â†’     (âˆ€ i â†’ ğ’œ i âˆˆ PClo ğ’¦)
    â†’     â¨… ğ’œ âˆˆ PClo ğ’¦

We prove that identities satisfied by all factors of a product are also satisfied by the product.

::

  products-preserve-identities :
        (p q : Term{X = X})
        (I : ğ“¤ Ì‡ ) (ğ’œ : I â†’ Algebra ğ“¤ ğ‘†)
   â†’    ((i : I) â†’ (ğ’œ i) âŠ§ p â‰ˆ q)
       -----------------------------------
   â†’     â¨… ğ’œ âŠ§ p â‰ˆ q

  products-preserve-identities p q I ğ’œ ğ’œâŠ§pâ‰ˆq = Î³
   where
     Î³ : (p Ì‡ â¨… ğ’œ) â‰¡ (q Ì‡ â¨… ğ’œ)
     Î³ = gfe Î» a â†’
      (p Ì‡ â¨… ğ’œ) a
        â‰¡âŸ¨ interp-prod gfe p ğ’œ a âŸ©
      (Î» i â†’ ((p Ì‡ (ğ’œ i)) (Î» x â†’ (a x) i)))
        â‰¡âŸ¨ gfe (Î» i â†’ cong-app (ğ’œâŠ§pâ‰ˆq i) (Î» x â†’ (a x) i)) âŸ©
      (Î» i â†’ ((q Ì‡ (ğ’œ i)) (Î» x â†’ (a x) i)))
        â‰¡âŸ¨ (interp-prod gfe q ğ’œ a)â»Â¹ âŸ©
      (q Ì‡ â¨… ğ’œ) a
        âˆ

  products-in-class-preserve-identities :
       (ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) ( ğ“¤ âº ))
       (p q : Term{X = X})
       (I : ğ“¤ Ì‡ ) (ğ’œ : I â†’ Algebra ğ“¤ ğ‘†)
   â†’   ğ’¦ âŠ§ p â‰‹ q  â†’  ((i : I) â†’ ğ’œ i âˆˆ ğ’¦)
       ------------------------------------
   â†’    â¨… ğ’œ âŠ§ p â‰ˆ q

  products-in-class-preserve-identities ğ’¦ p q I ğ’œ ğ’¦âŠ§pâ‰‹q allğ’œiâˆˆğ’¦ = Î³
   where
     ğ’œâŠ§pâ‰ˆq : âˆ€ i â†’ (ğ’œ i) âŠ§ p â‰ˆ q
     ğ’œâŠ§pâ‰ˆq i = ğ’¦âŠ§pâ‰‹q (allğ’œiâˆˆğ’¦ i)

     Î³ : (p Ì‡ â¨… ğ’œ) â‰¡ (q Ì‡ â¨… ğ’œ)
     Î³ = products-preserve-identities p q I ğ’œ ğ’œâŠ§pâ‰ˆq

Closure under subalgebras
~~~~~~~~~~~~~~~~~~~~~~~~~~

Next, we define a datatype that represents a class of algebraic structures that is closed under the taking of subalgebras.

Let S(ğ’¦) denote the class of algebras isomorphic to a subalgebra of a member of ğ’¦.  With our new formal definition of Subalgebra, we will show that every term equation, ``p â‰ˆ q``, that is satisfied by all ``ğ‘¨ âˆˆ ğ’¦`` is also satisfied by all ``B âˆˆ S(ğ’¦)``. In other words, the collection of identities modeled by a given class of algebras is also modeled by all of the subalgebras of that class.


::

  -- Subalgebra Closure
  data SClo (ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) (ğ“¤ âº)) : Pred (Algebra ğ“¤ ğ‘†) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº ) where
   sbase : {ğ‘¨ :  Algebra _ ğ‘†} â†’ ğ‘¨ âˆˆ ğ’¦ â†’ ğ‘¨ âˆˆ SClo ğ’¦
   sub : {ğ‘¨ : Algebra _ ğ‘†} â†’ ğ‘¨ âˆˆ SClo ğ’¦ â†’ (sa : SubalgebrasOf ğ‘¨) â†’ âˆ£ sa âˆ£ âˆˆ SClo ğ’¦

  subalgebras-preserve-identities : (ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) ( ğ“¤ âº ))(p q : Term{X = X})
   â†’  (ğ’¦ âŠ§ p â‰‹ q) â†’ (SAK : SubalgebrasOfClass ğ’¦)
   â†’  (prâ‚ âˆ¥ (prâ‚‚ SAK) âˆ¥) âŠ§ p â‰ˆ q
  subalgebras-preserve-identities ğ’¦ p q ğ’¦âŠ§pâ‰‹q SAK = Î³
   where

    ğ‘¨ : Algebra ğ“¤ ğ‘†
    ğ‘¨ = âˆ£ SAK âˆ£

    Aâˆˆğ’¦ : ğ‘¨ âˆˆ ğ’¦
    Aâˆˆğ’¦ = âˆ£ prâ‚‚ SAK âˆ£

    AâŠ§pâ‰ˆq : ğ‘¨ âŠ§ p â‰ˆ q
    AâŠ§pâ‰ˆq = ğ’¦âŠ§pâ‰‹q Aâˆˆğ’¦

    subalg : SubalgebrasOf ğ‘¨
    subalg = âˆ¥ prâ‚‚ SAK âˆ¥

    ğ‘© : Algebra ğ“¤ ğ‘†
    ğ‘© = prâ‚ subalg

    h : âˆ£ ğ‘© âˆ£ â†’ âˆ£ ğ‘¨ âˆ£
    h = âˆ£ prâ‚‚ subalg âˆ£

    hem : is-embedding h
    hem = prâ‚ âˆ¥ prâ‚‚ subalg âˆ¥

    hhm : is-homomorphism ğ‘© ğ‘¨ h
    hhm = prâ‚‚ âˆ¥ prâ‚‚ subalg âˆ¥

    Î¾ : (b : X â†’ âˆ£ ğ‘© âˆ£ ) â†’ h ((p Ì‡ ğ‘©) b) â‰¡ h ((q Ì‡ ğ‘©) b)
    Î¾ b =
     h ((p Ì‡ ğ‘©) b)  â‰¡âŸ¨ comm-hom-term gfe ğ‘© ğ‘¨ (h , hhm) p b âŸ©
     (p Ì‡ ğ‘¨)(h âˆ˜ b) â‰¡âŸ¨ intensionality AâŠ§pâ‰ˆq (h âˆ˜ b) âŸ©
     (q Ì‡ ğ‘¨)(h âˆ˜ b) â‰¡âŸ¨ (comm-hom-term gfe ğ‘© ğ‘¨ (h , hhm) q b)â»Â¹ âŸ©
     h ((q Ì‡ ğ‘©) b)  âˆ

    hlc : {b b' : domain h} â†’ h b â‰¡ h b' â†’ b â‰¡ b'
    hlc hbâ‰¡hb' = (embeddings-are-lc h hem) hbâ‰¡hb'

    Î³ : ğ‘© âŠ§ p â‰ˆ q
    Î³ = gfe Î» b â†’ hlc (Î¾ b)


.. _obs 14 in agda:

Closure under hom images
~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall (:numref:`Obs %s <obs 14>`) that an identity is satisfied by all algebras in a class if and only if that identity is compatible with all homomorphisms from the term algebra ğ‘»(X) into algebras of the class.  More precisely, ifğ“š is a class of ğ‘†-algebras and ğ‘, ğ‘ terms in the language of ğ‘†, then,

.. math:: ğ’¦ âŠ§ p â‰ˆ q \; â‡” \; âˆ€ ğ‘¨ âˆˆ ğ’¦, âˆ€ h âˆˆ \mathrm{Hom}(ğ‘»(X), ğ‘¨), h âˆ˜ p^{ğ‘»(X)} = h âˆ˜ q^{ğ‘»(X)}.

We now formalize this result in Agda. Similarly, we define a datatype that represents classes of algebras that include all homomorphic images of algebras in the class, and we prove that identities satisfied by all algberas in a class are also satsified by all homomorphic images of algebras in the class.

::

  --Closure under hom images
  data HClo (ğ’¦ : Pred (Algebra ğ“¤ ğ‘†)(ğ“¤ âº)) : Pred (Algebra ğ“¤ ğ‘†) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº ) where
   hbase : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ ğ’¦ â†’ ğ‘¨ âˆˆ HClo ğ’¦
   hhom : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ HClo ğ’¦ â†’ ((ğ‘© , _ ) : HomImagesOf ğ‘¨) â†’ ğ‘© âˆˆ HClo ğ’¦

  module _ {ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) (ğ“¤ âº)} where

   -- â‡’ (the "only if" direction)
   identities-compatible-with-homs : (p q : Term{X = X})
    â†’                ğ’¦ âŠ§ p â‰‹ q
         ----------------------------------------------------
    â†’     âˆ€ ğ‘¨ KA h â†’ âˆ£ h âˆ£ âˆ˜ (p Ì‡ (ğ‘»(X))) â‰¡ âˆ£ h âˆ£ âˆ˜ (q Ì‡ (ğ‘»(X)))
   -- Here, the inferred types are
   -- ğ‘¨ : Algebra ğ“¤ ğ‘†, KA : ğ’¦ ğ‘¨, h : hom ((ğ‘»(X))) ğ‘¨

   identities-compatible-with-homs p q ğ’¦âŠ§pâ‰‹q ğ‘¨ KA h = Î³
    where
     pAâ‰¡qA : p Ì‡ ğ‘¨ â‰¡ q Ì‡ ğ‘¨
     pAâ‰¡qA = ğ’¦âŠ§pâ‰‹q KA

     pAhâ‰¡qAh : âˆ€(ğ’‚ : X â†’ âˆ£ ğ‘»(X) âˆ£ )
      â†’        (p Ì‡ ğ‘¨)(âˆ£ h âˆ£ âˆ˜ ğ’‚) â‰¡ (q Ì‡ ğ‘¨)(âˆ£ h âˆ£ âˆ˜ ğ’‚)
     pAhâ‰¡qAh ğ’‚ = intensionality pAâ‰¡qA (âˆ£ h âˆ£ âˆ˜ ğ’‚)

     hpaâ‰¡hqa : âˆ€(ğ’‚ : X â†’ âˆ£ ğ‘»(X) âˆ£ )
      â†’        âˆ£ h âˆ£ ((p Ì‡ ğ‘»(X)) ğ’‚) â‰¡ âˆ£ h âˆ£ ((q Ì‡ ğ‘»(X)) ğ’‚)
     hpaâ‰¡hqa ğ’‚ =
      âˆ£ h âˆ£ ((p Ì‡ ğ‘»(X)) ğ’‚)  â‰¡âŸ¨ comm-hom-term gfe (ğ‘» X) ğ‘¨ h p ğ’‚ âŸ©
      (p Ì‡ ğ‘¨)(âˆ£ h âˆ£ âˆ˜ ğ’‚) â‰¡âŸ¨ pAhâ‰¡qAh ğ’‚ âŸ©
      (q Ì‡ ğ‘¨)(âˆ£ h âˆ£ âˆ˜ ğ’‚) â‰¡âŸ¨ (comm-hom-term gfe (ğ‘» X) ğ‘¨ h q ğ’‚)â»Â¹ âŸ©
      âˆ£ h âˆ£ ((q Ì‡ ğ‘»(X)) ğ’‚)  âˆ

     Î³ : âˆ£ h âˆ£ âˆ˜ (p Ì‡ ğ‘»(X)) â‰¡ âˆ£ h âˆ£ âˆ˜ (q Ì‡ ğ‘»(X))
     Î³ = gfe hpaâ‰¡hqa

   -- â‡ (the "if" direction)
   homs-compatible-with-identities : (p q : Term)
    â†’    (âˆ€ ğ‘¨ KA h  â†’  âˆ£ h âˆ£ âˆ˜ (p Ì‡ ğ‘»(X)) â‰¡ âˆ£ h âˆ£ âˆ˜ (q Ì‡ ğ‘»(X)))
         --------------------------------------------------
    â†’                ğ’¦ âŠ§ p â‰‹ q
   --inferred types: ğ‘¨ : Algebra ğ“¤ ğ‘†, KA : ğ‘¨ âˆˆ ğ’¦, h : hom (ğ‘»(X)) ğ‘¨

   homs-compatible-with-identities p q all-hpâ‰¡hq {ğ‘¨} KA = Î³
    where
     h : (ğ’‚ : X â†’ âˆ£ ğ‘¨ âˆ£) â†’ hom (ğ‘» X) ğ‘¨
     h ğ’‚ = lift-hom{ğ‘¨ = ğ‘¨} ğ’‚

     Î³ : ğ‘¨ âŠ§ p â‰ˆ q
     Î³ = gfe Î» ğ’‚ â†’
      (p Ì‡ ğ‘¨) ğ’‚
        â‰¡âŸ¨ ğ“‡â„¯ğ’»ğ“ âŸ©
      (p Ì‡ ğ‘¨)(âˆ£ h ğ’‚ âˆ£ âˆ˜ â„Š)
        â‰¡âŸ¨(comm-hom-term gfe (ğ‘» X) ğ‘¨ (h ğ’‚) p â„Š)â»Â¹ âŸ©
      (âˆ£ h ğ’‚ âˆ£ âˆ˜ (p Ì‡ ğ‘»(X))) â„Š
        â‰¡âŸ¨ ap (Î» - â†’ - â„Š) (all-hpâ‰¡hq ğ‘¨ KA (h ğ’‚)) âŸ©
      (âˆ£ h ğ’‚ âˆ£ âˆ˜ (q Ì‡ ğ‘»(X))) â„Š
        â‰¡âŸ¨ (comm-hom-term gfe (ğ‘» X) ğ‘¨ (h ğ’‚) q â„Š) âŸ©
      (q Ì‡ ğ‘¨)(âˆ£ h ğ’‚ âˆ£ âˆ˜ â„Š)
        â‰¡âŸ¨ ğ“‡â„¯ğ’»ğ“ âŸ©
      (q Ì‡ ğ‘¨) ğ’‚
        âˆ

   compatibility-of-identities-and-homs : (p q : Term)
    â†’  (ğ’¦ âŠ§ p â‰‹ q)
        â‡” (âˆ€ ğ‘¨ ka hh â†’ âˆ£ hh âˆ£ âˆ˜ (p Ì‡ ğ‘»(X)) â‰¡ âˆ£ hh âˆ£ âˆ˜ (q Ì‡ ğ‘»(X)))
   --inferred types: ğ‘¨ : algebra ğ“¤ s, ka : ğ‘¨ âˆˆ ğ’¦, hh : hom (ğ‘»(X)) ğ‘¨.

   compatibility-of-identities-and-homs p q =
     identities-compatible-with-homs p q ,
     homs-compatible-with-identities p q

   ---------------------------------------------------------------

   --Compatibility of identities with interpretation of terms
   hom-id-compatibility : (p q : âˆ£ ğ‘»(X) âˆ£ )
                          (ğ‘¨ : Algebra _ ğ‘†)
                          (Ï• : hom (ğ‘» X) ğ‘¨)
    â†’                     (ğ‘¨ âŠ§ p â‰ˆ q)
                         -------------------
    â†’                     âˆ£ Ï• âˆ£ p â‰¡ âˆ£ Ï• âˆ£ q

   hom-id-compatibility p q ğ‘¨ Ï• pAâ‰¡qA =
      âˆ£ Ï• âˆ£ p              â‰¡âŸ¨ ap âˆ£ Ï• âˆ£ (term-agreement{gfe = gfe} p) âŸ©
      âˆ£ Ï• âˆ£ ((p Ì‡ ğ‘» X) â„Š)  â‰¡âŸ¨ (comm-hom-term gfe (ğ‘» X) ğ‘¨ Ï• p â„Š) âŸ©
      (p Ì‡ ğ‘¨) (âˆ£ Ï• âˆ£ âˆ˜ â„Š)  â‰¡âŸ¨ intensionality pAâ‰¡qA (âˆ£ Ï• âˆ£ âˆ˜ â„Š)  âŸ©
      (q Ì‡ ğ‘¨) (âˆ£ Ï• âˆ£ âˆ˜ â„Š)  â‰¡âŸ¨ (comm-hom-term gfe (ğ‘» X) ğ‘¨ Ï• q â„Š)â»Â¹ âŸ©
      âˆ£ Ï• âˆ£ ((q Ì‡ ğ‘» X) â„Š)  â‰¡âŸ¨ (ap âˆ£ Ï• âˆ£ (term-agreement{gfe = gfe} q))â»Â¹ âŸ©
      âˆ£ Ï• âˆ£ q  âˆ


Equational theories and classes
---------------------------------

Here we define the notation ``Th`` for the identities satisfied by all structures in a given class, and ``Mod`` for all structures that satisfy a given collection of identities.

::

  Th : Pred (Algebra ğ“¤ ğ‘†)(ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº ) â†’ Pred (Term{X = X} Ã— Term) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº)
  Th ğ’¦ = Î» (p , q) â†’ ğ’¦ âŠ§ p â‰‹ q

  Mod : Pred (Term{X = X} Ã— Term) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº) â†’ Pred (Algebra ğ“¤ ğ‘†)(ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº )
  Mod â„° = Î» A â†’ âˆ€ p q â†’ (p , q) âˆˆ â„° â†’ A âŠ§ p â‰ˆ q

------------------------------------------

.. _the free algebra in agda:

The free algebra in Agda
---------------------------

Recall, we proved above that term algebra ğ‘»(ğ‘‹) is the absolutely free algebra in the class ğ“š(ğ‘†) of all ğ‘†-structures. In this section, we formalize, for a given class ğ’¦ of ğ‘†-algebras, the (relatively) free algebra in SP(ğ’¦) over ğ‘‹.  Recall, this was defined above in :numref:`free algebras` as follows:

  ğ”½(ğ’¦, ğ‘‹) := ğ‘»(ğ‘‹)/Î¨(ğ’¦, ğ‘»(ğ‘‹)).

Thus, we must first formalize the congruence Ïˆ(ğ’¦, ğ‘»(ğ‘‹)) which is defined by

  Î¨(ğ’¦, ğ‘»(ğ‘‹)) := â‹€ Ïˆ(ğ’¦, ğ‘»(ğ‘‹)),

where Ïˆ(ğ’¦, ğ‘»(ğ‘‹)) := \{Î¸ âˆˆ Con ğ‘»(ğ‘‹) : ğ‘¨/Î¸ âˆˆ S(ğ’¦)\}.

Strictly speaking, ğ‘‹ is not a subset of ğ”½(ğ’¦, ğ‘‹) so it doesn't make sense to say that "ğ‘‹ generates ğ”½(ğ’¦, ğ‘‹)."  But as long as ğ’¦ contains a nontrivial algebra, we will have Î¨(ğ’¦, ğ‘»(ğ‘‹)) âˆ© ğ‘‹Â² â‰  âˆ…, and we can identify ğ‘‹ with ğ‘‹/Î¨(ğ’¦, ğ‘»(ğ‘‹)) in ğ”½(ğ’¦, ğ‘‹). (See :numref:`Obs %s <obs 9.6>`.)

::

  module _ {ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) (ğ“¤ âº)} where

   ğ‘»HI = HomImagesOf (ğ‘» X)

   ğ‘»img : ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº Ì‡
   ğ‘»img  =  Î£ ğ‘¨ ê‰ (Algebra ğ“¤ ğ‘†) ,
              Î£ Ï• ê‰ hom (ğ‘» X) ğ‘¨ , (ğ‘¨ âˆˆ SClo ğ’¦) Ã— Epic âˆ£ Ï• âˆ£

   ğ‘»ğ‘¨ : (ti : ğ‘»img) â†’ Algebra ğ“¤ ğ‘†
   ğ‘»ğ‘¨ ti = âˆ£ ti âˆ£

   ğ‘»ğ‘¨âˆˆSCloğ’¦ : (ti : ğ‘»img) â†’ (ğ‘»ğ‘¨ ti) âˆˆ SClo ğ’¦
   ğ‘»ğ‘¨âˆˆSCloğ’¦ ti = âˆ£ prâ‚‚ âˆ¥ ti âˆ¥ âˆ£

   ğ‘»Ï• : (ti : ğ‘»img) â†’ hom (ğ‘» X) (ğ‘»ğ‘¨ ti)
   ğ‘»Ï• ti = prâ‚ âˆ¥ ti âˆ¥

   ğ‘»Ï•E : (ti : ğ‘»img) â†’ Epic âˆ£ (ğ‘»Ï• ti) âˆ£
   ğ‘»Ï•E ti = âˆ¥ prâ‚‚ âˆ¥ ti âˆ¥ âˆ¥

   ğ‘»KER : ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº Ì‡
   ğ‘»KER = Î£ (p , q) ê‰ (âˆ£ (ğ‘» X) âˆ£ Ã— âˆ£ (ğ‘» X) âˆ£) ,
      âˆ€ ti â†’ (p , q) âˆˆ KER-pred{B = âˆ£ (ğ‘»ğ‘¨ ti) âˆ£} âˆ£ ğ‘»Ï• ti âˆ£

   Î¨ : Pred (âˆ£ (ğ‘» X) âˆ£ Ã— âˆ£ (ğ‘» X) âˆ£) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº)
   Î¨ (p , q) =
    âˆ€ ti â†’ âˆ£ (ğ‘»Ï• ti) âˆ£ âˆ˜ (p Ì‡ ğ‘»(X)) â‰¡ âˆ£ (ğ‘»Ï• ti) âˆ£ âˆ˜ (q Ì‡ ğ‘»(X))

   Î¨' : Pred (âˆ£ (ğ‘» X) âˆ£ Ã— âˆ£ (ğ‘» X) âˆ£) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº)
   Î¨' (p , q) = âˆ€ ti â†’ âˆ£ (ğ‘»Ï• ti) âˆ£ p â‰¡ âˆ£ (ğ‘»Ï• ti) âˆ£ q

N.B. Î¨ is the kernel of ğ‘»(X) â†’ ğ”½(ğ’¦, ğ‘»(X)).  Therefore, to prove ğ‘¨ is a homomorphic image of ğ”½(ğ’¦, ğ‘»(X)), it suffices to show that the kernel of the lift h : ğ‘»(X) â†’ ğ‘¨ contains Î¨.

.. code-block::

   ğ‘»---- g --->>ğ”½  (ker g = Î¨)
    \         .
     \       .
      h     âˆƒÏ•     (want: Î¨ âŠ† ker h)
       \   .
        \ .
         V
         ğ‘¨


----------------------------------------------------------

More tools for Birkhoff's theorem
----------------------------------

Here are some of the key facts and identities we need to complete the proof of Birkhoff's HSP theorem.

::

   ğ‘»hom-gen : (ğ‘ª : Algebra ğ“¤ ğ‘†) â†’ Î£ h ê‰ (hom (ğ‘» X) ğ‘ª), Epic âˆ£ h âˆ£
   ğ‘»hom-gen ğ‘ª = h , lift-of-epic-is-epic hâ‚€ hE
    where
      â„‹ : X â†  ğ‘ª
      â„‹ = ğ• ğ‘ª

      hâ‚€ : X â†’ âˆ£ ğ‘ª âˆ£
      hâ‚€ = fst â„‹

      hE : Epic hâ‚€
      hE = snd â„‹

      h : hom (ğ‘» X) ğ‘ª
      h = lift-hom{ğ‘¨ = ğ‘ª}{X = X} hâ‚€

   SCloğ’¦â†’ğ‘»img : (ğ‘ª : Algebra ğ“¤ ğ‘†) â†’ (ğ‘ª âˆˆ SClo ğ’¦) â†’ ğ‘»img
   SCloğ’¦â†’ğ‘»img ğ‘ª ğ‘ªâˆˆSCloğ’¦ =
     ğ‘ª , (fst (ğ‘»hom-gen ğ‘ª)) , (ğ‘ªâˆˆSCloğ’¦ , (snd (ğ‘»hom-gen ğ‘ª)))

   ğ‘»imgâ†’ğ‘»âŠ§ : âˆ€ p q
    â†’        (p , q) âˆˆ Î¨'
    â†’        (ti : ğ‘»img)
         -----------------------------------
    â†’     âˆ£ (ğ‘»Ï• ti) âˆ£ ((p Ì‡ ğ‘»(X)) â„Š)
         â‰¡ âˆ£ (ğ‘»Ï• ti) âˆ£ ((q Ì‡ ğ‘»(X)) â„Š)
   ğ‘»imgâ†’ğ‘»âŠ§ p q pÎ¨q ti = goal1
     where
      ğ‘ª : Algebra ğ“¤ ğ‘†
      ğ‘ª = âˆ£ ti âˆ£

      Ï• : hom (ğ‘» X) ğ‘ª
      Ï• = ğ‘»Ï• ti

      pCq : âˆ£ Ï• âˆ£ p â‰¡ âˆ£ Ï• âˆ£ q
      pCq = pÎ¨q ti

      ğ“… ğ“† : âˆ£ ğ‘» X âˆ£  -- Notation: ğ“… = \Mcp
      ğ“… = âˆ£ tg{X = X}{gfe = gfe} p âˆ£
      ğ“† = âˆ£ tg{X = X}{gfe = gfe} q âˆ£

      pâ‰¡ğ“… : p â‰¡ (ğ“… Ì‡ ğ‘» X) â„Š
      pâ‰¡ğ“… = âˆ¥ tg p âˆ¥

      qâ‰¡ğ“† : q â‰¡ (ğ“† Ì‡ ğ‘» X) â„Š
      qâ‰¡ğ“† = âˆ¥ tg q âˆ¥

      Î¾ : âˆ£ Ï• âˆ£ ((ğ“… Ì‡ ğ‘»(X)) â„Š) â‰¡ âˆ£ Ï• âˆ£ ((ğ“† Ì‡ ğ‘»(X)) â„Š)
      Î¾ = (ap âˆ£ Ï• âˆ£ pâ‰¡ğ“…)â»Â¹ âˆ™ pCq âˆ™ (ap âˆ£ Ï• âˆ£ qâ‰¡ğ“†)

      goal1 : âˆ£ Ï• âˆ£ ((p Ì‡ ğ‘»(X)) â„Š) â‰¡ âˆ£ Ï• âˆ£ ((q Ì‡ ğ‘»(X)) â„Š)
      goal1 = (ap âˆ£ Ï• âˆ£ (term-gen-agreement p))
               âˆ™ Î¾ âˆ™ (ap âˆ£ Ï• âˆ£ (term-gen-agreement q))â»Â¹

   Î¨âŠ†ThSCloğ’¦ : Î¨ âŠ† Th (SClo ğ’¦)
   Î¨âŠ†ThSCloğ’¦ {p , q} pÎ¨q {ğ‘ª} ğ‘ªâˆˆSCloğ’¦ = ğ‘ªâŠ§pâ‰ˆq
     where
      ti : ğ‘»img
      ti = SCloğ’¦â†’ğ‘»img ğ‘ª ğ‘ªâˆˆSCloğ’¦

      Ï• : hom (ğ‘» X) ğ‘ª
      Ï• = ğ‘»Ï• ti

      Ï•E : Epic âˆ£ Ï• âˆ£
      Ï•E = ğ‘»Ï•E ti

      Ï•sur : (ğ’„ : X â†’ âˆ£ ğ‘ª âˆ£ )(x : X) â†’ Image âˆ£ Ï• âˆ£ âˆ‹ (ğ’„ x)
      Ï•sur ğ’„ x = Ï•E (ğ’„ x)

      preim : (ğ’„ : X â†’ âˆ£ ğ‘ª âˆ£)(x : X) â†’ âˆ£ (ğ‘» X) âˆ£
      preim ğ’„ x = (Inv âˆ£ Ï• âˆ£ (ğ’„ x) (Ï•sur ğ’„ x))

      Î¶ : (ğ’„ : X â†’ âˆ£ ğ‘ª âˆ£) â†’ âˆ£ Ï• âˆ£ âˆ˜ (preim ğ’„) â‰¡ ğ’„
      Î¶ ğ’„ = gfe Î» x â†’ InvIsInv âˆ£ Ï• âˆ£ (ğ’„ x) (Ï•sur ğ’„ x)

      Î³ : âˆ£ Ï• âˆ£ âˆ˜ (p Ì‡ ğ‘»(X)) â‰¡ âˆ£ Ï• âˆ£ âˆ˜ (q Ì‡ ğ‘»(X))
      Î³ = pÎ¨q ti

      ğ‘ªâŠ§pâ‰ˆq : (p Ì‡ ğ‘ª) â‰¡ (q Ì‡ ğ‘ª)
      ğ‘ªâŠ§pâ‰ˆq = gfe Î» ğ’„ â†’
       (p Ì‡ ğ‘ª) ğ’„               â‰¡âŸ¨ (ap (p Ì‡ ğ‘ª) (Î¶ ğ’„))â»Â¹ âŸ©
       (p Ì‡ ğ‘ª) (âˆ£ Ï• âˆ£ âˆ˜ (preim ğ’„)) â‰¡âŸ¨ (comm-hom-term gfe (ğ‘» X) ğ‘ª Ï• p (preim ğ’„))â»Â¹ âŸ©
       âˆ£ Ï• âˆ£ ((p Ì‡ ğ‘»(X))(preim ğ’„))     â‰¡âŸ¨ (intensionality Î³ (preim ğ’„)) âŸ©
       âˆ£ Ï• âˆ£ ((q Ì‡ ğ‘»(X))(preim ğ’„))     â‰¡âŸ¨ comm-hom-term gfe (ğ‘» X) ğ‘ª Ï• q (preim ğ’„) âŸ©
       (q Ì‡ ğ‘ª)(âˆ£ Ï• âˆ£ âˆ˜ (preim ğ’„))  â‰¡âŸ¨ ap (q Ì‡ ğ‘ª) (Î¶ ğ’„) âŸ©
       (q Ì‡ ğ‘ª) ğ’„ âˆ


   Î¨âŠ†Thğ’¦ : âˆ€ p q â†’ (p , q) âˆˆ Î¨ â†’ ğ’¦ âŠ§ p â‰‹ q
   Î¨âŠ†Thğ’¦ p q pÎ¨q {ğ‘¨} KA = Î¨âŠ†ThSCloğ’¦{p , q} pÎ¨q (sbase KA)

-------------------------------------------------------

Closure under HSP
--------------------

Finally, we have a datatype that represents classes of algebras that are close under the taking of homomorphic images, subalgebras, and products of algebras in the class.

::

  -- Variety Closure
  data VClo (ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) (ğ“¤ âº)) : Pred (Algebra ğ“¤ ğ‘†)(ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº ) where
   vbase : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ ğ’¦ â†’ ğ‘¨ âˆˆ VClo ğ’¦
   vprod : {I : ğ“¤ Ì‡ }{ğ’œ : I â†’ Algebra _ ğ‘†} â†’ (âˆ€ i â†’ ğ’œ i âˆˆ VClo ğ’¦) â†’ â¨… ğ’œ âˆˆ VClo ğ’¦
   vsub : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ VClo ğ’¦ â†’ (sa : SubalgebrasOf ğ‘¨) â†’ âˆ£ sa âˆ£ âˆˆ VClo ğ’¦
   vhom : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ VClo ğ’¦ â†’ ((ğ‘© , _ , _) : HomImagesOf ğ‘¨) â†’ ğ‘© âˆˆ VClo ğ’¦

-- ThVCloâŠ†ThSClo : Th (VClo ğ’¦) âŠ† Th (SClo ğ’¦)
-- ThVCloâŠ†ThSClo = ?

Identities for product closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

  module _ {ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) ( ğ“¤ âº )} where

   pclo-id1 : âˆ€ {p q} â†’ (ğ’¦ âŠ§ p â‰‹ q) â†’ (PClo ğ’¦ âŠ§ p â‰‹ q)
   pclo-id1 {p} {q} Î± (pbase x) = Î± x
   pclo-id1 {p} {q} Î± (prod{I}{ğ’œ} ğ’œ-Pğ’¦ ) = Î³
    where
     IH : (i : I)  â†’ (p Ì‡ ğ’œ i) â‰¡ (q Ì‡ ğ’œ i)
     IH = Î» i â†’ pclo-id1{p}{q} Î±  ( ğ’œ-Pğ’¦  i )
     Î³ : p Ì‡ (â¨… ğ’œ)  â‰¡ q Ì‡ (â¨… ğ’œ)
     Î³ = products-preserve-identities p q I ğ’œ IH

   pclo-id2 : âˆ€{p q} â†’ ((PClo ğ’¦) âŠ§ p â‰‹ q ) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   pclo-id2 p Aâˆˆğ’¦ = p (pbase Aâˆˆğ’¦)


Identities for subalgebra closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::


   sclo-id1 : âˆ€{p q} â†’ (ğ’¦ âŠ§ p â‰‹ q) â†’ (SClo ğ’¦ âŠ§ p â‰‹ q)
   sclo-id1 {p} {q} ğ’¦âŠ§pâ‰‹q (sbase Aâˆˆğ’¦) = ğ’¦âŠ§pâ‰‹q Aâˆˆğ’¦
   sclo-id1 {p} {q} ğ’¦âŠ§pâ‰‹q (sub {ğ‘¨ = ğ‘¨} AâˆˆSCloğ’¦ sa) = Î³
    where
     AâŠ§pâ‰ˆq : ğ‘¨ âŠ§ p â‰ˆ q
     AâŠ§pâ‰ˆq = sclo-id1{p}{q} ğ’¦âŠ§pâ‰‹q AâˆˆSCloğ’¦

     B : Algebra ğ“¤ ğ‘†
     B = âˆ£ sa âˆ£

     h : âˆ£ B âˆ£ â†’ âˆ£ ğ‘¨ âˆ£
     h = prâ‚ âˆ¥ sa âˆ¥

     hem : is-embedding h
     hem = âˆ£ prâ‚‚ âˆ¥ sa âˆ¥ âˆ£

     hhm : is-homomorphism B ğ‘¨ h
     hhm = âˆ¥ prâ‚‚ âˆ¥ sa âˆ¥ âˆ¥

     Î¾ : (b : X â†’ âˆ£ B âˆ£ ) â†’ h ((p Ì‡ B) b) â‰¡ h ((q Ì‡ B) b)
     Î¾ b =
      h ((p Ì‡ B) b)  â‰¡âŸ¨ comm-hom-term gfe B ğ‘¨ (h , hhm) p b âŸ©
      (p Ì‡ ğ‘¨)(h âˆ˜ b) â‰¡âŸ¨ intensionality AâŠ§pâ‰ˆq (h âˆ˜ b) âŸ©
      (q Ì‡ ğ‘¨)(h âˆ˜ b) â‰¡âŸ¨ (comm-hom-term gfe B ğ‘¨ (h , hhm) q b)â»Â¹ âŸ©
      h ((q Ì‡ B) b)  âˆ

     hlc : {b b' : domain h} â†’ h b â‰¡ h b' â†’ b â‰¡ b'
     hlc hbâ‰¡hb' = (embeddings-are-lc h hem) hbâ‰¡hb'

     Î³ : p Ì‡ B â‰¡ q Ì‡ B
     Î³ = gfe Î» b â†’ hlc (Î¾ b)

   sclo-id2 : âˆ€ {p q} â†’ (SClo ğ’¦ âŠ§ p â‰‹ q) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   sclo-id2 p Aâˆˆğ’¦ = p (sbase Aâˆˆğ’¦)


Identities for hom image closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::


   hclo-id1 : âˆ€{p q} â†’ (ğ’¦ âŠ§ p â‰‹ q) â†’ (HClo ğ’¦ âŠ§ p â‰‹ q)
   hclo-id1 {p}{q} ğ’¦âŠ§pâ‰‹q (hbase Aâˆˆğ’¦) = ğ’¦âŠ§pâ‰‹q Aâˆˆğ’¦
   hclo-id1 {p}{q} ğ’¦âŠ§pâ‰‹q (hhom{ğ‘¨} AâˆˆHCloğ’¦ ğ‘©Ï•hE) = Î³
    where
     AâŠ§pâ‰ˆq : ğ‘¨ âŠ§ p â‰ˆ q
     AâŠ§pâ‰ˆq = (hclo-id1{p}{q} ğ’¦âŠ§pâ‰‹q ) AâˆˆHCloğ’¦

     ğ‘© : Algebra ğ“¤ ğ‘†
     ğ‘© = âˆ£ ğ‘©Ï•hE âˆ£

     Ï• : âˆ£ ğ‘¨ âˆ£ â†’ âˆ£ ğ‘© âˆ£
     Ï• = âˆ£ âˆ¥ ğ‘©Ï•hE âˆ¥ âˆ£

     Ï•hom : is-homomorphism ğ‘¨ ğ‘© Ï•
     Ï•hom = âˆ£ prâ‚‚ âˆ¥ ğ‘©Ï•hE âˆ¥ âˆ£

     Ï•sur : (ğ’ƒ : X â†’ âˆ£ ğ‘© âˆ£ )(x : X) â†’ Image Ï• âˆ‹ (ğ’ƒ x)
     Ï•sur ğ’ƒ x = âˆ¥ prâ‚‚ âˆ¥ ğ‘©Ï•hE âˆ¥ âˆ¥ (ğ’ƒ x)

     preim : (ğ’ƒ : X â†’ âˆ£ ğ‘© âˆ£)(x : X) â†’ âˆ£ ğ‘¨ âˆ£
     preim ğ’ƒ x = (Inv Ï• (ğ’ƒ x) (Ï•sur ğ’ƒ x))

     Î¶ : (ğ’ƒ : X â†’ âˆ£ ğ‘© âˆ£) â†’ Ï• âˆ˜ (preim ğ’ƒ) â‰¡ ğ’ƒ
     Î¶ ğ’ƒ = gfe Î» x â†’ InvIsInv Ï• (ğ’ƒ x) (Ï•sur ğ’ƒ x)

     Î³ : (p Ì‡ ğ‘©) â‰¡ (q Ì‡ ğ‘©)
     Î³ = gfe Î» ğ’ƒ â†’
      (p Ì‡ ğ‘©) ğ’ƒ               â‰¡âŸ¨ (ap (p Ì‡ ğ‘©) (Î¶ ğ’ƒ))â»Â¹ âŸ©
      (p Ì‡ ğ‘©) (Ï• âˆ˜ (preim ğ’ƒ)) â‰¡âŸ¨ (comm-hom-term gfe ğ‘¨ ğ‘© (Ï• , Ï•hom) p (preim ğ’ƒ))â»Â¹ âŸ©
      Ï•((p Ì‡ ğ‘¨)(preim ğ’ƒ))     â‰¡âŸ¨ ap Ï• (intensionality AâŠ§pâ‰ˆq (preim ğ’ƒ)) âŸ©
      Ï•((q Ì‡ ğ‘¨)(preim ğ’ƒ))     â‰¡âŸ¨ comm-hom-term gfe ğ‘¨ ğ‘© (Ï• , Ï•hom) q (preim ğ’ƒ) âŸ©
      (q Ì‡ ğ‘©)(Ï• âˆ˜ (preim ğ’ƒ))  â‰¡âŸ¨ ap (q Ì‡ ğ‘©) (Î¶ ğ’ƒ) âŸ©
      (q Ì‡ ğ‘©) ğ’ƒ âˆ

   hclo-id2 : âˆ€ {p q} â†’ (HClo ğ’¦ âŠ§ p â‰‹ q) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   hclo-id2 p Aâˆˆğ’¦ = p (hbase Aâˆˆğ’¦)

Identities for HSP closure
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

   vclo-id1 : âˆ€ {p q} â†’ (ğ’¦ âŠ§ p â‰‹ q) â†’ (VClo ğ’¦ âŠ§ p â‰‹ q)
   vclo-id1 {p} {q} Î± (vbase Aâˆˆğ’¦) = Î± Aâˆˆğ’¦
   vclo-id1 {p} {q} Î± (vprod{I = I}{ğ’œ = ğ’œ} ğ’œâˆˆVCloğ’¦) = Î³
    where
     IH : (i : I) â†’ ğ’œ i âŠ§ p â‰ˆ q
     IH i = vclo-id1{p}{q} Î± (ğ’œâˆˆVCloğ’¦ i)

     Î³ : p Ì‡ (â¨… ğ’œ)  â‰¡ q Ì‡ (â¨… ğ’œ)
     Î³ = products-preserve-identities p q I ğ’œ IH

   vclo-id1 {p} {q} Î± ( vsub {ğ‘¨ = ğ‘¨} AâˆˆVCloğ’¦ sa ) = Î³
    where
     AâŠ§pâ‰ˆq : ğ‘¨ âŠ§ p â‰ˆ q
     AâŠ§pâ‰ˆq = vclo-id1{p}{q} Î± AâˆˆVCloğ’¦

     ğ‘© : Algebra ğ“¤ ğ‘†
     ğ‘© = âˆ£ sa âˆ£

     h : âˆ£ ğ‘© âˆ£ â†’ âˆ£ ğ‘¨ âˆ£
     h = prâ‚ âˆ¥ sa âˆ¥

     hem : is-embedding h
     hem = âˆ£ prâ‚‚ âˆ¥ sa âˆ¥ âˆ£

     hhm : is-homomorphism ğ‘© ğ‘¨ h
     hhm = âˆ¥ prâ‚‚ âˆ¥ sa âˆ¥ âˆ¥

     Î¾ : (b : X â†’ âˆ£ ğ‘© âˆ£ ) â†’ h ((p Ì‡ ğ‘©) b) â‰¡ h ((q Ì‡ ğ‘©) b)
     Î¾ b =
      h ((p Ì‡ ğ‘©) b)  â‰¡âŸ¨ comm-hom-term gfe ğ‘© ğ‘¨ (h , hhm) p b âŸ©
      (p Ì‡ ğ‘¨)(h âˆ˜ b) â‰¡âŸ¨ intensionality AâŠ§pâ‰ˆq (h âˆ˜ b) âŸ©
      (q Ì‡ ğ‘¨)(h âˆ˜ b) â‰¡âŸ¨ (comm-hom-term gfe ğ‘© ğ‘¨ (h , hhm) q b)â»Â¹ âŸ©
      h ((q Ì‡ ğ‘©) b)  âˆ

     hlc : {b b' : domain h} â†’ h b â‰¡ h b' â†’ b â‰¡ b'
     hlc hbâ‰¡hb' = (embeddings-are-lc h hem) hbâ‰¡hb'

     Î³ : p Ì‡ ğ‘© â‰¡ q Ì‡ ğ‘©
     Î³ = gfe Î» b â†’ hlc (Î¾ b)

   vclo-id1 {p}{q} Î± (vhom{ğ‘¨ = ğ‘¨} AâˆˆVCloğ’¦ ğ‘©Ï•hE) = Î³
    where
     AâŠ§pâ‰ˆq : ğ‘¨ âŠ§ p â‰ˆ q
     AâŠ§pâ‰ˆq = vclo-id1{p}{q} Î± AâˆˆVCloğ’¦

     ğ‘© : Algebra ğ“¤ ğ‘†
     ğ‘© = âˆ£ ğ‘©Ï•hE âˆ£

     Ï• : âˆ£ ğ‘¨ âˆ£ â†’ âˆ£ ğ‘© âˆ£
     Ï• = âˆ£ âˆ¥ ğ‘©Ï•hE âˆ¥ âˆ£

     Ï•h : is-homomorphism ğ‘¨ ğ‘© Ï•
     Ï•h = âˆ£ prâ‚‚ âˆ¥ ğ‘©Ï•hE âˆ¥ âˆ£

     Ï•E : (ğ’ƒ : X â†’ âˆ£ ğ‘© âˆ£ )(x : X) â†’ Image Ï• âˆ‹ (ğ’ƒ x)
     Ï•E ğ’ƒ x = âˆ¥ prâ‚‚ âˆ¥ ğ‘©Ï•hE âˆ¥ âˆ¥ (ğ’ƒ x)

     preim : (ğ’ƒ : X â†’ âˆ£ ğ‘© âˆ£)(x : X) â†’ âˆ£ ğ‘¨ âˆ£
     preim ğ’ƒ x = (Inv Ï• (ğ’ƒ x) (Ï•E ğ’ƒ x))

     Î¶ : (ğ’ƒ : X â†’ âˆ£ ğ‘© âˆ£) â†’ Ï• âˆ˜ (preim ğ’ƒ) â‰¡ ğ’ƒ
     Î¶ ğ’ƒ = gfe Î» x â†’ InvIsInv Ï• (ğ’ƒ x) (Ï•E ğ’ƒ x)

     Î³ : (p Ì‡ ğ‘©) â‰¡ (q Ì‡ ğ‘©)
     Î³ = gfe Î» ğ’ƒ â†’
      (p Ì‡ ğ‘©) ğ’ƒ               â‰¡âŸ¨ (ap (p Ì‡ ğ‘©) (Î¶ ğ’ƒ))â»Â¹ âŸ©
      (p Ì‡ ğ‘©) (Ï• âˆ˜ (preim ğ’ƒ)) â‰¡âŸ¨ (comm-hom-term gfe ğ‘¨ ğ‘© (Ï• , Ï•h) p (preim ğ’ƒ))â»Â¹ âŸ©
      Ï•((p Ì‡ ğ‘¨)(preim ğ’ƒ))     â‰¡âŸ¨ ap Ï• (intensionality AâŠ§pâ‰ˆq (preim ğ’ƒ)) âŸ©
      Ï•((q Ì‡ ğ‘¨)(preim ğ’ƒ))     â‰¡âŸ¨ comm-hom-term gfe ğ‘¨ ğ‘© (Ï• , Ï•h) q (preim ğ’ƒ) âŸ©
      (q Ì‡ ğ‘©)(Ï• âˆ˜ (preim ğ’ƒ))  â‰¡âŸ¨ ap (q Ì‡ ğ‘©) (Î¶ ğ’ƒ) âŸ©
      (q Ì‡ ğ‘©) ğ’ƒ âˆ

   vclo-id2 : âˆ€ {p q} â†’ (VClo ğ’¦ âŠ§ p â‰‹ q) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   vclo-id2 p Aâˆˆğ’¦ = p (vbase Aâˆˆğ’¦)


--------------------------------------------------

Axiomatization of a class
-------------------------

We conclude the `closure module`_ by proving that a class ğ’¦ of structures is axiomatized by ``Th (VClo ğ’¦)``, which is the set of equations satisfied by all members of the varietal closure of ğ’¦.

::

   -- Th (VClo ğ’¦) is precisely the set of identities modeled by ğ’¦
   ThHSP-axiomatizes : (p q : âˆ£ (ğ‘» X) âˆ£)
             -----------------------------------------
    â†’         ğ’¦ âŠ§ p â‰‹ q  â‡”  ((p , q) âˆˆ Th (VClo ğ’¦))

   ThHSP-axiomatizes p q =
    (Î» ğ’¦âŠ§pâ‰‹q ğ‘¨âˆˆVCloğ’¦ â†’ vclo-id1{p = p}{q = q} ğ’¦âŠ§pâ‰‹q ğ‘¨âˆˆVCloğ’¦) ,
    Î» pqâˆˆTh ğ‘¨âˆˆğ’¦ â†’ pqâˆˆTh (vbase ğ‘¨âˆˆğ’¦)



-----------------------------------------------

Unicode Hints
---------------

Table of some special characters used in the `closure module`_.

  +--------+------------------------+
  | To get | Type                   |
  +--------+------------------------+
  | ğ’‚, ğ’ƒ   | ``\MIa``, ``\MIb``     |
  +--------+------------------------+
  | ğ‘“ Ì‚ ğ‘¨  |  ``\Mif \^ \MIA``      |
  +--------+------------------------+
  | â‰…      | ``â‰…`` or ``\cong``     |
  +--------+------------------------+
  | âˆ˜      | ``\comp`` or ``\circ`` |
  +--------+------------------------+
  | ğ’¾ğ’¹     | ``\Mci\Mcd``           |
  +--------+------------------------+
  | â„’ğ’¦     | ``\McL\McK``           |
  +--------+------------------------+
  | Ï•      | ``\phi``               |
  +--------+------------------------+

See :numref:`unicode hints` for a longer list of symbols used in the agda-ualib_, or better yet, use these

  **Emacs commands providing information about special characters/input methods**:

    * ``M-x describe-char`` (or ``M-m h d c``) with the cursor on the character of interest

    * ``M-x describe-input-method`` (or ``C-h I``)

-------------------------

.. include:: hyperlink_references.rst

