.. FILE: closure.lagda.rst
.. AUTHOR: William DeMeo and Siva Somayyajula
.. DATE: 2 Jul 2020

===========================
Equational Logic in Agda
===========================

Closure operators
-----------------

Fix a signature ğ‘†.

Let ğ’¦ be a class of ğ‘†-algebras. Define

  * H(ğ’¦) = homomorphic images of members of ğ’¦;
  * S(ğ’¦) = algebras isomorphic to a subalgebra of a member of ğ’¦;
  * P(ğ’¦) = algebras isomorphic to a direct product of members of ğ’¦.

As a straight-forward verification confirms, H, S, and P are closure operators. A class ğ’¦ of ğ‘†-algebras is said to be *closed under the formation of homomorphic images* if H(ğ’¦) âŠ† ğ’¦. Similarly, ğ’¦ is *closed under the formation of subalgebras* (resp., *products*) provided S(ğ’¦) âŠ† ğ’¦ (resp., P(ğ’¦) âŠ† ğ’¦).

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class H(ğ’¦) (resp., S(ğ’¦); resp., P(ğ’¦)) is closed under isomorphism.

The operators H, S, and P can be composed with one another repeatedly, forming yet more closure operators. If Câ‚ and Câ‚‚ are closure operators on classes of structures, let us say that Câ‚ â‰¤ Câ‚‚ if for every class ğ’¦ we have Câ‚(ğ’¦) âŠ† Câ‚‚(ğ’¦).

.. _lem 3.41:

.. proof:lemma:: Lem. 3.41 of :cite:`Bergman:2012`

   SH â‰¤ HS, PS â‰¤ SP.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let C âˆˆ SH(ğ’¦). Then C â‰¤ B for some B âˆˆ H(A), where A âˆˆ ğ’¦.  Let Î¸ be such that B â‰… A/Î¸.  Then C is isomorphic to a subalgebra, say, T, of A/Î¸.  By the correspondence theorem, there is a subalgebra S â‰¤ A such that S/Î¸ = T.  Thus, C âˆˆ HS(A) âŠ† HS(ğ’¦), as desired.

      Let C âˆˆ PS(ğ’¦). Then C = Î  Báµ¢ for some Báµ¢ â‰¤ Aáµ¢ âˆˆ ğ’¦. Clearly, C = Î  Báµ¢ â‰¤ Î  Aáµ¢, so C âˆˆ SP(ğ’¦), as desired. âˆ

---------------------------------------------

Varieties
-------------

A class ğ’¦ of ğ‘†-algebras is called a **variety** if it is closed under each of the closure operators H, S, and P introduced above; the corresponding closure operator is often denoted ğ•. Thus, if ğ’¦ is a class of similar algebras, then the **variety generated by** ğ’¦ is denoted by ğ•(ğ’¦) and defined to be the smallest class that contains ğ’¦ and is closed under H, S, and P.

.. The class of all varieties of ğ‘†-algebras is ordered by inclusion, and closed under arbitrary intersection; thus, the class of varieties is a complete lattice.

We would like to know how to construct ğ•(ğ’¦) directly from ğ’¦, but it's not immediately obvious how many times we would have to apply the operators H, S, P before the result stabilizes to form a variety---the **variety generated by** ğ’¦.  Fortunately, Garrett Birkhoff proved that if we apply the operators in the correct order, then it suffices to apply each one only once.

.. proof:theorem:: Thm 3.43 of :cite:`Bergman:2012`

   ğ• = HSP.

   .. container:: toggle

      .. container:: header

         *Proof*.

      Let ğ’¦ be a class of algebras. To see that HSP(ğ’¦) is a variety, we use :numref:`Lemma %s <lem 3.41>` to compute H(HSP) = HSP, S(HSP) â‰¤ HSÂ²P = HSP, P(HSP) â‰¤ HSPÂ² = HSP. Thus HSP â‰¥ ğ•.

      On the other hand, HSP(ğ’¦) âŠ† HSP(ğ•(ğ’¦)) = ğ•(ğ’¦) so HSP â‰¤ ğ•.

---------------------------------------------------

Equational classes
---------------------

In his treatment of Birhoff's HSP theorem, Cliff Bergman (at the start of Section 4.4 of his universal algebra textbook :cite:`Bergman:2012`) proclaims, "Now, finally, we can formalize the idea we have been using since the first page of this text."  He then proceeds to define **identities of terms** as follows (paraphrasing for notational consistency):

Let ğ‘† be a signature.  An **identity** or **equation** in ğ‘† is an ordered pair of terms, written ğ‘ â‰ˆ ğ‘, from the term algebra ğ”‰. If A is an ğ‘†-algebra we say that A **satisfies** ğ‘ â‰ˆ ğ‘ if ğ‘ Ì‡ A â‰¡ ğ‘ Ì‡ A.  In this  situation,  we  write A âŠ§ ğ‘ â‰ˆ ğ‘.

If ğ’¦ is a class of ğ‘†-algebras, we write ğ’¦ âŠ§ ğ‘ â‰‹ ğ‘ if, for every A âˆˆ ğ’¦, A âŠ§ ğ‘ â‰ˆ ğ‘. Finally, if ğ“” is a set of equations, we write ğ’¦ âŠ§ ğ“” if every member of ğ’¦ satisfies every member of ğ“”.

We formalize these notions in Agda in the ``closure`` module, which begins as follows.

::

  {-# OPTIONS --without-K --exact-split --safe #-}

  open import prelude

  open import basic using (Signature; Algebra; Î '; Op)

  open import subuniverses using (Subuniverses; SubunivAlg;
   hom-image-alg; _is-subalgebra-of_; Subalgebra)

  open import homomorphisms using (hom; is-homomorphism)

  open import terms using (Term; generator; node; _Ì‡_; _Ì‚_;
   interp-prod2; interp-prod; comm-hom-term')

  module closure {S : Signature ğ“ ğ“¥} where

  _âŠ§_â‰ˆ_ : {X : ğ“§ Ì‡ } â†’ Algebra ğ“¤ S
   â†’      Term{X = X} â†’ Term â†’ ğ“§ âŠ” ğ“¤ Ì‡

  A âŠ§ p â‰ˆ q = (p Ì‡ A) â‰¡ (q Ì‡ A)

  _âŠ§_â‰‹_ : {X : ğ“§ Ì‡ } â†’ Pred (Algebra ğ“¤ S) ğ“¦
   â†’      Term{X = X} â†’ Term â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“§ âŠ” ğ“¤ âº Ì‡

  _âŠ§_â‰‹_ ğ’¦ p q = {A : Algebra _ S} â†’ ğ’¦ A â†’ A âŠ§ p â‰ˆ q


---------------------------------------------

Identity preservation
----------------------

Identities are compatible with the formation of subalgebras, homomorphic images and products. More precisely,
for every class ğ’¦ of structures, each of the classes S(ğ’¦), H(ğ’¦), P(ğ’¦), ğ•(ğ’¦) satisfies the same set of identities as does ğ’¦.

We formalize the notion of closure under the taking of homomorphic images in the `morphisms` module.  Here we will formalize closure under the taking of products and subuniverses, and prove that these closures preserve identities.

.. _obs 13 in agda:

Identities in products
~~~~~~~~~~~~~~~~~~~~~~~~

Let â„™ (ğ’¦) denote the class of algebras isomorphic to a direct product of members of ğ’¦.

::

  P-closed : (ğ“›ğ’¦ : (ğ“¤ : Universe) â†’ Pred (Algebra ğ“¤ S) (ğ“¤ âº ))
   â†’      (ğ“˜ : Universe) (I : ğ“˜ Ì‡ ) (ğ’œ : I â†’ Algebra ğ“˜ S)
   â†’      (( i : I ) â†’ ğ’œ i âˆˆ ğ“›ğ’¦ ğ“˜ ) â†’ ğ“˜ âº Ì‡
  P-closed ğ“›ğ’¦ = Î» ğ“˜ I ğ’œ ğ’œiâˆˆğ“›ğ’¦ â†’  Î ' ğ’œ  âˆˆ (ğ“›ğ’¦ ğ“˜)

  module _
    (gfe : global-dfunext)
    (ğ’¦ : Pred (Algebra ğ“¤ S)(ğ“ âŠ” ğ“¥ âŠ” ((ğ“¤ âº) âº))) { X : ğ“§ Ì‡ } where

    products-preserve-identities : (p q : Term{X = X})
          (I : ğ“¤ Ì‡ ) (ğ’œ : I â†’ Algebra ğ“¤ S)
     â†’    ğ’¦ âŠ§ p â‰‹ q  â†’  ((i : I) â†’ ğ’œ i âˆˆ ğ’¦)
     â†’    Î ' ğ’œ âŠ§ p â‰ˆ q
    products-preserve-identities p q I ğ’œ ğ’¦âŠ§pâ‰‹q allğ’œiâˆˆğ’¦ = Î³
     where
      allğ’œâŠ§pâ‰ˆq : âˆ€ i â†’ (ğ’œ i) âŠ§ p â‰ˆ q
      allğ’œâŠ§pâ‰ˆq i = ğ’¦âŠ§pâ‰‹q (allğ’œiâˆˆğ’¦ i)

      Î³ : (p Ì‡ Î ' ğ’œ) â‰¡ (q Ì‡ Î ' ğ’œ)
      Î³ = gfe Î» a â†’
       (p Ì‡ Î ' ğ’œ) a
         â‰¡âŸ¨ interp-prod gfe p ğ’œ a âŸ©
       (Î» i â†’ ((p Ì‡ (ğ’œ i)) (Î» x â†’ (a x) i)))
         â‰¡âŸ¨ gfe (Î» i â†’ cong-app (allğ’œâŠ§pâ‰ˆq i) (Î» x â†’ (a x) i)) âŸ©
       (Î» i â†’ ((q Ì‡ (ğ’œ i)) (Î» x â†’ (a x) i)))
         â‰¡âŸ¨ (interp-prod gfe q ğ’œ a)â»Â¹ âŸ©
       (q Ì‡ Î ' ğ’œ) a
         âˆ


Identities in subalgebras
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let S(ğ’¦) denote the class of algebras isomorphic to a subalgebra of a member of ğ’¦. We show that every term equation, ğ‘ â‰ˆ ğ‘, that is satisfied by all A âˆˆ ğ’¦ is also satisfied by all B âˆˆ S(ğ’¦).

::

  _is-subalgebra-of-class_ : {ğ“¤ : Universe} (B : Algebra ğ“¤ S)
   â†’                 Pred (Algebra ğ“¤ S)(ğ“¤ âº) â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº Ì‡
  B is-subalgebra-of-class ğ’¦ =
   Î£ A ê‰ (Algebra _ S) , (A âˆˆ ğ’¦) Ã— (B is-subalgebra-of A)

  module _
   (ğ’¦ : Pred (Algebra ğ“¤ S) ( ğ“¤ âº ))
   (ğ’¦' : Pred (Algebra ğ“¤ S)(ğ“ âŠ” ğ“¥ âŠ” ((ğ“¤ âº) âº))){X : ğ“§ Ì‡ }
   (ğ“¤â˜… : Univalence) where

   gfe : global-dfunext
   gfe = univalence-gives-global-dfunext ğ“¤â˜…

   SubalgebrasOfClass : Pred (Algebra ğ“¤ S)(ğ“¤ âº) â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº Ì‡
   SubalgebrasOfClass ğ’¦ =
    Î£ A ê‰ (Algebra _ S) , (A âˆˆ ğ’¦) Ã— Subalgebra{A = A} ğ“¤â˜…

   ğ•Š-closed : (ğ“›ğ’¦ : (ğ“¤ : Universe) â†’ Pred (Algebra ğ“¤ S) (ğ“¤ âº))
    â†’      (ğ“¤ : Universe) â†’ (B : Algebra ğ“¤ S) â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº Ì‡
   ğ•Š-closed ğ“›ğ’¦ =
    Î» ğ“¤ B â†’ (B is-subalgebra-of-class (ğ“›ğ’¦ ğ“¤)) â†’ (B âˆˆ ğ“›ğ’¦ ğ“¤)

   subalgebras-preserve-identities : (p q : Term{X = X})
    â†’  (ğ’¦ âŠ§ p â‰‹ q) â†’ (SAK : SubalgebrasOfClass ğ’¦)
    â†’  (prâ‚ âˆ¥ (prâ‚‚ SAK) âˆ¥) âŠ§ p â‰ˆ q
   subalgebras-preserve-identities p q ğ’¦âŠ§pâ‰‹q SAK = Î³
    where

     A : Algebra ğ“¤ S
     A = âˆ£ SAK âˆ£

     Aâˆˆğ’¦ : A âˆˆ ğ’¦
     Aâˆˆğ’¦ = âˆ£ prâ‚‚ SAK âˆ£

     AâŠ§pâ‰ˆq : A âŠ§ p â‰ˆ q
     AâŠ§pâ‰ˆq = ğ’¦âŠ§pâ‰‹q Aâˆˆğ’¦

     subalg : Subalgebra{A = A} ğ“¤â˜…
     subalg = âˆ¥ prâ‚‚ SAK âˆ¥

     B : Algebra ğ“¤ S
     B = prâ‚ subalg

     h : âˆ£ B âˆ£ â†’ âˆ£ A âˆ£
     h = âˆ£ prâ‚‚ subalg âˆ£

     h-emb : is-embedding h
     h-emb = prâ‚ âˆ¥ prâ‚‚ subalg âˆ¥

     h-hom : is-homomorphism B A h
     h-hom = prâ‚‚ âˆ¥ prâ‚‚ subalg âˆ¥

     Î¾ : (ğ’ƒ : X â†’ âˆ£ B âˆ£ ) â†’ h ((p Ì‡ B) ğ’ƒ) â‰¡ h ((q Ì‡ B) ğ’ƒ)
     Î¾ ğ’ƒ =
      h ((p Ì‡ B) ğ’ƒ)  â‰¡âŸ¨ comm-hom-term' gfe B A (h , h-hom) p ğ’ƒ âŸ©
      (p Ì‡ A)(h âˆ˜ ğ’ƒ) â‰¡âŸ¨ intensionality AâŠ§pâ‰ˆq (h âˆ˜ ğ’ƒ) âŸ©
      (q Ì‡ A)(h âˆ˜ ğ’ƒ) â‰¡âŸ¨ (comm-hom-term' gfe B A (h , h-hom) q ğ’ƒ)â»Â¹ âŸ©
      h ((q Ì‡ B) ğ’ƒ)  âˆ

     hlc : {b b' : domain h} â†’ h b â‰¡ h b' â†’ b â‰¡ b'
     hlc hbâ‰¡hb' = (embeddings-are-lc h h-emb) hbâ‰¡hb'

     Î³ : B âŠ§ p â‰ˆ q
     Î³ = gfe Î» ğ’ƒ â†’ hlc (Î¾ ğ’ƒ)


Closure under H, S, P
----------------------

::

  data PClo (ğ’¦ : Pred (Algebra ğ“¤ S) ğ“£) : Pred (Algebra ğ“¤ S)(ğ“ âŠ” ğ“¥ âŠ” ğ“£ âŠ” ğ“¤ âº ) where
   pbase : {A : Algebra ğ“¤ S} â†’ A âˆˆ ğ’¦ â†’ A âˆˆ PClo ğ’¦
   prod : {I : ğ“¤ Ì‡ }{ğ’œ : I â†’ Algebra _ S}
    â†’     (âˆ€ i â†’ ğ’œ i âˆˆ PClo ğ’¦)
    â†’     Î ' ğ’œ âˆˆ PClo ğ’¦

  data SClo (ğ’¦ : Pred (Algebra ğ“¤ S) ğ“£) : Pred (Algebra ğ“¤ S)(ğ“ âŠ” ğ“¥ âŠ” ğ“£ âŠ” ğ“¤ âº ) where
   sbase : {A : Algebra _ S} â†’ A âˆˆ ğ’¦ â†’ A âˆˆ SClo ğ’¦
   --sub : {A B : Algebra _ S} â†’ A âˆˆ SClo ğ’¦ â†’ B is-subalgebra-of A â†’ B âˆˆ SClo ğ’¦
   --sub : {A : Algebra _ S} â†’ A âˆˆ SClo ğ’¦ â†’ B is-subalgebra-of A â†’ B âˆˆ SClo ğ’¦
   sub : {A : Algebra _ S} {B : Pred âˆ£ A âˆ£ ğ“¤ }
         {ğ¹ : (ğ“¸ : âˆ£ S âˆ£) â†’ Op (âˆ¥ S âˆ¥ ğ“¸) (Î£ B)}
         (BâˆˆSubA : B âˆˆ Subuniverses A)
    â†’    A âˆˆ SClo ğ’¦
    â†’    SubunivAlg{A = A}{B = B}{ğ¹ = ğ¹} BâˆˆSubA âˆˆ SClo ğ’¦

  data HClo (ğ’¦ : Pred (Algebra ğ“¤ S) ğ“£) : Pred (Algebra ğ“¤ S)(ğ“ âŠ” ğ“¥ âŠ” ğ“£ âŠ” ğ“¤ âº ) where
   hbase : {A : Algebra ğ“¤ S} â†’ A âˆˆ ğ’¦ â†’ A âˆˆ HClo ğ’¦
   hhom : {A B : Algebra ğ“¤ S}{f : hom A B}
    â†’     A âˆˆ HClo ğ’¦
    â†’     hom-image-alg {A = A}{B = B} f âˆˆ HClo ğ’¦

  data VClo (ğ’¦ : Pred (Algebra ğ“¤ S) ğ“£) : Pred (Algebra ğ“¤ S)(ğ“ âŠ” ğ“¥ âŠ” ğ“£ âŠ” ğ“¤ âº ) where
   vbase : {A : Algebra ğ“¤ S} â†’ A âˆˆ ğ’¦ â†’ A âˆˆ VClo ğ’¦
   vprod : {I : ğ“¤ Ì‡ }{ğ’œ : I â†’ Algebra _ S} â†’ (âˆ€ i â†’ ğ’œ i âˆˆ VClo ğ’¦) â†’ Î ' ğ’œ âˆˆ VClo ğ’¦
   vsub : âˆ€{A : Algebra _ S}{B : Algebra _ S} â†’ A âˆˆ VClo ğ’¦ â†’ B is-subalgebra-of A â†’ B âˆˆ VClo ğ’¦
   vhom : {A B : Algebra ğ“¤ S}{f : hom A B}
    â†’     A âˆˆ VClo ğ’¦ â†’ hom-image-alg {A = A}{B = B} f âˆˆ VClo ğ’¦

---------------------------------------------

Alternative formulations
----------------------------

::

  module _
   (ğ’¦ : Pred (Algebra ğ“¤ S) ğ“£)
   (gfe : global-dfunext)
   (dfe : dfunext ğ“¤ ğ“¤)
   {X : ğ“¤ Ì‡ } where

   _âŠ§'_â‰‹_ : Pred (Algebra ğ“¤ S) ğ“¦ â†’ Term {X = X} â†’ Term â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤ âº Ì‡
   _âŠ§'_â‰‹_ = _âŠ§_â‰‹_ {X = X}

   pclo-id1 : âˆ€ {p q} â†’ (ğ’¦ âŠ§ p â‰‹ q) â†’ (PClo ğ’¦ âŠ§ p â‰‹ q)
   pclo-id1 {p} {q} Î± (pbase x) = Î± x
   pclo-id1 {p} {q} Î± (prod{I}{ğ’œ} ğ’œ-Pğ’¦ ) = Î³
    where
     IH : (i : I)  â†’ (p Ì‡ ğ’œ i) â‰¡ (q Ì‡ ğ’œ i)
     IH = Î» i â†’ pclo-id1{p}{q} Î±  ( ğ’œ-Pğ’¦  i )
     Î³ : p Ì‡ (Î ' ğ’œ)  â‰¡ q Ì‡ (Î ' ğ’œ)
     Î³ =
      (p Ì‡ (Î ' ğ’œ) )
        â‰¡âŸ¨ interp-prod2 gfe p ğ’œ âŸ©
      (Î» (args : X â†’ âˆ£ Î ' ğ’œ âˆ£) â†’ (Î» i â†’ (p Ì‡ ğ’œ i)(Î» x â†’ (args x) i)))
        â‰¡âŸ¨ dfe (Î» args â†’ (ap (Î» - â†’ (Î» i â†’ (- i)(Î» x â†’ args x i))) (dfe IH))) âŸ©
      (Î» (args : X â†’ âˆ£ Î ' ğ’œ âˆ£) â†’ (Î» i â†’ (q Ì‡ ğ’œ i)(Î» x â†’ (args x) i)))
        â‰¡âŸ¨ (interp-prod2 gfe q ğ’œ)â»Â¹ âŸ©
      (q Ì‡ (Î ' ğ’œ))
        âˆ

   pclo-id2 : âˆ€{p q} â†’ ((PClo ğ’¦) âŠ§' p â‰‹ q ) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   pclo-id2 p Aâˆˆğ’¦ = p (pbase Aâˆˆğ’¦)

   sclo-id1 : âˆ€{p q} â†’ (ğ’¦ âŠ§' p â‰‹ q) â†’ (SClo ğ’¦ âŠ§ p â‰‹ q)
   sclo-id1 {p} {q} ğ’¦âŠ§pâ‰‹q (sbase Aâˆˆğ’¦) = ğ’¦âŠ§pâ‰‹q Aâˆˆğ’¦
   sclo-id1 {p} {q} ğ’¦âŠ§pâ‰‹q (sub {A = A}{B = B}{ğ¹ = ğ¹} BâˆˆSubA AâˆˆSCloğ’¦) = Î³
    where
     IH : p Ì‡ A â‰¡ q Ì‡ A
     IH = sclo-id1{p}{q} ğ’¦âŠ§pâ‰‹q AâˆˆSCloğ’¦

     B : Algebra ğ“¤ S
     B = SubunivAlg{A = A}{B = B}{ğ¹ = ğ¹} BâˆˆSubA
     -- We need to do this so that both A and Î£ B , ğ¹ can be classified by the same predicate SClo.
     -- tBâ‰¡tA : âˆ€ ğ’• â†’ ( ğ’ƒ : X â†’ Î£ B ) â†’ ( ğ’• Ì‡ (Î£ B , ğ¹) )( Î» x â†’  ğ’ƒ x ) â‰¡ (ğ’• Ì‡ A) (Î» x â†’  âˆ£ ğ’ƒ x âˆ£ )
     -- tBâ‰¡tA ğ’• = ?
      -- mem :   {B : Pred âˆ£ A âˆ£ ğ“¤}  { ğ¹ : ( ğ“¸ : âˆ£ S âˆ£ ) â†’ Op ( âˆ¥ S âˆ¥ ğ“¸ ) (Î£ B) }
      --   â†’    ( ( ğ“¸ : âˆ£ S âˆ£ ) ( a : âˆ¥ S âˆ¥ ğ“¸ â†’ Î£ B )  â†’  âˆ£ ğ¹ ğ“¸ a âˆ£ â‰¡ âˆ¥ A âˆ¥ ğ“¸ (Î» i â†’ âˆ£ a i âˆ£ ) )
      --   â†’    A is-supalgebra-of (Î£ B , ğ¹)
     uni2alg : B is-subalgebra-of A
     uni2alg = ?

     Î³ : p Ì‡ B â‰¡ q Ì‡ B
     Î³ = let sts = uni2alg in
      gfe Î» ğ’ƒ â†’
       (p Ì‡ B) ğ’ƒ â‰¡âŸ¨ ? âŸ©  -- we need an elimination rule here (see is-subalg-elim in UF-Subuniverse.agda)
         -- (p Ì‡ uni2alg) ğ’ƒ â‰¡âŸ¨ IH âŸ©
         -- (q Ì‡ uni2alg) ğ’ƒ â‰¡âŸ¨ ? âŸ©
       (q Ì‡ B) ğ’ƒ  âˆ

   sclo-id2 : âˆ€ {p q} â†’ (SClo ğ’¦ âŠ§' p â‰‹ q) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   sclo-id2 p Aâˆˆğ’¦ = p (sbase Aâˆˆğ’¦)

   hclo-id1 : âˆ€{p q} â†’ (ğ’¦ âŠ§ p â‰‹ q) â†’ (HClo ğ’¦ âŠ§ p â‰‹ q)
   hclo-id1 {p}{q} ğ’¦âŠ§pâ‰‹q (hbase Aâˆˆğ’¦) = ğ’¦âŠ§pâ‰‹q Aâˆˆğ’¦
   hclo-id1 {p}{q} ğ’¦âŠ§pâ‰‹q (hhom{A}{B}{f} AâˆˆHCloğ’¦) = Î³
    where
     AâŠ§pâ‰ˆq : A âŠ§ p â‰ˆ q
     AâŠ§pâ‰ˆq = (hclo-id1{p}{q} ğ’¦âŠ§pâ‰‹q ) AâˆˆHCloğ’¦

     IH : (p Ì‡ A) â‰¡ (q Ì‡ A)
     IH = AâŠ§pâ‰ˆq

     HIA = hom-image-alg{A = A}{B = B} f

     preim : (ğ’ƒ : X â†’ Î£ (Image_âˆ‹_ âˆ£ f âˆ£))(x : X) â†’ âˆ£ A âˆ£
     preim = Î» ğ’ƒ x â†’ (Inv âˆ£ f âˆ£ (âˆ£ ğ’ƒ x âˆ£)(âˆ¥ ğ’ƒ x âˆ¥))

     hom-image-term-interpretation hiti : (ğ’ƒ : X â†’ âˆ£ HIA âˆ£)(p : Term)
      â†’ (p Ì‡ HIA ) ğ’ƒ â‰¡ âˆ£ f âˆ£ ((p Ì‡ A)( Î» i â†’ preim ğ’ƒ i )) , im ((p Ì‡ A)(Î» i â†’ preim ğ’ƒ i))

     hom-image-term-interpretation ğ’ƒ (generator x) =
      let iiif = ( InvIsInv âˆ£ f âˆ£ âˆ£ ğ’ƒ x âˆ£ âˆ¥ ğ’ƒ x âˆ¥ )â»Â¹ in
       ğ’ƒ x â‰¡âŸ¨ ? âŸ© âˆ£ f âˆ£ (preim ğ’ƒ x) , im (preim ğ’ƒ x) âˆ

     hom-image-term-interpretation ğ’ƒ (node ğ“¸ ğ’•) =  ap (Î» - â†’ (ğ“¸ Ì‚ HIA) -) (gfe Î» x â†’ Ï†IH x)
      where
       Ï†IH : (x : âˆ¥ S âˆ¥ ğ“¸)
        â†’ ( ğ’• x Ì‡ HIA ) ğ’ƒ  â‰¡ âˆ£ f âˆ£ ( ( ğ’• x Ì‡ A ) (preim ğ’ƒ) ) , im ((ğ’• x Ì‡ A) (preim ğ’ƒ ) )
       Ï†IH x = hom-image-term-interpretation ğ’ƒ (ğ’• x)

     hiti = hom-image-term-interpretation  -- alias

     Î³ : (p Ì‡ HIA) â‰¡ (q Ì‡ HIA)
     Î³ = (p Ì‡ HIA)
               â‰¡âŸ¨ refl _ âŸ©
           ( Î» ( ğ’ƒ : X â†’ âˆ£ HIA âˆ£ ) â†’ (p Ì‡ HIA) ( Î» x â†’ (ğ’ƒ x) ) )
               â‰¡âŸ¨ gfe (Î» x â†’ hiti x p) âŸ©
           ( Î» ğ’ƒ â†’ âˆ£ f âˆ£ ( (p Ì‡ A) ( Î» x â†’ preim ğ’ƒ x ) ) , im ( (p Ì‡ A) ( Î» x â†’ preim ğ’ƒ x ) ) )
               â‰¡âŸ¨ ap (Î» - â†’ Î» ğ’ƒ â†’ âˆ£ f âˆ£ (- (Î» x â†’ preim ğ’ƒ x) )  , im (-  (Î» x â†’ preim ğ’ƒ x) )) IH âŸ©
           ( Î» ğ’ƒ â†’ âˆ£ f âˆ£ ( (q Ì‡ A) ( Î» x â†’ preim ğ’ƒ x ) ) , im ( (q Ì‡ A) ( Î» x â†’ preim ğ’ƒ x ) ) )
               â‰¡âŸ¨ ( gfe (Î» x â†’ hiti x q) )â»Â¹ âŸ©
           ( Î» ğ’ƒ â†’ (q Ì‡ HIA) ( Î» x â†’ (ğ’ƒ x) ) )
               â‰¡âŸ¨ refl _ âŸ©
           (q Ì‡ HIA)    âˆ

   hclo-id2 : âˆ€ {p q} â†’ (HClo ğ’¦ âŠ§' p â‰‹ q) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   hclo-id2 p Aâˆˆğ’¦ = p (hbase Aâˆˆğ’¦)

   vclo-id1 : âˆ€ {p q} â†’ (ğ’¦ âŠ§' p â‰‹ q) â†’ (VClo ğ’¦ âŠ§ p â‰‹ q)
   vclo-id1 {p} {q} Î± (vbase Aâˆˆğ’¦) = Î± Aâˆˆğ’¦
   vclo-id1 {p} {q} Î± (vprod{I = I}{ğ’œ = ğ’œ} allAiâˆˆVCloğ’¦) = Î³
     where
      IH : (i : I) â†’ ğ’œ i âŠ§ p â‰ˆ q
      IH i = vclo-id1{p}{q} Î± (allAiâˆˆVCloğ’¦ i)

      Î³ : p Ì‡ (Î ' ğ’œ)  â‰¡ q Ì‡ (Î ' ğ’œ)
      Î³ =
       (p Ì‡ (Î ' ğ’œ))
         â‰¡âŸ¨ interp-prod2 gfe p ğ’œ âŸ©
       (Î» (args : X â†’ âˆ£ Î ' ğ’œ âˆ£) â†’ (Î» i â†’ (p Ì‡ ğ’œ i)(Î» x â†’ (args x) i)))
         â‰¡âŸ¨ dfe (Î» args â†’ (ap (Î» - â†’ (Î» i â†’ (- i)(Î» x â†’ args x i))) (dfe IH))) âŸ©
       (Î» (args : X â†’ âˆ£ Î ' ğ’œ âˆ£) â†’ (Î» i â†’ (q Ì‡ ğ’œ i)(Î» x â†’ (args x) i)))
         â‰¡âŸ¨ (interp-prod2 gfe q ğ’œ)â»Â¹ âŸ©
       (q Ì‡ (Î ' ğ’œ))
         âˆ

   --vsub : âˆ€ {A : Algebra _ S} {B : Algebra _ S} â†’ A âˆˆ VClo ğ’¦ â†’ B is-subalgebra-of A â†’ B âˆˆ VClo ğ’¦
   vclo-id1 {p} {q} Î± ( vsub {A = A}{B = B} AâˆˆVCloğ’¦ Bâ‰¤A ) = Î³
     where
      Î³ : B âŠ§ p â‰ˆ q
      Î³ = ?

   --vhom : {A B : Algebra ğ“¤ S} {f : Hom A B} â†’ A âˆˆ VClo ğ’¦ â†’  hom-image-alg {A = A}{B = B} f âˆˆ VClo ğ’¦
   vclo-id1 {p} {q} Î± ( vhom{A = A}{B = B}{f = f} AâˆˆVCloğ’¦ ) = Î³
     where
      Î³ : hom-image-alg{A = A}{B = B} f âŠ§ p â‰ˆ q
      Î³ = {!!}

   vclo-id2 : âˆ€ {p q} â†’ (VClo ğ’¦ âŠ§' p â‰‹ q) â†’ (ğ’¦ âŠ§ p â‰‹ q)
   vclo-id2 p Aâˆˆğ’¦ = p (vbase Aâˆˆğ’¦)

