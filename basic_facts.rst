.. include:: _static/math_macros.rst

.. role:: cat
.. role:: code

.. _basic-facts:

===========
Basic Facts
===========

Here is a collection of basic facts that are useful in universal algebra.  Some of them involve homomorphisms, or terms, or clones.  

Throughout this section,

+ :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©, \ ğ”¹ = âŸ¨B, F^ğ”¹âŸ©, \ â„‚ = âŸ¨C, F^â„‚âŸ©\ ` are algebras of the same signature :math:`Ïƒ = (F, Ï)`, and

+ :math:`g, h : \hom(ğ”¸, ğ”¹)` are homomorphism from ğ”¸ to ğ”¹;

.. index:: ! equalizer

The **equalizer** of :math:`g` and :math:`h` is the set

.. math:: ğ–¤(g,h) = \{a: A âˆ£ g\, a = h\, a\}.

Here is a small collection of basic observations that we will need later. When we refer back to these, we will call them :numref:`Obs %s <obs-one>`, etc.

.. _obs-one:

.. proof:observation::

   :math:`ğ–¤(g,h)` is a subuniverse of ğ”¸.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.

      Fix arbitrary :math:`f âˆˆ F` and :math:`a : Ïf â†’ ğ–¤(g,h)`.

      We show that :math:`g (f^ğ”¸ \, a) = h (f^ğ”¸ \, a)`, as this will show that :math:`ğ–¤(g, h)` is closed under the operation :math:`f^ğ”¸` of :math:`ğ”¸`.

      For all :math:`i<Ï f` we have :math:`a \, i âˆˆ ğ–¤(g,h)`, so :math:`g\, a \, i= h\, a\, i`.  Therefore (by function extensionality) :math:`g âˆ˜ a = h âˆ˜ a` and so, by definition of homomorphism,

      .. math:: g  (f^ğ”¸\,a) = f^ğ”¹ (g âˆ˜ a) = f^ğ”¹ (h âˆ˜ a) = h (f^ğ”¸\, a).

      â˜

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-one>` is described in :numref:`equalizer-as-subuniverse`,  and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.

.. _obs-two:

.. proof:observation::

   If the set :math:`X âŠ† A` generates ğ”¸ and :math:`g|_X = h|_X`, then :math:`g = h`.

   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Suppose the subset :math:`X âŠ† A` generates :math:`âŸ¨A, F^ğ”¸âŸ©` and suppose :math:`g|_X = h|_X`.
 
      Fix an arbitrary :math:`a: A`. We show :math:`g\, a = h\, a`.
 
      Since :math:`X` generates ğ”¸, there exists a term :math:`t` and a tuple :math:`x: Ït â†’ X` of generators such that :math:`a = t^ğ”¸\, x`.
 
      Therefore, since :math:`g|_X = h|_X`, we have
    
      .. math:: g âˆ˜ x = (g\, x_0, \dots, g\, x_{Ï t}) = (h\, x_0, \dots, h\, x_{Ï t}) = h âˆ˜ x,

      so

      .. math:: g\, a = g(t^ğ”¸ \, x) = t^ğ”¹ (g âˆ˜ x) = t^ğ”¹ (h âˆ˜ x) = h(t^ğ”¸ \,x) = h\, a.

      â˜

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-two>` is described in :numref:`homomorphisms-that-agree-on-a-generating-set`,  and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.

.. _obs-three:

.. proof:observation::

   If :math:`A, B` are finite and :math:`X` generates ğ”¸, then :math:`|\hom(ğ”¸, ğ”¹)| â‰¤ |B|^{|X|}`.

   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      By :ref:`Obs 2 <obs-two>`, a homomorphism is uniquely determined by its restriction to a generating set.

      If :math:`X` generates ğ”¸, then since there are exactly :math:`|B|^{|X|}` functions from :math:`X` to :math:`B` we have :math:`|\hom(ğ”¸, ğ”¹)| â‰¤ |B|^{|X|}`. â˜
    
.. _obs-four:

.. proof:observation::

   If :math:`g âˆˆ \epi (ğ”¸, ğ”¹)`, :math:`h âˆˆ \hom (ğ”¸, â„‚)`, and :math:`\ker g âŠ† \ker h`, then

   .. math:: âˆƒ k âˆˆ \hom(ğ”¹, â„‚), \ h = k âˆ˜ g.
    
   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      We define :math:`k âˆˆ \hom(ğ”¹, â„‚)` as follows:

      Fix :math:`b âˆˆ B`.

      Since :math:`g` is surjective, the set :math:`g^{-1}\{b\} âŠ† A` is nonempty, and since :math:`\ker g âŠ† \ker h`, it is clear that every element of :math:`g^{-1}\{b\}` is mapped by :math:`h` to a single element of :math:`C`.

      Label this element :math:`c_b`. That is, :math:`h(a) = c_b`, for all :math:`a âˆˆ g^{-1}\{b\}`.
   
      For each such :math:`b`, and its associated :math:`c_b`, define :math:`k(b) = c_b`.
   
      The observant reader may have noticed a slight-of-hand in the foregoing "construction" of the function :math:`k`. While it's true that for each :math:`b âˆˆ B` there exists a :math:`c_b` such that :math:`h(a) = c_b` for all :math:`a âˆˆ g^{-1}\{b\}`, it's also true that we have no means of producing such :math:`c_b` constructively.
      
      One could argue that each :math:`c_b` is easily computed as :math:`c_b = h(a)` for some (every) :math:`a âˆˆ g^{-1}\{b\}`. But this requires producing a particular :math:`a âˆˆ g^{-1}\{b\}` to use as "input" to the function :math:`h`. How do we select such an element from the (nonempty) set :math:`g^{-1}\{b\}`?
      
      We must appeal to the Axiom of :term:`Choice` at this juncture and concede that the function :math:`k` will not be constructively defined. (We have more to say about this in :numref:`Sec %s <basic-facts-in-lean>` when we implement :numref:`Obs %s <obs-four>` in Lean.)  Nonetheless, we forge ahead (nonconstructively) and define :math:`k` as described above, using the Axiom of :term:`Choice` to compute a :math:`c_b` for each :math:`b âˆˆ B`.
   
      It is then easy to see that :math:`k âˆ˜ g = h`.  Indeed, for each :math:`a âˆˆ A`, we have :math:`a âˆˆ g^{-1}\{g(a)\}`, so :math:`k(g(a)) = h(a)` by definition.

      Finally, to prove that :math:`k` is a homomorphism, fix an operation symbol :math:`f âˆˆ F` and a tuple :math:`b: Ï f â†’ B`; we will show that
      
      .. math:: f^â„‚ (k âˆ˜ b) = k (f^ğ”¹(b)).
         :label: hom1

      Let :math:`a: Ï f â†’ A` be such that :math:`g âˆ˜ a = b`.  Then the left hand side of :eq:`hom1` is :math:`f^â„‚ (k âˆ˜ g âˆ˜ a) = f^â„‚ (h âˆ˜ a)`, which is equal to :math:`h (f^ğ”¸ (a))` since :math:`h` is a homomorphism.
   
      Therefore,
   
      .. math:: 
      
         f^â„‚ (k âˆ˜ b) &= f^â„‚ (k âˆ˜ g âˆ˜ a) = f^â„‚ (h âˆ˜ a)\\ 
                 & = h (f^ğ”¸ (a)) = (k âˆ˜ g)(f^ğ”¸ (a))\\
                 & = k (f^ğ”¹ (g âˆ˜ a)) = k (f^ğ”¹ (b)),

      as desired, where the penultimate equality holds by virtue of the fact that :math:`g` is a homomorphism. â˜

**Formalization**. Our formal implementation (in `Lean`_) of :numref:`Obs %s <obs-four>` is described in :numref:`factoring-homomorphisms`, and is included in the `birkhoff.lean`_ file of the `lean-ualib`_ library.


Formalization
-------------

Our formal implementation (in `Lean`_) of these objects is described in :numref:`Sections %s <basic-facts-in-lean>`, :numref:`%s <terms-in-lean>`, and :numref:`%s <clones-in-lean>`.


.. include:: hyperlink_references.rst
