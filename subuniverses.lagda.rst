.. FILE: subuniverses.agda
.. AUTHOR: William DeMeo and Siva Somayyajula
.. DATE: 20 Feb 2020
.. UPDATE: 17 Jun 2020

.. _types for subalgebras:

=====================
Types for Subalgebras
=====================

Preliminaries
------------------

We define subuniverses and subalgebras and prove some basic facts about them in a module called ``subuniverses`` which resides in the ``subuniverses.lagda.rst`` file of the ``agda-ualib`` library.

The file starts, as usual, with a list of imports.

::

   {-# OPTIONS --without-K --exact-split --safe #-}

   open import prelude
   open import basic using (Signature; Algebra; Op)
   open import relations using (transitive)
   open import homomorphisms using (HOM; Hom; hom; is-homomorphism)

   open import terms
    using (Term; _Ì‡_; _Ì‚_; generator; node; comm-hom-term)

   open import Relation.Unary using (â‹‚)


.. _subuniverses in agda:

Subuniverses in Agda
------------------------

We begin the ``subuniverses`` module with a straightforward definition of the collection of subuniverses of an algebra A.  Since a subuniverse is a subset of the domain of A, it is defined as a predicate on âˆ£ A âˆ£.  Thus, the collection of subuniverses is a predicate on predicates on âˆ£ A âˆ£.

::

   module subuniverses {S : Signature ğ“ ğ“¥} where

   Subuniverses : (A : Algebra ğ“¤ S)
    â†’             Pred (Pred âˆ£ A âˆ£ ğ“£) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âŠ” ğ“£)

   Subuniverses (A , FA) B =
    (f : âˆ£ S âˆ£)(a : âˆ¥ S âˆ¥ f â†’ A) â†’ Im a âŠ† B â†’ FA f a âˆˆ B

Next we define a data type that represents the property of being a subuniverse. Note that, in order to keep ``A`` at same universe level as ``Î£ B , F``, we force ``B`` to live in the same universe.  We need to do this so that both ``A`` and ``Î£ B , F`` can be classified by the same predicate ``SClo``.

::

   data _is-supalgebra-of_
    (A : Algebra ğ“¤ S) : Pred (Algebra ğ“¤ S) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº) where
     mem : (B : Pred âˆ£ A âˆ£ ğ“¤) (F : (f : âˆ£ S âˆ£)
      â†’    Op (âˆ¥ S âˆ¥ f) (Î£ B)) â†’ ((f : âˆ£ S âˆ£)(a : âˆ¥ S âˆ¥ f â†’ Î£ B)
      â†’    âˆ£ F f a âˆ£ â‰¡ âˆ¥ A âˆ¥ f (Î» i â†’ âˆ£ a i âˆ£))
      â†’    A is-supalgebra-of (Î£ B , F)

   _is-subalgebra-of_ : Algebra ğ“¤ S â†’ Algebra ğ“¤ S â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº Ì‡
   B is-subalgebra-of A = A is-supalgebra-of B

   module _
    {A : Algebra ğ“¤ S} {B : Pred âˆ£ A âˆ£ ğ“¤}
    {F : (f : âˆ£ S âˆ£) â†’ Op (âˆ¥ S âˆ¥ f) (Î£ B)}
    (BâˆˆSubA : B âˆˆ Subuniverses A) where

    SubunivAlg : Algebra ğ“¤ S
    SubunivAlg =
     Î£ B , Î» f x â†’ âˆ¥ A âˆ¥ f (âˆ£_âˆ£ âˆ˜ x) , BâˆˆSubA f (âˆ£_âˆ£ âˆ˜ x)(âˆ¥_âˆ¥ âˆ˜ x)

    subuniv-to-subalg : SubunivAlg is-subalgebra-of A
    subuniv-to-subalg = mem B âˆ¥ SubunivAlg âˆ¥ Î» f a â†’ (refl _)

.. _obs 7 in agda:

Subuniverse generation in Agda
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next we formalize the important theorem about subuniverse generation that we presented above in :numref:`Obs %s <obs 7>`.  Recall, if :math:`A = âŸ¨ğ´, â€¦âŸ©` is an ğ‘†-algebra, if :math:`âˆ… â‰  ğ´â‚€ âŠ† ğ´`, and if we define by recursion the sets :math:`A_{n+1} = Aâ‚™ âˆª \{ f a : f âˆˆ F, a : Ï f â†’ Aâ‚™ \}`, then the subuniverse of A generated by ğ´â‚€ is :math:`\mathrm{Sg}^A(Aâ‚€) = â‹ƒâ‚™ Aâ‚™`.

::

   record Subuniverse {A : Algebra ğ“¤ S} : ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº Ì‡ where
    constructor mksub
    field
      sset  : Pred âˆ£ A âˆ£ ğ“¤
      isSub : sset âˆˆ Subuniverses A

   module _ {A : Algebra ğ“¤ S} where

    data Sg (X : Pred âˆ£ A âˆ£ ğ“£) : Pred âˆ£ A âˆ£ (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âŠ” ğ“£) where
     var : âˆ€ {v} â†’ v âˆˆ X â†’ v âˆˆ Sg X
     app :  ( f : âˆ£ S âˆ£ ) { a : âˆ¥ S âˆ¥ f â†’ âˆ£ A âˆ£ }
      â†’       Im a âŠ† Sg X
             -----------------
      â†’       âˆ¥ A âˆ¥ f a âˆˆ Sg X

    sgIsSub : (X : Pred âˆ£ A âˆ£ ğ“¤) â†’ Sg X âˆˆ Subuniverses A
    sgIsSub _ f a Î± = app f Î±

    sgIsSmallest : {X : Pred âˆ£ A âˆ£ ğ“¡} {Y : Pred âˆ£ A âˆ£ ğ“¢}
     â†’             Y âˆˆ Subuniverses A
     â†’             X âŠ† Y
                  -----------------
     â†’              Sg X âŠ† Y

    -- By induction on x âˆˆ Sg X, show x âˆˆ Y
    sgIsSmallest _ XâŠ†Y (var vâˆˆX) = XâŠ†Y vâˆˆX

    sgIsSmallest {Y = Y} YIsSub XâŠ†Y (app f {a} imaâŠ†SgX) = appâˆˆY
     where
      -- First, show the args are in Y
      imaâŠ†Y : Im a âŠ† Y
      imaâŠ†Y i = sgIsSmallest YIsSub XâŠ†Y (imaâŠ†SgX i)

      --Since Y is a subuniverse of A, it contains the application
      appâˆˆY : âˆ¥ A âˆ¥ f a âˆˆ Y          --           of f to said args.
      appâˆˆY = YIsSub f a imaâŠ†Y

.. _obs 6 in agda:

Intersections of subalgebras are subalgebras
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall from :numref:`Obs %s <obs 6>` that the intersection â‹‚áµ¢ ğ´áµ¢ of a collection {ğ´áµ¢ âˆ£ ğ´áµ¢ â‰¤ A} of subuniverses of an algebra A is again a subuniverse of A.  We formalize the statement and proof of this easy fact in Agda as follows.

::

   module _
    {A : Algebra ğ“¤ S} {I : ğ“˜ Ì‡}
    {ğ’œ : I â†’ Pred âˆ£ A âˆ£ ğ“£} where

    sub-inter-is-sub : ((i : I) â†’ ğ’œ i âˆˆ Subuniverses A)
     â†’                 â‹‚ I ğ’œ âˆˆ Subuniverses A

    sub-inter-is-sub Ai-is-Sub f a imaâŠ†â‹‚A = Î±
     where
      Î± : âˆ¥ A âˆ¥ f a âˆˆ â‹‚ I ğ’œ
      Î± i = Ai-is-Sub i f a Î» j â†’ imaâŠ†â‹‚A j i


.. _hom images:

Homomorphic images
~~~~~~~~~~~~~~~~~~

Next we show that the image of an (extensional) homomorphism is a subuniverse.  (A version for intensional homs appears below, but the proof is essentially the same.)  We also construct the subalgebra whose universe is a homomorphic image.

::

   module _ {A B : Algebra ğ“¤ S} (h : hom A B)  where

    HomImage : âˆ£ B âˆ£ â†’ ğ“¤ Ì‡
    HomImage = Î» b â†’ Image âˆ£ h âˆ£ âˆ‹ b

    hom-image : ğ“¤ Ì‡
    hom-image = Î£ (Image_âˆ‹_ âˆ£ h âˆ£)

    fres : âˆ£ A âˆ£ â†’ Î£ (Image_âˆ‹_ âˆ£ h âˆ£)
    fres a = âˆ£ h âˆ£ a , im a

    hom-image-alg : Algebra ğ“¤ S
    hom-image-alg = hom-image , ops-interp
     where
      a : {f : âˆ£ S âˆ£ }(x : âˆ¥ S âˆ¥ f â†’ hom-image)(y : âˆ¥ S âˆ¥ f) â†’ âˆ£ A âˆ£
      a x y = Inv âˆ£ h âˆ£  âˆ£ x y âˆ£ âˆ¥ x y âˆ¥

      ops-interp : (f : âˆ£ S âˆ£) â†’ Op (âˆ¥ S âˆ¥ f) hom-image
      ops-interp =
       Î» f x â†’ (âˆ£ h âˆ£  (âˆ¥ A âˆ¥ f (a x)) , im (âˆ¥ A âˆ¥ f (a x)))

We are about ready to formalize the easy fact that a homomorphic image is a subuniverse, but before doing so, let us go through the steps of the proof informally.  Let f be an operation symbol, let :math:`b : Ï f â†’ âˆ£ B âˆ£` be a (Ï f)-tuple of elements of âˆ£ B âˆ£, and assume âˆ€ ğ‘–, b(ğ‘–) âˆˆ Image h.  We must show :math:`f^B b âˆˆ Image h`.  The assumption âˆ€ ğ‘–,  b(ğ‘–) âˆˆ Image h implies that there is a (Ï f)-tuple :math:`a : Ï f â†’ âˆ£ A âˆ£`  such that h âˆ˜ a = b.  Since h is a homomorphism, we have :math:`f^B b  = f^B (h âˆ˜ a) = h (f^A a) âˆˆ` Image h.

We formalize the proof in Agda as follows.

::

    hom-image-is-sub : {funext ğ“¥ ğ“¤} â†’ HomImage âˆˆ Subuniverses B
    hom-image-is-sub {fe} f b bâˆˆImf =
     eq (âˆ¥ B âˆ¥ f (Î» x â†’ b x)) ( âˆ¥ A âˆ¥ f ar) Î³
      where
       ar : âˆ¥ S âˆ¥ f â†’ âˆ£ A âˆ£
       ar = Î» x â†’ Inv âˆ£ h âˆ£ (b x) (bâˆˆImf x)

       Î¶ : (Î» x â†’ âˆ£ h âˆ£ (ar x)) â‰¡ (Î» x â†’ b x)
       Î¶ = fe (Î» x â†’ InvIsInv âˆ£ h âˆ£ (b x) (bâˆˆImf x))

       Î³ : âˆ¥ B âˆ¥ f (Î» x â†’ b x)
            â‰¡ âˆ£ h âˆ£ (âˆ¥ A âˆ¥ f (Î» x â†’ Inv âˆ£ h âˆ£ (b x)(bâˆˆImf x)))
       Î³ = âˆ¥ B âˆ¥ f (Î» x â†’ b x)  â‰¡âŸ¨ ap ( âˆ¥ B âˆ¥ f ) (Î¶ â»Â¹) âŸ©
           (âˆ¥ B âˆ¥ f)(âˆ£ h âˆ£ âˆ˜ ar) â‰¡âŸ¨ ( âˆ¥ h âˆ¥ f ar ) â»Â¹ âŸ©
           âˆ£ h âˆ£ (âˆ¥ A âˆ¥ f ar)    âˆ

.. _obs 12 in agda:

Subuniverse generation with terms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Recall :numref:`Obs %s <obs 12>` presenting subuniverse generation using the images of terms: If ğ‘Œ is a subset of ğ´, then :math:`\mathrm{Sg}^A(Y) = \{t^A a : t âˆˆ T(X), a : X â†’ Y\}`. To formalize this in Agda, we first prove that subuniverses are closed under the action of term operations.

::

   module _
    {X : ğ“ âŠ” ğ“¥ âŠ” ğ“¤ Ì‡}
    {A B : Algebra ğ“¤ S}
    {B : Pred âˆ£ A âˆ£ ğ“¤}
    (Y : ğ“¤ Ì‡) where

    sub-term-closed : B âˆˆ Subuniverses A
     â†’                (t : Term)(b : X â†’ âˆ£ A âˆ£)
     â†’                (âˆ€ i â†’ b i âˆˆ B)
                    ---------------------------
     â†’                ((t Ì‡ A) b) âˆˆ B

    sub-term-closed Bâ‰¤A (generator x) b bâˆˆB = bâˆˆB x

    sub-term-closed Bâ‰¤A (node f t) b bâˆˆB =
      Bâ‰¤A f (Î» z â†’ (t z Ì‡ A) b)
            (Î» x â†’ sub-term-closed Bâ‰¤A (t x) b bâˆˆB)

This proves :math:`\mathrm{Sg}^A(Y) âŠ‡ \{ t^A a : t âˆˆ ğ‘‡(ğ‘‹), a : ğ‘‹ â†’ ğ‘Œ \}`.

Next we prove :math:`\mathrm{Sg}^{A}(Y) âŠ† \{ t^A a : t âˆˆ ğ‘‡(ğ‘‹), a : ğ‘‹ â†’ ğ‘Œ \}` by the following steps:

  #. The image of ğ‘Œ under all terms, which we call `TermImage ğ‘Œ`, is a subuniverse of A; i.e.,
     TermImage ğ‘Œ = :math:`â‹ƒ \{ t^A a : t âˆˆ ğ‘‡(ğ‘‹), a : ğ‘‹ â†’ ğ‘Œ \} â‰¤ A`.
  #. ğ‘Œ âŠ† TermImage ğ‘Œ (obvious)
  #. :math:`\mathrm{Sg}^A(Y)` is the smallest subuniverse containing ğ‘Œ (see `sgIsSmallest`) so :math:`\mathrm{Sg}^A(Y)` âŠ† TermImage ğ‘Œ.

::

    data TermImage (Y : Pred âˆ£ A âˆ£ ğ“¤) : Pred âˆ£ A âˆ£ (ğ“ âŠ” ğ“¥ âŠ” ğ“¤) where
     var : âˆ€ {y : âˆ£ A âˆ£} â†’ y âˆˆ Y â†’ y âˆˆ TermImage Y
     app : (f : âˆ£ S âˆ£) (t : âˆ¥ S âˆ¥ f â†’ âˆ£ A âˆ£)
      â†’    (âˆ€ i  â†’  t i âˆˆ TermImage Y)
          -------------------------------
      â†’    (âˆ¥ A âˆ¥ f t) âˆˆ TermImage Y

    --1. TermImage is a subuniverse
    TermImageIsSub : (Y : Pred âˆ£ A âˆ£ ğ“¤)
     â†’               TermImage Y âˆˆ Subuniverses A

    TermImageIsSub Y = Î» f a x â†’ app f a x

    --2. Y âŠ† TermImageY
    YâŠ†TermImageY : (Y : Pred âˆ£ A âˆ£ ğ“¤)
     â†’             Y âŠ† TermImage Y

    YâŠ†TermImageY Y {a} aâˆˆY = var aâˆˆY

    -- 3. Sg^A(Y) is the smallest subuniverse containing Y
    --    Proof: see `sgIsSmallest`

Finally, we can prove the desired inclusion.

::

    SgYâŠ†TermImageY : (Y : Pred âˆ£ A âˆ£ ğ“¤) â†’ Sg Y âŠ† TermImage Y
    SgYâŠ†TermImageY Y = sgIsSmallest (TermImageIsSub Y)
                                    (YâŠ†TermImageY Y)

**Exercise**. Prove the following by generalizing the relation â‰ƒ to predicates:

.. code-block::

   SgYâ‰ƒTermImageY : (Y : Pred âˆ£ A âˆ£ k) â†’ (TermImage Y) â‰ƒ (Sg Y)
   SgYâ‰ƒTermImageY {x} Y = ?

-----------------------------------------------------------------------------------


Subalgebras in Agda
---------------------

The next submodule is a generalization of MHE's implementation of subgroups. We consider the subalgebras of a given arbitrary "overalgebra" A.

**Ref**. This module generalizes `MHE's ambient module <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#subgroups-sip>`_ . It does for subuniverses what MHE does for subgroups.

::

   module _ {A : Algebra ğ“¤ S} (UV : Univalence) where

    gfe : global-dfunext
    gfe = univalence-gives-global-dfunext UV

    op-closed : (âˆ£ A âˆ£ â†’ ğ“¦ Ì‡) â†’ ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âŠ” ğ“¦ Ì‡
    op-closed B = (f : âˆ£ S âˆ£)(a : âˆ¥ S âˆ¥ f â†’ âˆ£ A âˆ£)
     â†’ ((i : âˆ¥ S âˆ¥ f) â†’ B (a i)) â†’ B (âˆ¥ A âˆ¥ f a)

    subuniverse : ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº Ì‡
    subuniverse = Î£ B ê‰ (ğ“Ÿ âˆ£ A âˆ£) , op-closed ( _âˆˆâ‚€ B)

    being-op-closed-is-subsingleton : (B : ğ“Ÿ âˆ£ A âˆ£)
     â†’           is-subsingleton (op-closed ( _âˆˆâ‚€ B ))
    being-op-closed-is-subsingleton B = Î -is-subsingleton gfe
     (Î» f â†’ Î -is-subsingleton gfe
      (Î» a â†’ Î -is-subsingleton gfe
       (Î» _ â†’ âˆˆ-is-subsingleton B (âˆ¥ A âˆ¥ f a))))

    prâ‚-is-embedding : is-embedding âˆ£_âˆ£
    prâ‚-is-embedding = prâ‚-embedding being-op-closed-is-subsingleton

    --so equality of subalgebras is equality of their underlying
    --subsets in the powerset:
    ap-prâ‚ : (B C : subuniverse) â†’ B â‰¡ C â†’ âˆ£ B âˆ£ â‰¡ âˆ£ C âˆ£
    ap-prâ‚ B C = ap âˆ£_âˆ£

    ap-prâ‚-is-equiv : (B C : subuniverse) â†’ is-equiv (ap-prâ‚ B C)
    ap-prâ‚-is-equiv =
     embedding-gives-ap-is-equiv âˆ£_âˆ£ prâ‚-is-embedding

    subuniverse-is-a-set : is-set subuniverse
    subuniverse-is-a-set B C = equiv-to-subsingleton
                              (ap-prâ‚ B C , ap-prâ‚-is-equiv B C)
                              (powersets-are-sets' UV âˆ£ B âˆ£ âˆ£ C âˆ£)

For a subuniverse ğµ of A, we want to form a subalgebra B = âŸ¨ğµ, â€¦âŸ© of A such that the operations of B are those of A restricted to ğµ.

Here are some useful lemmas extracted from MHE's proof of `subgroup-equality`. The first is called `f` in MHE's proof.

::

    subuniverse-equality-gives-membership-equiv : (B C : subuniverse)
     â†’                                  B â‰¡ C
                         -----------------------------------
     â†’                   ( x : âˆ£ A âˆ£ ) â†’ (x âˆˆâ‚€ âˆ£ B âˆ£) â‡” (x âˆˆâ‚€ âˆ£ C âˆ£)
    subuniverse-equality-gives-membership-equiv B C Bâ‰¡C x =
     transport (Î» - â†’ x âˆˆâ‚€ âˆ£ - âˆ£) Bâ‰¡C ,
      transport (Î» - â†’ x âˆˆâ‚€ âˆ£ - âˆ£ ) ( Bâ‰¡C â»Â¹ )

The next is called `h` in MHE's proof.

::

    membership-equiv-gives-carrier-equality : (B C : subuniverse)
     â†’          ((x : âˆ£ A âˆ£) â†’  x âˆˆâ‚€ âˆ£ B âˆ£  â‡”  x âˆˆâ‚€ âˆ£ C âˆ£)
               -----------------------------------------
     â†’                       âˆ£ B âˆ£ â‰¡ âˆ£ C âˆ£
    membership-equiv-gives-carrier-equality B C Ï† =
     subset-extensionality' UV Î± Î²
      where
       Î± :  âˆ£ B âˆ£ âŠ†â‚€ âˆ£ C âˆ£
       Î± x = lr-implication (Ï† x)

       Î² : âˆ£ C âˆ£ âŠ†â‚€ âˆ£ B âˆ£
       Î² x = rl-implication (Ï† x)

The next is called lemma `g` in MHE's proof.

::

    membership-equiv-gives-subuniverse-equality : (B C : subuniverse)
     â†’            (( x : âˆ£ A âˆ£ ) â†’ x âˆˆâ‚€ âˆ£ B âˆ£ â‡” x âˆˆâ‚€ âˆ£ C âˆ£)
                  ---------------------------------------
     â†’                          B â‰¡ C
    membership-equiv-gives-subuniverse-equality B C =
     inverse (ap-prâ‚ B C)
     (ap-prâ‚-is-equiv B C)
        âˆ˜ (membership-equiv-gives-carrier-equality B C)

    membership-equiv-is-subsingleton : (B C : subuniverse)
     â†’    is-subsingleton (( x : âˆ£ A âˆ£) â†’ x âˆˆâ‚€ âˆ£ B âˆ£ â‡” x âˆˆâ‚€ âˆ£ C âˆ£)
    membership-equiv-is-subsingleton B C =
     Î -is-subsingleton gfe
      (Î» x â†’ Ã—-is-subsingleton
       (Î -is-subsingleton gfe (Î» _ â†’ âˆˆ-is-subsingleton âˆ£ C âˆ£ x ))
         (Î -is-subsingleton gfe (Î» _ â†’ âˆˆ-is-subsingleton âˆ£ B âˆ£ x )))

So, two subuniverses are equal if and only if they have the same elements (cf. `subgroup-equality <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#371022>`_ ):

::

    subuniverse-equality : (B C : subuniverse)
     â†’    (B â‰¡ C)  â‰ƒ  ((x : âˆ£ A âˆ£)  â†’ (x âˆˆâ‚€ âˆ£ B âˆ£) â‡” (x âˆˆâ‚€ âˆ£ C âˆ£))

    subuniverse-equality B C =
     logically-equivalent-subsingletons-are-equivalent _ _
       (subuniverse-is-a-set B C)
        (membership-equiv-is-subsingleton B C)
         (subuniverse-equality-gives-membership-equiv B C ,
           membership-equiv-gives-subuniverse-equality B C)

The converse of `membership-equiv-gives-carrier-equality` is obvious.

::

    carrier-equality-gives-membership-equiv : (B C : subuniverse)
     â†’                            âˆ£ B âˆ£ â‰¡ âˆ£ C âˆ£
                   ----------------------------------------
     â†’              ( ( x : âˆ£ A âˆ£ ) â†’ x âˆˆâ‚€ âˆ£ B âˆ£ â‡” x âˆˆâ‚€ âˆ£ C âˆ£ )
    carrier-equality-gives-membership-equiv B C (refl _) x = id , id

    --so we have...
    carrier-equiv : (B C : subuniverse)
     â†’   ((x : âˆ£ A âˆ£) â†’ x âˆˆâ‚€ âˆ£ B âˆ£ â‡” x âˆˆâ‚€ âˆ£ C âˆ£) â‰ƒ (âˆ£ B âˆ£ â‰¡ âˆ£ C âˆ£)
    carrier-equiv B C =
     logically-equivalent-subsingletons-are-equivalent _ _
      (membership-equiv-is-subsingleton B C)
       (powersets-are-sets' UV âˆ£ B âˆ£ âˆ£ C âˆ£)
        (membership-equiv-gives-carrier-equality B C ,
          carrier-equality-gives-membership-equiv B C)

    -- ...which yields an alternative subuniverse equality lemma.
    subuniverse-equality' : (B C : subuniverse)
     â†’                      (B â‰¡ C) â‰ƒ (âˆ£ B âˆ£ â‰¡ âˆ£ C âˆ£)
    subuniverse-equality' B C =
     (subuniverse-equality B C) â— (carrier-equiv B C)

Following MHE's analogous development for groups and their subgroups (cf. `Subgroup' <https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#372215>`_ ) we now show that the type of subuniverses is equivalent to the following type, as an application of the subtype classifyer.

::

    Subalgebra : ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº Ì‡
    Subalgebra = Î£ B ê‰ (Algebra ğ“¤ S) ,
                    Î£ h ê‰ (âˆ£ B âˆ£ â†’ âˆ£ A âˆ£) ,
                      is-embedding h Ã— is-homomorphism B A h

----------------------------------------------------------------------------------------------

The intensional-hom-image module
---------------------------------

The image of an intensional HOM is a subuniverse. (N.B. the proof still requires function extensionality. Question: Is it necessary?)

::

   -- HOM image is subuniverse
   module intensional-hom-image
    {A B : Algebra ğ“¤ S} (h : HOM A B)  where

    HOMImage : âˆ£ B âˆ£ â†’ ğ“¤ Ì‡
    HOMImage = Î» b â†’ Image âˆ£ h âˆ£ âˆ‹ b

    HOM-image : ğ“¤ Ì‡
    HOM-image = Î£ (Image_âˆ‹_ âˆ£ h âˆ£)

    fres' : âˆ£ A âˆ£ â†’ Î£ (Image_âˆ‹_ âˆ£ h âˆ£)
    fres' a = âˆ£ h âˆ£ a , im a

    HOM-image-alg : Algebra ğ“¤ S
    HOM-image-alg = HOM-image , ops-interp
     where
      a : {f : âˆ£ S âˆ£} (x : âˆ¥ S âˆ¥ f â†’ HOM-image) (y : âˆ¥ S âˆ¥ f)
       â†’  âˆ£ A âˆ£
      a x y = Inv âˆ£ h âˆ£  âˆ£ x y âˆ£ âˆ¥ x y âˆ¥

      ops-interp : ( f : âˆ£ S âˆ£ ) â†’ Op (âˆ¥ S âˆ¥ f) HOM-image
      ops-interp = Î» f x â†’(âˆ£ h âˆ£ (âˆ¥ A âˆ¥ f (a x)) , im (âˆ¥ A âˆ¥ f (a x)))

    HOM-image-is-sub : funext ğ“¥ ğ“¤ â†’ HOMImage âˆˆ Subuniverses B
    HOM-image-is-sub fe f b bâˆˆImh = eq (âˆ¥ B âˆ¥ f b) (âˆ¥ A âˆ¥ f ar) Î³
     where
      ar : âˆ¥ S âˆ¥ f â†’ âˆ£ A âˆ£
      ar = Î» x â†’ Inv âˆ£ h âˆ£ (b x) (bâˆˆImh x)

      Î¶ : (Î» x â†’ âˆ£ h âˆ£ (ar x)) â‰¡ (Î» x â†’ b x)
      Î¶ = fe (Î» x â†’ InvIsInv âˆ£ h âˆ£ (b x) (bâˆˆImh x) )

      Î³ : âˆ¥ B âˆ¥ f (Î» x â†’ b x)
           â‰¡ âˆ£ h âˆ£ (âˆ¥ A âˆ¥ f (Î» x â†’ Inv âˆ£ h âˆ£ (b x) (bâˆˆImh x)))
      Î³ =   âˆ¥ B âˆ¥ f (Î» x â†’ b x)      â‰¡âŸ¨ ap ( âˆ¥ B âˆ¥ f ) Î¶ â»Â¹ âŸ©
            ( âˆ¥ B âˆ¥ f ) ( âˆ£ h âˆ£ âˆ˜ ar ) â‰¡âŸ¨ intensionality Î¾ ar âŸ©
             âˆ£ h âˆ£ ( âˆ¥ A âˆ¥ f ar )      âˆ
       where
        Ï„ : (Î» f ar â†’ (âˆ¥ B âˆ¥ f)(âˆ£ h âˆ£ âˆ˜ ar))
             â‰¡ (Î» f ar â†’ âˆ£ h âˆ£ (âˆ¥ A âˆ¥ f ar ))
        Ï„ = (âˆ¥ h âˆ¥)â»Â¹
        Î¾ : (Î» (ar : âˆ¥ S âˆ¥ f â†’ âˆ£ A âˆ£) â†’ (âˆ¥ B âˆ¥ f)(âˆ£ h âˆ£ âˆ˜ ar))
             â‰¡ (Î» (ar : âˆ¥ S âˆ¥ f â†’ âˆ£ A âˆ£) â†’ âˆ£ h âˆ£ (âˆ¥ A âˆ¥ f ar))
        Î¾ = dep-intensionality Ï„ f

    finv' : {X : ğ“¤ Ì‡ } (b : X â†’ âˆ£ HOM-image-alg âˆ£) (x : X) â†’ âˆ£ A âˆ£
    finv' = Î» b x â†’ Inv âˆ£ h âˆ£ âˆ£ b x âˆ£ âˆ¥ b x âˆ¥



--------------------------------------------------------------------------------------------------

Notes on homomorphic images and their types
--------------------------------------------

The homomorphic image of `f : Hom A B` is the image of `âˆ£ A âˆ£` under `f`, which, in "set-builder" notation, is simply `Im f = {f a : a âˆˆ âˆ£ A âˆ£ }`.

As we have proved, `Im f` is a subuniverse of `B`.

However, there is another means of representing the collection "H A" of all homomorphic images of A without ever referring to codomain algebras (like B above).

Here's how: by the first isomorphism theorem, for each `f : Hom A B`, there exists a congruence `Î¸` of `A` (which is the kernel of `f`) that satisfies `A / Î¸ â‰… Im f`.

Therefore, we have a handle on the collection `H A` of all homomorphic images of `A` if we simply consider the collection `Con A` of all congruence relations of `A`.  Indeed, by the above remark, we have

  `H A = { A / Î¸ : Î¸ âˆˆ Con A }`.

So, we could define the following:

.. code-block::

   hom-closed : (ğ“š : Pred (Algebra (ğ“¤ âº) S) l)
    â†’           Pred (Algebra ğ“¤ S) _
    hom-closed ğ“š = Î» A â†’ (ğ“š (A / (âˆ¥ğŸâˆ¥ A)))
      â†’             (âˆƒ Î¸ : Congruence A)
      â†’             (âˆƒ ğ‘ª : Algebra (ğ“¤ âº) S)
      â†’             (ğ“š ğ‘ª) Ã— ((A / Î¸) â‰… ğ‘ª)

To get this to type check, we have an apparent problem, and we need a trick to resolve it. The class ğ“š is a collection of algebras whose universes live at some level. (Above we use `ğ“¤ âº`.)

However, if `A` is an algebra with `âˆ£ A âˆ£ : ğ“¤ Ì‡`, then the quotient structure  (as it is now defined in Con.agda), has type `A / Î¸ : ğ“¤ âº Ì‡`. So, in order for the class `ğ“š` to contain both `A` and all its quotients `A / Î¸` (i.e. all its homomorphic images), we need to somehow define a class of algebras that have different universe levels.

Can we define a data type with such "universe level polymorphism"?

Without that, we use a trick to get around the problem. Instead of assuming that `A` itself belongs to `ğ“š`, we could instead take the "quotient" `A / âˆ¥ğŸâˆ¥` (which is isomorphic to `A`) as belonging to `ğ“š`.

This is a hack and, worse, it won't do for us. We need something inductive because we will also need that if `ğ‘ª â‰… A / Î¸ âˆˆ ğ“š`, then also `ğ‘ª / Ïˆ â‰… (A / Î¸) / Ïˆ âˆˆ ğ“š`.

So, if we want `ğ“š` to be closed under all quotients, we cannot determine in advance the universe levels of the algebras that belong to `ğ“š`.

We are trying to come up with a datatype for classes of algebras that has some sort of inductive notion of the universe levels involved.

It seems we may be testing the limits of Agda's universe level paradigm. Maybe we can invent a new type to solve the problem, or we may have to try to extend Agda's capabilities.

..
   record AlgebraClass (ğ“¤ : Universe) : ğ“¤ Ì‡ where
    algebras : Pred (Algebra ğ“¤ S) ( ğ“¤ âº )
    nextclass : AlgebraClass ( ğ“¤ âº )

   record AlgebraClass : Set _ where
    algebras : (â„“ : Level) -> Pred (Algebra â„“ S) (lsuc â„“)

   module _ {S : Signature ğ“ ğ“¥} where

    hom-closed : Pred (AlgebraClass lzero) _
    hom-closed ğ“š = âˆ€ A -> (algebras ğ“š) A -- (ğ“š (A / (âŸ¦ğŸâŸ§ A)))
     -> âˆ€ (Î¸ : Congruence A) -> (âˆƒ ğ‘ª : Algebra lsuc â„“ S)
          ------------------------------
     ->     (ğ“š ğ‘ª) Ã— ((A / Î¸) â‰… ğ‘ª)


   module _  {S : Signature ğ“ ğ“¥}  where
    open AlgebraClass

    data HomClo {â„“ : Level} (ğ“š : AlgebraClass) : Pred AlgebraClass _ where
     hombase : {A : Algebra â„“ S} â†’ A âˆˆ (algebras ğ“š) â„“  â†’ A âˆˆ HomClo ğ“š
     homstep : {A : Algebra â„“ S} ->  A âˆˆ HomClo ğ“š
       ->     (âˆƒ Î¸ : Congruence A)
       ->     (ğ‘ª : Algebra (lsuc â„“) S)
             ------------------------------
       ->     ğ‘ª âˆˆ (algebras (lsuc â„“) ğ“š) Ã— ((A / Î¸) â‰… ğ‘ª)




------------------

.. include:: hyperlink_references.rst



