.. include:: _static/math_macros.rst

.. _inductively-defined-things:

=====================
Inductive Definitions
=====================

One of the primary motivations for the `lean-ualib`_ project was our observation that, on the one hand, many important constructs in universal algebra can be defined inductively, and on the other hand, type theory in general, and Lean in particular, offers excellent support for defining inductive types and powerful tactics for proving their properties.

These two facts suggest that there is much to be gained from implementing universal algebra in an expressive type system that offers powerful tools for proving theorems about inductively defined types. Examples demonstrating how this vision manifests in our Lean library are presented in :numref:`subalgebras-in-lean`, :numref:`terms-in-lean`, and :numref:`clones-in-lean`.

.. In particular, our Lean_ implementation of the notion of :term:`subuniverse` illustrates one of these underlying themes motivating our work.

To exhibit the efficiency and ease with which we can formalize and work with basic but important mathematical objects in Lean_, we will present some fundamental theorems about subalgebras, terms and clones---first in this chapter using the informal language of universal algebra, and then in the next chapter using the formal language of Lean.

The idea is to demonstrate the power and utility of implementing in a formal language **inductively defined types**, which are essential for expressing and working with infinite objects in a constructive and computable way, and for proving (by induction) properties of these objects.

.. index:: ! subuniverse, ! subalgebra

Subalgebras
-----------

The following is an inductive definition of the subuniverse generated by a set (cf. Theorem 1.14 of :cite:`Bergman:2012`).

.. _thm-1-14:

.. proof:theorem:: Subuniverse generation

   Let :math:`ğ”¸ = âŸ¨A, F^{ğ”¸}âŸ©`  be  an  algebra in the signature :math:`Ïƒ = (F, Ï)` and let :math:`X âŠ† A`.

   Define, by recursion on :math:`n`, the sets :math:`X_n` as follows:

   .. math:: X_0  &=  X \\
          X_{n+1} &=  X_n âˆª \{ f a  âˆ£ f âˆˆ F, \ a âˆˆ X_n^{Ïf}\}.
      :label: subalgebra-inductive

   Then  :math:`\mathrm{Sg}^{ğ”¸}(X) = â‹ƒ X_n`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Let :math:`Y = â‹ƒ_{n < Ï‰} X_n`. Clearly :math:`X_n âŠ† Y âŠ† A`, for every :math:`n < Ï‰`. In particular :math:`X = X_0 âŠ† Y`.

      Let us show that :math:`Y` is a subuniverse of ğ”¸.
   
      Let :math:`f` be a basic :math:`k`-ary operation and :math:`a âˆˆ Y^k`.
    
      From the construction of :math:`Y`, there is an :math:`n < Ï‰` such that :math:`âˆ€ i,\ a,\ i âˆˆ X_n`.
    
      From its definition, :math:`f a âˆˆ X_{n+1} âŠ† Y`.
    
      Thus :math:`Y` is a subuniverse of ğ”¸ containing :math:`X`.
    
      By :eq:`SgDef`, :math:`\mathrm{Sg}^{ğ”¸}(X) âŠ† Y`.
    
      For the opposite inclusion, it is enough to check, by induction on :math:`n`, that :math:`X_n âŠ† \mathrm{Sg}^{ğ”¸}(X)`.
    
      By definition, :math:`X_0 = X âŠ† \mathrm{Sg}^{ğ”¸}(X)`.
      
      Assume :math:`X_n âŠ† \mathrm{Sg}^ğ”¸(X)`.  We show :math:`X_{n+1} âŠ† \mathrm{Sg}^ğ”¸(X)`.
      
      If :math:`b âˆˆ X_{n+1} - X_n`, then :math:`b = f a` for a basic :math:`k`-ary operation :math:`f` and some :math:`a âˆˆ X_n^k`.
      
      But :math:`âˆ€ i, \ a i âˆˆ \mathrm{Sg}^ğ”¸(X)` and since this latter object is a subuniverse, :math:`b âˆˆ \mathrm{Sg}^ğ”¸(X)` as well.
    
      Therefore, :math:`X_{n+1} âŠ† \mathrm{Sg}^ğ”¸(X)`, as desired.

The argument in the proof of :numref:`Theorem %s <thm-1-14>` is of a type that one encounters frequently throughout algebra. It has two parts.

  #. Some set :math:`Y` is shown to be a subuniverse of ğ”¸ that contains :math:`X`.

  #. Every subuniverse containing :math:`X` is shown to contain :math:`Y` as well.

  #. One concludes that :math:`Y = \mathrm{Sg}^ğ”¸ (X)`.

-----------------------------------------------

.. index:: ! Taylor term, ! term

.. _terms:

Terms
-----

Fix a signature :math:`Ïƒ = (F, Ï)`, let :math:`X` be a set of **variables** and assume :math:`X âˆ© F = âˆ…`.

For every :math:`n < Ï‰`, let :math:`F_n = Ï^{-1} \{n\}` be the set of :math:`ğ—‡`-ary operation symbols.

By a **word** on :math:`X âˆª F` we mean a nonempty, finite sequence of members of :math:`X âˆª T`.

We denote the concatenation of sequences by simple juxtaposition. We define, by induction on :math:`n`, the sets :math:`T_n` of words on :math:`X âˆª F` by

.. math::      T_0 &= X âˆª F_0;\\
           T_{n+1} &= T_n âˆª \{ f s âˆ£ f âˆˆ  F, \ s : Ïf â†’ T_n \}. 

Define the collection of **terms in the signature** Ïƒ **over** :math:`X` by :math:`T_Ïƒ(X) = â‹ƒ_{n < Ï‰}T_n`.

The definition of :math:`T_Ïƒ (X)` is recursive, indicating that *the set of terms in a signature can be implemented (e.g., in Lean) using an inductive type*.

We will confirm this in :numref:`inductively-defined-types`, but before doing so we impose an algebraic structure on :math:`T_Ïƒ (X)`, and then state and prove some basic but important facts about this algebra. These will be formalized in the next section, giving us another chance to compare informal language proofs to their formal Lean counterparts and to show off inductively defined types in Lean.

If :math:`w` is a term, let :math:`|w|` be the least :math:`n` such that :math:`w âˆˆ T_n`, called the *height* of :math:`w`. [4]_ The height is a useful index for recursion and induction.

Notice that :math:`T_Ïƒ (X)` is nonempty iff either :math:`X` or :math:`F_0` is nonempty. As long as :math:`T_Ïƒ (X)` is nonempty, we can impose upon it an algebraic structure, as follows:

For every basic operation symbol :math:`f âˆˆ F` let :math:`f^{ğ•‹_Ïƒ (X)}` be the operation on :math:`T_Ïƒ (X)` that maps each tuple :math:`a : Ï f â†’ T_Ïƒ (X)` to the formal term :math:`f a`.

We define :math:`ğ•‹_Ïƒ (X)` to be the algebra with universe :math:`T_Ïƒ (X)` and with basic operations :math:`\{f^{ğ•‹_Ïƒ (X)} | f âˆˆ F\}`. [5]_

.. todo:: complete this section (include material on free algebras)

-----------------------------------------------

.. index:: ! clone
.. index:: ! clone of projections
.. index:: ! clone of polynomial operations
.. index:: ! clone of term operations

.. _clones:

Clones
------

An **operational clone** (or just **clone**) on a nonempty set :math:`A` is a set of operations on :math:`A` that contains the projection operations and is closed under general composition.

Let :math:`ğ–¢ A` denote the collection of all clones on :math:`A`.

The smallest clone on :math:`A` is the **clone of projections**, which we denote and define as follows:

.. math:: \operatorname{Proj} A = â‹ƒ_{i < n < Ï‰}  \{Ï€^n_i : âˆ€ a âˆˆ A^n,\ Ï€^n_i(a) = a(i)\}.

The **clone of term operations** of a Ïƒ-algebra ğ”¸ is the smallest clone on :math:`A` containing the basic operations of ğ”¸; this is
denoted and defined by

.. math:: \operatorname{Clo} ğ”¸ = â‹‚ \{ U âˆˆ ğ–¢ A âˆ£ F^{ğ”¸} âŠ† U\}.

The set of :math:`n`-ary members of :math:`\operatorname{Clo} ğ”¸` is sometimes denoted by :math:`\operatorname{Clo}_n ğ”¸` (despite the fact that the latter is clearly not a clone).

The **clone of polynomial operations** (or **polynomial clone**) of a Ïƒ-algebra ğ”¸ is denoted by :math:`\operatorname{Pol} ğ”¸` and is defined to be the clone generated by the collection consisting of the basic operations of ğ”¸ along with the **constants** on :math:`A`. [2]_

The set of :math:`n`-ary members of :math:`\operatorname{Pol} ğ”¸` is sometimes denoted by :math:`\operatorname{Pol}_n ğ”¸`. 

.. .. [9] Lean's built-in sigma type is defined as follows: :math:`structure sigma {Î± : Type u} (Î² : Î± â†’ Type v) := mk :: (fst : Î±) (snd : Î² fst)`

We now state a theorem that shows how the clone of term operations of a signature can be defined inductively.

.. _thm-4-3:

.. proof:theorem::

   Let :math:`X` be a set and :math:`Ïƒ = (F, Ï)` a signature. Define

   .. math:: F_0 &= X;\\
         F_{n+1} &= F_n âˆª \{ f g âˆ£ f âˆˆ F, g : Ïf â†’ (F_n âˆ© (Ï g â†’ X)) \}, \quad n < Ï‰.

   Then :math:`\mathrm{Clo}^X(F) = â‹ƒ_n F_n`.

Thus *the clone of terms operations can be implemented (e.g., in Lean) as an inductive type*. The following theorem makes this precise (cf. Theorem 4.32 of :cite:`Bergman:2012`). 

.. _thm-4-32:

.. proof:theorem::

   Let ğ”¸ and ğ”¹ be algebras of signature :math:`Ïƒ`.

   #. If :math:`t âˆˆ T (X_Ï‰)` and :math:`g : ğ”¸ â†’ ğ”¹` is a homomorphism, then
      
      .. math:: g\, t^{ğ”¸}(a) = t^{ğ”¹}(g âˆ˜ a), \quad  âˆ€ a : Ï t â†’ A

   #. If :math:`t âˆˆ T (X_Ï‰)`, :math:`Î¸ âˆˆ \operatorname{Con}(ğ”¸)`, :math:`a : Ï t â†’ A` and :math:`b : Ï t â†’ A`, then
   
      .. math:: a \mathrel{Î¸} b \implies t^ğ”¸(a) \mathrel{Î¸} t^ğ”¸(b).

   #. If :math:`Y âŠ† A`, then

      .. math:: \operatorname{Sg}^ğ”¸(Y) = \{ t^ğ”¸ (a) : t âˆˆ T(X_n), a : Ï t â†’ Y, i â‰¤ n < Ï‰\}.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      The first statement is an easy induction on :math:`|t|`.

      The second statement follows from the first by taking :math:`ğ”¹ = ğ”¸/Î¸` and ğ—€ the canonical homomorphism.
  
      For the third statement, again by induction on the height of :math:`t`, every subalgebra must be closed under the action of :math:`t^{ğ”¸}`. 
  
      Thus the right-hand side is contained in the left. On the other hand, the right-hand side is clearly a subalgebra containing the elements of :math:`Y` (take :math:`t = x_1`) from which the reverse inclusion follows.

.. For a nonempty set :math:`A`, we let :math:`ğ–®_A` denote the set of all finitary operations on :math:`A`. That is, :math:`ğ–®_A = â‹ƒ_{nâˆˆ â„•} A^{A^n}` on :math:`A` is a subset of :math:`ğ–®_A` that contains all projection operations and is closed under the (partial) operation of :ref:`general composition <general-composition>`.

.. If :math:`ğ”¸ = âŸ¨ A, F^ğ”¸ âŸ©` denotes the algebra with universe :math:`A` and set of basic operations :math:`F`, then :math:`\operatorname{Clo} (ğ”¸)` denotes the clone generated by :math:`F`, which is also known as the **clone of term operations** of :math:`ğ”¸`.

.. proof:example::

   We will discuss varieties in more detail later, but for now a variety is a collection of algebras of the same signature that is defined by a certain set of identities. [3]_ 
   
   In 1977, Walter Taylor showed in :cite:`Taylor:1977` that a variety :math:`ğ•` satisfies some nontrivial idempotent Malcev condition if and only if it satisfies one of the following form: for some :math:`n`, ğ• has an idempotent :math:`n`-ary term  :math:`t` such that for each :math:`i < n` there is an identity of the form 

   .. math:: t(âˆ—, \cdots, âˆ—, x, âˆ—, \cdots, âˆ—) â‰ˆ t(âˆ—, \cdots, âˆ—, y, âˆ—, \cdots, âˆ—)

   true in ğ• where distinct variables :math:`x` and :math:`y` appear in the :math:`i`-th position on each side of the identity. Such a term :math:`t` now goes by the name **Taylor term**.

-----------------------------------------------

.. _basic-facts:

Basic Facts
-----------

Throughout this section,

+ :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©, \ ğ”¹ = âŸ¨B, F^ğ”¹âŸ©, \ â„‚ = âŸ¨C, F^â„‚âŸ©\ ` are algebras of the same signature :math:`Ïƒ = (F, Ï)`, and

+ :math:`g, h : \hom(ğ”¸, ğ”¹)` are homomorphism from ğ”¸ to ğ”¹;

.. index:: ! equalizer

The **equalizer** of :math:`g` and :math:`h` is the set

.. math:: ğ–¤(g,h) = \{ a : A âˆ£ g(a) = h(a) \}.

Here is a list of basic observations that we will need later. We will reference the first observation in the list as :ref:`Obs 1 <obs-one>`, etc. [6]_

.. _obs-one:

.. proof:observation::

   :math:`ğ–¤(g,h)` is a subuniverse of ğ”¸.

   .. container:: toggle
 
      .. container:: header
 
         *Proof.*

      Fix arbitrary :math:`f âˆˆ F` and :math:`a : Ïf â†’ ğ–¤(g,h)`.

      We show that :math:`g (f^ğ”¸ âˆ˜ a) = h (f^ğ”¸ âˆ˜ a)`, as this shows that :math:`ğ–¤(g, h)` is closed under the operation :math:`f^ğ”¸` of :math:`ğ”¸`.

      But this is trivial since, by definition of homomorphism, we have

      .. math:: (g âˆ˜ f^ğ”¸)(Î¹_i a) = (f^ğ”¹ âˆ˜ F g)(Î¹_i a) = (f^ğ”¹ âˆ˜ F h)(Î¹_i a) = (h âˆ˜ f^ğ”¸)(Î¹_i a).

.. _obs-two:

.. proof:observation::

   If the set :math:`X âŠ† A` generates ğ”¸ and :math:`g|_X = h|_X`, then :math:`g = h`.

   .. container:: toggle
    
      .. container:: header
  
         *Proof*.

      Suppose the subset :math:`X âŠ† A` generates :math:`âŸ¨A, f^ğ”¸âŸ©` and suppose :math:`g|_X = h|_X`.
 
      Fix an arbitrary :math:`a : A`. We show :math:`g(a) = h(a)`.
 
      Since :math:`X` generates ğ”¸, there exists a term :math:`t` and a tuple :math:`x : Ït â†’ X` of generators such that :math:`a = t^ğ”¸ x`.
 
      Therefore, since :math:`F g = F h` on :math:`X`, we have
    
      .. math:: g(a) = g(tá´¬ x) = (tá´® âˆ˜ F g)(x) = (tá´® âˆ˜ F h)(x) = h(tá´¬ x) = h(a).

.. _obs-three:

.. proof:observation::

   If :math:`A, B` are finite and :math:`X` generates ğ”¸, then :math:`|\hom(ğ”¸, ğ”¹)| â‰¤ |B|^{|X|}`.

   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      By :ref:`Obs 2 <obs-two>`, a homomorphism is uniquely determined by its restriction to a generating set.

      If :math:`X` generates ğ”¸, then since there are exactly :math:`|B|^{|X|}` functions from :math:`X` to :math:`B` we have :math:`|\hom(ğ”¸, ğ”¹)| â‰¤ |B|^{|X|}`.
    
.. _obs-four:

.. proof:observation::

   If :math:`g : \epi (ğ”¸, ğ”¹)` and :math:`h : \hom (ğ”¸, â„‚)` satisfy :math:`\ker g âŠ† \ker h`, then

   .. math:: âˆƒ k âˆˆ \hom(ğ”¹, â„‚)\ . \ h = k âˆ˜ g.
    
   .. container:: toggle
    
      .. container:: header
    
         *Proof*.

      We define :math:`k âˆˆ \hom(ğ”¹, â„‚)` constructively, as follows:

      Fix :math:`b : B`.

      Since :math:`g` is surjective, the set :math:`g^{-1}\{b\} âŠ† A` is nonempty, and since :math:`\ker g âŠ† \ker h`, we see that every element of :math:`g^{-1}\{b\}` is mapped by :math:`h` to a single element of :math:`C`.

      Label this element :math:`c_b`. That is, :math:`h(a) = c_b`, for all :math:`a : g^{-1}\{b\}`.
   
      We define :math:`k(b) = c_b`. Since :math:`b` was arbitrary, :math:`k` is defined on all of :math:`B` in this way.
   
      Now it's easy to see that :math:`k g = h` by construction.
   
      Indeed, for each :math:`a âˆˆ A`, we have :math:`a âˆˆ g^{-1}\{g(a)\}`, so :math:`k(g(a)) = h(a)` by definition.
   
      To see that :math:`k` is a homomorphism, let there be :math:`m` operation symbols and let :math:`0â‰¤ i< m` be arbitrary.
   
      Fix :math:`b : \underline{k_i} â†’ B`.
   
      Since :math:`g` is surjective, for each :math:`i : \underline{k_i}`, the subset :math:`g^{-1}\{b(i)\}âŠ† A` is nonempty and is mapped by :math:`h` to a single point of :math:`C` (since :math:`\ker g âŠ† \ker h`.
   
      Label this point :math:`c_i` and define :math:`c : \underline{k_i} â†’ C` by :math:`c(i) = c_i`.
   
      We want to show :math:`(f^C âˆ˜ F k) (b) = (k âˆ˜ f^B)(b).`
   
      The left hand side is :math:`f^C c`, which is equal to :math:`(h âˆ˜ fá´¬)(a)` for some :math:`a : \underline{k_i} â†’ A`, since :math:`h` is a homomorphism.
   
      Therefore,
   
      .. math:: (f^C âˆ˜ F k) (b) = (h âˆ˜ f^A) (a) = (k âˆ˜ g âˆ˜ f^A)(a) = (k âˆ˜ f^B âˆ˜ F g)(a) = (k âˆ˜ f^B)(b).

.. _obs-five:

.. proof:observation::

   Let :math:`Ïƒ = (F, Ï)` be a signature each :math:`f âˆˆ F` an :math:`Ïf`-ary operation symbol.
 
   Define :math:`F_0 := \operatorname{Proj}(A)` and for all :math:`n > 0` in :math:`Ï‰` let
 
   .. math:: F_{n+1} := F_n âˆª \{ f g âˆ£ f âˆˆ F, g : Ïf â†’ (F_n âˆ© (Ïg â†’ A)) \}.
 
   Then :math:`\mathrm{Clo}^{ğ”¸}(F) = â‹ƒ_n F_n`.
 
.. _obs-six:

.. proof:observation::

   Let :math:`f` be a similarity type.
 
   (a) :math:`ğ•‹_Ï (X)` is generated by :math:`X`.
 
   (b) For every algebra :math:`ğ”¸ = âŸ¨A, FâŸ©` of type :math:`Ï` and every function :math:`h : X â†’ A` there is a unique homomorphism :math:`g : ğ•‹_Ï (X) â†’ âŸ¨A, fá´¬âŸ©` such that :math:`g|_X = h`.
 
   .. container:: toggle
    
      .. container:: header
     
         *Proof*.
     
      The definition of :math:`ğ•‹_Ï (X)` exactly parallels the construction in :numref:`Theorem %s <thm-1-14>`. That accounts for the first item.
     
      For b, define :math:`g(t)` by induction on :math:`|t|`.
     
      Suppose :math:`|t| = 0`.  Then :math:`t âˆˆ X âˆª \mathcal F_0`.
     
      If :math:`t âˆˆ X` then define :math:`g(t) = h(t)`. For :math:`t âˆˆ \mathcal F_0`, :math:`g(t) = t^{ğ”¸}`.
     
      Note that since :math:`ğ”¸ = âŸ¨A, fá´¬âŸ©` is an algebra of type :math:`f` and :math:`t` is a nullary operation symbol, :math:`t^{ğ”¸}` is defined.
     
      For the inductive step, let :math:`|t| = n + 1`. Then :math:`t = f(s_1, \dots, s_k)` for some :math:`f âˆˆ \mathcal F_k` and :math:`s_1, \dots, s_k` each of height at most :math:`n`. We define :math:`g(t) = f^{ğ”¸}(g(s_1), \dots, g(s_k))`.
     
      By its very definition, :math:`g` is a homomorphism. Finally, the uniqueness of :math:`g` follows from :numref:`Obs %s <obs-two>`.
 
.. _obs-seven:

.. proof:observation::

   Let :math:`ğ”¸ = âŸ¨A, f^{ğ”¸}âŸ©` and :math:`ğ”¹ = âŸ¨B, f^{ğ”¹}âŸ©` be algebras of type :math:`Ï`.
 
    (a) For every :math:`n`-ary term :math:`t` and homomorphism :math:`g : ğ”¸ â†’ ğ”¹`, :math:`g(t^{ğ”¸}(a_1,\dots, a_n)) = t^{ğ”¹}(g(a_1),\dots, g(a_n))`.

    (b) For every term :math:`t âˆˆ T_Ï(X_Ï‰)` and every :math:`Î¸ âˆˆ \mathrm{Con}âŸ¨A, fá´¬âŸ©`, :math:`ğ”¸ â‰¡_Î¸ ğ”¹` implies :math:`t^{ğ”¸}(ğ”¸) â‰¡_Î¸ t^{ğ”¸}(ğ”¹)`.

    (c) For every subset :math:`Y` of :math:`A`,

        .. math:: \Sg^{ğ”¸}(Y) = \{ t^{ğ”¸}(a_1, \dots, a_n) : t âˆˆ Táµ¨ (X_n), a_i âˆˆ Y, i â‰¤ n < Ï‰\}.

   .. container:: toggle
    
      .. container:: header
    
        *Proof*.
    
      The first statement is an easy induction on :math:`|t|`.
    
      The second statement follows from the first by taking :math:`âŸ¨B, f^{ğ”¹}âŸ© = âŸ¨A, f^{ğ”¸}âŸ©/Î¸` and :math:`g` the canonical homomorphism.
    
      For the third statement, again by induction on the height of :math:`t`, every subalgebra must be closed under the action of :math:`t^{ğ”¸}`.
    
      Thus the right-hand side is contained in the left. On the other hand, the right-hand side is clearly a subalgebra containing the elements of :math:`Y` (take :math:`t = x_1`) from which the reverse inclusion follows.



------------------------

.. rubric:: Footnotes

.. [2]
   By "the constants on :math:`A`" we mean the **constant operations**; i.e., functions :math:`f: A â†’ A` such that :math:`âˆ€ a âˆˆ A, f(a) = c`, for some :math:`c âˆˆ A`.

.. [3]
   We will also have much to say about Malcev conditions, but for now we ask the reader to trust us when we say that such conditions play an important role in many deep results in universal algebra.

.. [4]
   The **height** of a type is simply type's *level* (see Section ???) and the syntax ``Type*`` indicates that we do not wish to commit in advance to a specific height.

.. [5]
   The construction of :math:`ğ•‹_Ï (X)` may seem to be making something out of nothing, but it plays a crucial role in the theory.

.. [6]
   To see the proofs, click the black triangles.

.. _Agda: https://wiki.portal.chalmers.se/agda/pmwiki.php

.. _Coq: http://coq.inria.fr

.. _NuPRL: http://www.nuprl.org/

.. _Lean: https://leanprover.github.io/

.. _Logic and Proof: https://leanprover.github.io/logic_and_proof/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/

.. _mathlib: https://github.com/leanprover-community/mathlib/

.. _Lean Standard Library: https://github.com/leanprover/lean

.. _lattice.lean: https://github.com/leanprover-community/mathlib/blob/master/src/data/set/lattice.lean

.. _basic.lean: https://github.com/leanprover-community/mathlib/blob/master/src/data/set/basic.lean

.. _set.lean: https://github.com/leanprover/lean/blob/master/library/init/data/set.lean

.. _2015 post by Floris van Doorn: https://homotopytypetheory.org/2015/12/02/the-proof-assistant-lean/

