::

  import data.set
  universes u v w ğ•©
  namespace ualib
  definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
  def Ï€ {Î² Î±} (i): op Î² Î± := Î» x, x i
  structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
  section algebra
    parameters (Î±: Type u) (Î³: Type w) (Ïƒ: signature)
    def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î± 
    def algebra := sigma algebra_on
    instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
    instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    def pr (i: Î³): op Î³ Î± := Î» (t: Î³ â†’ Î±), t i
  end algebra
  section clone
    parameter Î±: Type u    -- carrier type
    parameter Î³: Type w    -- arity type
    parameter â„±: Type v    -- operation symbol type
    parameter {Ïƒ: signature}

    variable {Ï„: signature}

    -- general composition
    def comp {Î³': Type w}
    (f: op Î³ Î±) (gs: Î³ â†’ op Î³' Î±): op Î³' Î± :=
    Î» x, f (Î» i, gs i x)

    local infix `â—¾`:50 := comp

    lemma comp_proj_id
    (ar:Î³) (gs: Î³ â†’ op Î³ Î±): comp (Ï€ ar) gs = gs ar := rfl

    structure clone (C: set (op Î³ Î±)) :=
    ( proj_closed: âˆ€ (ar: Î³), (Î» (x: Î³ â†’ Î±), x ar) âˆˆ C )
    ( comp_closed: âˆ€ (f: op Î³ Î±)  (gs: Î³ â†’ op Î³ Î±), 
          f âˆˆ C â†’ (âˆ€ i, gs i âˆˆ C) â†’ (f â—¾ gs) âˆˆ C )

    -- The clone generated by ğ’ª 
    inductive clo {ğ’ª : set (op Î³ Î±)} : set (op Î³ Î±)
    | pr (ar): clo (Ï€ ar)
    | comp {f} {gs: Î³ â†’ op Î³ Î±}:
      f âˆˆ ğ’ª  â†’ (âˆ€ i, clo (gs i)) â†’ clo (f â—¾ gs)
  
    -- BEGIN
    theorem clo_contains_generators
    (ğ’ª : set (op Î³ Î±)) : ğ’ª âŠ† @clo ğ’ª :=
    assume f (h: f âˆˆ ğ’ª), show f âˆˆ clo,
    from clo.comp h clo.pr

    -- (an alternative proof of the last result)
    theorem clo_contains_genserators'
    (ğ’ª : set (op Î³ Î±)): ğ’ª âŠ† @clo ğ’ª :=
    begin
      intros f h,
      apply clo.comp h,
      apply clo.pr
    end
  
    theorem clo_is_clone
    (ğ’ª : set (op Î³ Î±)): clone (@clo ğ’ª):=
    { 
      proj_closed := clo.pr,
      comp_closed :=
      assume (f: op Î³ Î±) (gs: Î³ â†’ op Î³ Î±),
      assume (hf: f âˆˆ clo) (hgs: âˆ€ (i:Î³), (gs i) âˆˆ clo),
      show (f â—¾ gs) âˆˆ clo, from 
      begin
      induction hf with ar' f' gs' hf' ghs' ih,
        { -- show comp (Ï€ ar') gs âˆˆ clo
          apply hgs
        },
        { -- show: comp (comp f' gs') gs âˆˆ clo
          apply clo.comp hf', 
          assumption
        }
      end
    }

    theorem clone_is_minimal
    (ğ’ª : set (op Î³ Î±)) (ops: set (op Î³ Î±)):
    clone ops â†’ ğ’ª âŠ† ops â†’ (@clo ğ’ª) âŠ† ops :=
    assume (hco: clone ops) (hso: ğ’ª âŠ† ops),
    assume f (hf: f âˆˆ @clo ğ’ª), 
    show f âˆˆ ops, from 
      begin
        induction hf with 
        ar' -- Î³ 
        g'  -- op Î³ Î±
        gs' -- Î³ â†’ op Î³ Î±
        hg' -- g' âˆˆ ğ’ª 
        ghs'-- âˆ€ (i: Î³), clo (gs' i)
        ih, -- âˆ€ (i: Î³),(Î»(f: op Î³ Î±)(hf: f âˆˆ clo), f âˆˆ ops)(gs' i)

        { -- base step: show Ï€ ar' âˆˆ Ops
          apply hco.proj_closed 
        },

        { -- induction step: show comp f' gs' âˆˆ Ops
          apply hco.comp_closed, apply hso,
          repeat { assumption } 
        }
    end
    -- END
  end clone
