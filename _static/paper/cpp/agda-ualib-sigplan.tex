%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigplan')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen]{acmart}
%\usepackage{amsmath,amscd,amssymb,amsthm}
%\usepackage{amsfonts}
%\usepackage{latexsym,enumerate,scalefnt,ifthen}
%\usepackage{mathtools}
%\usepackage{stmaryrd}

%% \usepackage[colorlinks=true,urlcolor=black,linkcolor=black,citecolor=black]{hyperref}
%% \usepackage{url}
%\usepackage{scalefnt}
%% \usepackage{tikz}
\usepackage{xspace}
%% \usetikzlibrary{math} %needed tikz library
%% \usepackage{color}
%% \usepackage[margin=4cm]{geometry}
%% \usepackage{scrextend}
\usepackage[newwjd]{agda}

%% \usepackage{fontspec,unicode-math}
%% \setmainfont{TeX Gyre Pagella}
%% \setmathfont{XITS Math}

\usepackage{unixode}
%\newcommand\mathscr[1]{\ensuremath{\mathcal{#1}}}
%% \usepackage{newunicodechar}
%% \newunicodechar{ùë®}{\ensuremath{\mathbf{A}}}
%% \usepackage{pdfcomment}
%% \usepackage{color}
%% \usepackage{todonotes}
%% \usepackage[yyyymmdd,hhmmss]{datetime}
%% \usepackage{background}
%% \backgroundsetup{
%%   position=current page.east,
%%   angle=-90,
%%   nodeanchor=east,
%%   vshift=-1cm,
%%   hshift=8cm,
%%   opacity=1,
%%   scale=1,
%%   contents={\textcolor{gray!80}{WORK IN PROGRESS.  DO NOT DISTRIBUTE. (compiled on \today\ at \currenttime)}}
%% }

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[CPP '21]{CPP 2021}{January, 2021}{online}
\acmBooktitle{}
\acmPrice{}
\acmISBN{XXX-X-XXXX-XXXX-X/XX/XX}

\usepackage[mathcal]{euscript}
%\usepackage{amsfonts}

\newcommand\ab[1]{\AgdaBound{#1}}
\newcommand\af[1]{\AgdaFunction{#1}}
\newcommand{\alg}[1]{\ensuremath{\mathbf{#1}}}  % algebraic structures
\newcommand{\var}[1]{\ensuremath{\mathscr{#1}}}  % algebraic structures

\newcommand{\agda}{\href{https://wiki.portal.chalmers.se/agda/pmwiki.php}{Agda}\xspace}
\newcommand\signatureOV{\AgdaFunction{Signature}\AgdaSpace{}\AgdaBound{ùìû}\AgdaSpace{}\AgdaBound{ùì•}}
\newcommand\algebraUS{\AgdaFunction{Algebra}\AgdaSpace{}\AgdaBound{ùì§}\AgdaSpace{}\AgdaBound{ùëÜ}\xspace}
\newcommand\algebraOVUS{\AgdaFunction{Algebra}\AgdaSpace{}\AgdaBound{ùì§}\AgdaSpace{}\AgdaSymbol{\{}\AgdaBound{ùìû}\AgdaSymbol{\}\{}\AgdaBound{ùì•}\AgdaSymbol{\}}\AgdaSpace{}\AgdaBound{ùëÜ}}

\begin{comment}
\newcommand\preludemodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/prelude.lagda.rst}{prelude module}\xspace}
\newcommand\basicmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/basic.lagda.rst}{basic module}\xspace}
\newcommand\congruencesmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/congruences.lagda.rst}{congruences module}\xspace}
\newcommand\homomorphismsmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/homomorphisms.lagda.rst}{homomorphisms module}\xspace}
\newcommand\termsmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/terms.lagda.rst}{terms module}\xspace}
\newcommand\subuniversesmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/subuniverses.lagda.rst}{subuniverses module}\xspace}
\newcommand\closuremodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/congruences.lagda.rst}{closure module}\xspace}
\newcommand\birkhoffmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/birkhoff.lagda.rst}{birkhoff module}\xspace}
\newcommand{\agdaualib}{\href{https://ualib.org}{agda-ualib}\xspace}
\end{comment}
%% For anonymized version
\newcommand{\agdaualib}{\href{anonymizedLink/agda-ualib.html}{agda-ualib}\xspace}
\newcommand\preludemodule{\href{anonymizedLink/prelude.lagda.rst}{prelude module}\xspace}
\newcommand\basicmodule{\href{anonymizedLink/basic.lagda.rst}{basic module}\xspace}
\newcommand\congruencesmodule{\href{anonymizedLink/congruences.lagda.rst}{congruences module}\xspace}
\newcommand\homomorphismsmodule{\href{anonymizedLink/homomorphisms.lagda.rst}{homomorphisms module}\xspace}
\newcommand\termsmodule{\href{anonymizedLink/terms.lagda.rst}{terms module}\xspace}
\newcommand\subuniversesmodule{\href{anonymizedLink/subuniverses.lagda.rst}{subuniverses module}\xspace}
\newcommand\closuremodule{\href{anonymizedLink/congruences.lagda.rst}{closure module}\xspace}
\newcommand\birkhoffmodule{\href{anonymizedLink/birkhoff.lagda.rst}{birkhoff module}\xspace}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{A Constructive, Machine-checked Proof\break of Birkhoff's Theorem}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{\protect{\href{https://williamdemeo.gitlab.io/}{William DeMeo}}}
\author{}
%% \author{William DeMeo}
%% \email{williamdemeo@gmail.com}
%% \affiliation{% \\
%%   \institution{\href{https://www.mff.cuni.cz/en/ka}{Department of Algebra}\\Charles University} %\\ Katedra Algebry, Univerzita Karlova\\
%%   \streetaddress{Sokolovska 83}
%%   \city{Prague}
%%   \state{Czech Republic} %186 00 Praha 8, 186 00 Praha 8, \v{C}esk\'{a} Republika}
%%   \postcode{186 00} % Prague 8, Czech Republic}
%% }
%% %\author{\href{https://hyeyoungshin.github.io/}{Hyeyoung Shin}}
%% \author{Hyeyoung Shin}
%% \email{hyeyoungshinw@gmail.com}
%% \affiliation{
%%   \institution{\href{https://prl-prg.github.io/}{Faculty of Information Technology}\\Czech Technical University}
%%   \streetaddress{Th√°kurova 9}
%%   \city{Prague} % 6
%%   \state{Czech Republic}
%%   \postcode{160 00} 
%% }

%% %\author{\href{http://www.cs.cmu.edu/~ssomayya/}{Siva Somayyajula}}
%% \author{Siva Somayyajula}
%% \email{ssomayya@andrew.cmu.edu}
%% \affiliation{%
%%   \institution{\href{https://www.cs.cmu.edu/}{Department of Computer Science}\\
%%   Carnegie Mellon University}
%%   \streetaddress{}
%%   \city{Pittsburgh}
%%   \state{PA}
%%   \postcode{}
%% }
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%% \renewcommand{\shortauthors}{DeMeo, Shin and Somayyajula}
%%
%% The abstract is a short summary of the work to be presented in the
%% article.
%\href{https://ualib.org}{Agda Universal Algebra Library}
\begin{abstract}
We introduce the \href{anonymizedLink/agda-ualib.html}{Agda Universal Algebra Library}, a project for the formalization of universal algebra in the Agda functional programming language. The primary aim of the project is to develop a usable library that makes Agda more accessible as a tool for discovering new theorems in general algebra and related fields, and for formally verifying ``known'' results.  The authors have implemented a collection of fundamental definitions and theorems from universal algebra in Agda, exhibiting the power of inductive and dependent types for this purpose.  To demonstrate the effectiveness of the library, we describe a major milestone of the project---a formal proof of Birkhoff's HSP Theorem.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10003796</concept_id>
       <concept_desc>Theory of computation~Constructive mathematics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10002990</concept_id>
       <concept_desc>Theory of computation~Logic and verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10010147.10010148.10010164</concept_id>
       <concept_desc>Computing methodologies~Representation of mathematical objects</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010125.10010130</concept_id>
       <concept_desc>Theory of computation~Type structures</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Constructive mathematics}
\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Logic and verification}
\ccsdesc[300]{Computing methodologies~Representation of mathematical objects}
\ccsdesc[300]{Theory of computation~Type structures}

\keywords{universal algebra, formalization of mathematics, equational logic, type theory}

\maketitle

\section{Introduction}\label{introduction}
To support formalization in type theory of research level mathematics in universal algebra and related fields, we present the Agda Universal Algebra Library (\agdaualib), a software library containing formal statements and proofs of the core definitions and results of universal algebra. 
The \agdaualib is written in \agda~\cite{Norell:2009}, a programming language and proof assistant based on Martin-L\"of Type Theory that not only supports dependent and inductive types, but also provides powerful \emph{proof tactics} for proving things about the objects that inhabit these types.

Though the project was only begun in the summer of 2017, the theory formalized in the library extends beyond prior efforts to formalize universal algebra in type theory (e.g.,~\cite{Gunther:2018},~\cite{Spitters:2011},~\cite{Capretta:1999}). In particular, we announce here for the first time a formal proof of Birkhoff's variety theorem in Martin-L√∂f type theory. We remark that, since all known proofs of Birkhoff's theorem are informal and nonconstructive, ours is a proof of a stronger result.

\subsection{Vision and Goals}\label{vision-and-goals}
The idea for the the Agda Universal Algebra Library originated with the observation that, on the one hand a number of basic and important constructs in universal algebra can be defined recursively, and theorems about them proved inductively, while on the other hand the \emph{types}---in particular, dependent and inductive types---make possible precise formal representations of recursively defined objects as well as constructive proofs of their properties, proofs that are computable and composable. These observations suggest that there is much to gain from implementing universal algebra in a language that supports dependent and inductive types.

\subsubsection{Primary Goals}\label{primary-goals}
The first goal of the project is to express the foundations of universal algebra in (constructive, Martin-L\"of) type theory, and to formally verify these foundations using the Agda programming language. Thus we aim to codify the edifice upon which our mathematical research stands, and demonstrate that advancements in our field can also be expressed in type theory and formally verified in a way that we and other working mathematicians can easily understand and check the results. We hope the library inspires and encourages others to formalize and verify their own mathematics research so that we may more easily understand and verify their results.

Our field is deep and broad, so codifying all of its foundations may seem like a daunting task and a risky investment of time and resources. However, we believe the subject is well served by a new, modern, \emph{constructive} presentation of its foundations.  Finally, the mere act of reinterpreting the foundations in an alternative system offers a fresh perspective, yielding new insights into our mathematics research.

%% Our new presentation expresses the foundations of universal algebra in the language of type theory, and uses the Agda proof assistant to codify and formally verify all aspects of the presentation.

\subsubsection{Secondary Goals}\label{secondary-goals}
We wish to emphasize that our ultimate objective is not merely to translate existing results into a more modern and formal language. Indeed, one important goal is to develop a system that is useful for conducting research in mathematics, and that is how we intend to use our library once we have achieved our immediate objective of implementing
the basic foundational core of universal algebra in Agda.

In our own mathematics research, experience has taught us that a proof assistant equipped with specialized libraries for universal algebra, as well as domain-specific tactics to automate proof idioms of our field, is extremely useful. Thus, a second goal of the agda-ualib project is to demonstrate the utility of such libraries and tactics for proving new theorems.

%% \subsection{Intended audience}\label{intended-audience}
%% This paper describes the Agda Universal Algebra Library (\agdaualib) in enough detail so that working mathematicians (and possibly some normal people, too) might be able to learn enough about Agda and its libraries to put them to use when creating, formalizing, and verifying new mathematics.

%% While there are no strict prerequisites, we expect anyone with an interest in this work will have been motivated by prior exposure to universal algebra, as presented in, say, \cite{Bergman:2012} or \cite{McKenzie:1987}, and to a lesser extent category theory, as presented in \cite{Riehl:2017}.

%% Some prior exposure to type theory and Agda would be helpful, but even without this background one should be able to gain something from reading article, by referring to the appendix and glossary, while simultaneously consulting one or more of the references mentioned in the references to fill in gaps as needed.

%% Finally, readers of this paper will benefit most from actively experimenting with Agda and the agda-ualib.

%% \subsection{Installing the library}\label{installing-the-library}
%% The main repository for the \agdaualib is \url{https://gitlab.com/ualib/ualib.gitlab.io}.

%% There are installation instructions in the main README.md file in that repository, but really all one needs is a working Agda installation and a clone of the \agdaualib repository.
\subsection{Main contribution}
Apart from the library itself, this paper also describes a ``proof of concept'' by way of a formal implementation of a deep result in universal algebra. As the focus of this goal, we have chosen what was among the first major results of the theory of universal algebras---namely, Garrett Birkhoff's celebrated HSP Theorem~\cite{Birkhoff:1935}.

This is noteworthy, not only because it is the first formal proof of Birkhoff's theorem, but also because the proof is \emph{fully constructive}, so the version of the theorem that we state and prove here is actually a \emph{stronger result} than the well-known informal version of the theorem presented in, say,~\cite{Bergman:2012}.

%% Naturally, the proof relies on many defeinitions and results developed in earlier chapters of the book. Nonetheless, Professor Bergman's path to a proof of the HSP theorem is the most straightforward and efficient one we know, and we will follow his presentation quite closely.

%% On the other hand, in order to get as directly as possible to a formal proof of the HSP Theorem, we will extract all the ingredients we need from~\cite{Bergman:2012}, and present them as a list of results at the end of this section, and then later, in Section XX, we will formalize each of these results in Agda.

%% Whenever we quote or paraphrase a result from~\cite{Bergman:2012}, we will include a citation that indicates where the corresponding result is found in the book.

\section{Agda prelude}\label{agda-prelude}
This section describes the \preludemodule of the \agdaualib. This full source code of the \preludemodule is available in the
\href{anonymizedLink/agda-ualib.html}{git repository of the agda-ualib}.
%\href{https://gitlab.com/ualib/ualib.gitlab.io}{git repository of the agda-ualib}.

%% \textbf{Notation}. Here are some acronyms that we use frequently.
%% \begin{itemize}
%% \item MHE = \href{https://www.cs.bham.ac.uk/~mhe/}{Martin H√∂tzel Escardo}
%% \item MLTT = \href{https://ncatlab.org/nlab/show/Martin-L\%C3\%B6f+dependent+type+theory}{Martin-L√∂f Type Theory}
%% \end{itemize}

\subsection{Options and imports}\label{options-and-imports}
All but the most trivial Agda programs begin by setting some options that effect how Agda behaves and importing from existing libraries (e.g., the \href{https://agda.github.io/agda-stdlib/}{Agda Standard Library} or, in our case, MHE's \href{https://github.com/martinescardo/TypeTopology}{Type Topology} library). In particular, logical axioms and deduction rules can be specified according to what one wishes to assume.

For example, here's the start of the first Agda source file in our library, which we call \texttt{prelude.lagda.rst}.
\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\end{code}
This specifies Agda \texttt{OPTIONS} that we will use throughout the library.
\begin{itemize}
\item \texttt{without-K} disables \href{https://ncatlab.org/nlab/show/axiom+K+\%28type+theory\%29}{Streicher's K axiom}; see also the \href{https://agda.readthedocs.io/en/v2.6.1/language/without-k.html}{section on axiom K} in the \href{https://agda.readthedocs.io/en/v2.6.1/language}{Agda Language Reference} manual.
\item \texttt{exact-split} makes Agda accept only those definitions that behave like so-called \emph{judgmental} or \emph{definitional} equalities.
  %% Martin Escardo explains this by saying it ``makes sure that pattern   matching corresponds to Martin-L√∂f eliminators;'' see also the \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html\#pattern-matching-and-equality}{Pattern matching and equality section} of the \href{https://agda.readthedocs.io/en/v2.6.1/tools/}{Agda Tools} documentation.
\item \texttt{safe} ensures that nothing is postulated outright---every non-MLTT axiom has to be an explicit assumption (e.g., an argument to a function or module); see also \href{https://agda.readthedocs.io/en/v2.6.1/tools/command-line-options.html\#cmdoption-safe}{this section} of the \href{https://agda.readthedocs.io/en/v2.6.1/tools/}{Agda Tools} documentation and the \href{https://agda.readthedocs.io/en/v2.6.1/language/safe-agda.html\#safe-agda}{Safe
  Agda section} of the \href{https://agda.readthedocs.io/en/v2.6.1/language}{Agda Language
  Reference}.
\end{itemize}

\subsubsection{Universes}\label{universes}
The first module of the \agdaualib, called \texttt{prelude}, begins with the Agda directive \texttt{module\ prelude\ where}, which is followed immediately by the import of the \texttt{Universes} module from Martin Escardo's \href{https://github.com/martinescardo/TypeTopology}{Type Topology} library.

\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{prelude}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Universes}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\end{code}
Escardo's \texttt{Universes} module provides, among other things, an elegant notation for type universes that is adopted throughout the \agdaualib.\footnote{Martin Escardo has an outstanding set of notes on \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html}{HoTT-UF-in-Agda} called \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/index.html}{Introduction to Univalent Foundations of Mathematics with Agda} . We highly recommend these notes to anyone wanting more details than we provide here about Martin-L√∂f type theory and the Univalent Foundations/HoTT extensions thereof.}

Following Escardo, the \agdaualib refers to universes using capitalized script letters, e.g., \ab ùì§, \ab ùì•, \ab ùì¶, \ab ùì£. In the \texttt{Universes} module, Escardo defines the Ãá operator which maps a universe \ab ùì§ (i.e., a level) to \texttt{Set}\ \ab ùì§, and the latter has type \texttt{Set (lsuc}\ \ab ùì§\texttt{)}.  The level \texttt{lzero} is renamed \ab{ùì§‚ÇÄ}, so \ab{ùì§‚ÇÄ}\ Ãá is an alias for \texttt{Set\ lzero}\ (which, incidentally, corresponds to \texttt{Sort\ 0} in \href{https://leanprover.github.io/}{Lean}). We won't describe the entire \texttt{Universes} module here, as it suffices to highlight the few key notational devices adopted throughout the \agdaualib.  In particular, \ab ùì§ Ãá is simply an alias for \texttt{Set}\ \ab ùì§, and the latter has type \texttt{Set\ (lsuc}\ \ab ùì§\texttt{)}. Also, \texttt{Set\ (lsuc\ lzero)} is denoted by \texttt{Set}\ \ab ùì§‚ÇÄ\ ‚Å∫ which is denoted by \ab ùì§‚ÇÄ\ ‚Å∫\ Ãá.
%% The appendix below contains a dictionary for translating between standard Agda syntax and MHE/\href{https://gitlab.com/ualib/ualib.gitlab.io}{agda-ualib} notation.
%% To justify the introduction of this somewhat nonstandard notation for universe levels, Escardo points out that the Agda library uses \texttt{Level} for universes (so what we write as ùì§ Ãá is written \texttt{Set\ ùì§} in standard Agda), but in univalent mathematics the types in ùì§ Ãá need not be sets, so the standard Agda notation can be misleading. Furthermore, the standard notation places emphasis on levels rather than universes themselves.
Finally, there are many occasions calling for a type that lives in the universe that is the least upper bound of two universe, say, \ab ùì§~ Ãá and \ab ùì•\ Ãá. The universe \ab ùì§~‚äî~\ab ùì•~ Ãá denotes this least upper bound. Here \ab ùì§~‚äî~\ab ùì• is used to denote the universe level corresponding to the least upper bound of the levels \ab ùì§ and \ab ùì•; the symbol \texttt{\_‚äî\_} denotes an Agda primitive designed for this purpose.

\section{Algebras in Agda}
We now describes the \basicmodule of the \agdaualib, which begins the Agda formalization of the basic concepts and theorems of universal algebra. In this module such notions as operation, signature, and algebraic structure are codified in the language of Martin-L\"of type theory.

\subsection{Preliminaries}
Like most Agda programs, this one begins with some Agda options specifying the foundational choices we wish to make, as explained above.  (We don't display the show the \AgdaKeyword{OPTIONS} directive here, since it is identical to the one shown above for the \preludemodule.  In fact, all modules in the \agdaualib being with the same \AgdaKeyword{OPTIONS} directive so we will not mention it again.)

The \basicmodule begins by invoking Agda's module directive, and then importing some dependencies from the \preludemodule.
%% \AgdaGeneralizable{ùì£}\AgdaSymbol{;}\AgdaSpace{}%
%% \AgdaPrimitive{ùì§‚ÇÄ}\AgdaSymbol{;}
%\AgdaGeneralizable{ùìò}\AgdaSymbol{;}\AgdaSpace{}%
%% \AgdaPrimitive{ùì§œâ}\AgdaSymbol{;}\AgdaSpace{}%
%% \AgdaRecord{Œ£œâ}\AgdaSymbol{;}\AgdaSpace{}%
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{basic}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{prelude}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{Universe}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùìû}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùì¶}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ùìß}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}‚∏≤\AgdaUnderscore{}}}\AgdaSymbol{;}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPrimitive{\AgdaUnderscore{}‚Å∫}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}Ãá}}\AgdaSymbol{;}\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}‚äî\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{Œ£}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{-Œ£}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£\AgdaUnderscore{}‚à£}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•\AgdaUnderscore{}‚à•}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ùüò}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ùüö}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}√ó\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Œ†}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}‚â°\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSymbol{;}\AgdaSpace{}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{Pred}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}‚àà\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\end{code}
Notice that the import directive is marked \AgdaKeyword{public}, so items imported here will also be available to any modules that import the \basicmodule.

\subsection{Operation type}
The \agdaualib defines a type of \textbf{operations} as follows.

\begin{code}%
\>[0]\AgdaComment{--The type of operations}\<%
\\
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\<%
\end{code}
The type Op encodes the arity of an operation as an arbitrary type \ab ùêº : \ab ùì• Ãá, yielding a completely general representation of an operation as a function type with domain \ab ùêº ‚Üí \ab ùê¥ (heuristically, the type of ``tuples of length~|~\ab ùêº~|'') and codomain \ab ùê¥. The last two lines of the code block above codify the ùëñ-th~|~\ab ùêº~|-ary projection operation on \ab ùê¥. For example, the usual \emph{projection operations} could be defined as follows.
\begin{code}%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{--Example. the projections}\<%
\\
\>[0]\AgdaFunction{œÄ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{œÄ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\<%
\end{code}

\subsection{Signature type}
The \agdaualib defines the signature of an algebraic structure in Agda as follows:
\begin{code}%
\>[0]\AgdaComment{-- ùìû: level at which operation symbol types live}\<%
\\
\>[0]\AgdaComment{-- ùì•: level at which arity types live}\<%
\\
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}%
\>[27]\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}
The \preludemodule of \agdaualib defines the syntax ‚à£\_‚à£ and ‚à•\_‚à• for the first and second projections, resp.  Consequently, if ùëÜ~:~\signatureOV is a signature, then ‚à£ ùëÜ ‚à£ denotes the set of operation symbols (which is often called ùêπ), and ‚à•~ùëÜ~‚à• denotes the arity function (which is often called œÅ). Thus, if  ùëì~:~‚à£~ùëÜ~‚à£ is an operation symbol in the signature ùëÜ, then ‚à•~ùëÜ~‚à•~ùëì is the arity of ùëì.

\subsection{Algebra type}
We are now ready to describe the type of algebras in the signature ùëÜ, also known as ùëÜ-\textbf{algebras}.  Here is how this type is defined in the \agdaualib.
\begin{code}%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[98I]\AgdaSymbol{(}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)\{}\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[98I]%
\>[10]\AgdaSymbol{(}\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}%
\>[33]\AgdaBound{ùìû}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùìû}\AgdaSymbol{\}\{}\AgdaBound{ùì•}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}\<%
\\
\>[.][@{}l@{}]\<[98I]%
\>[10]
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëì}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\end{code}
Thus an ùëÜ-algebra, with carrier type in \AgdaBound{ùì§}~Ãá, inhabits the type \algebraUS.  (Notice that we may leave off the implicits \AgdaBound{ùìû} and \AgdaBound{ùì•} if they can be inferred from the context.) To be clear,

\begin{quote}
\algebraUS \emph{is the type inhabited by all algebras of signature} \ab{ùëÜ} \emph{and carrier type} \ab ùì§\ Ãá, \emph{and this type of algebras has type} \ab ùìû ‚äî \ab ùì• ‚äî  \ab ùì§\ ‚Å∫\ Ãá.
\end{quote}
%\footnote{Recall, \ab ùìû ‚äî \ab ùì• ‚äî  \ab ùì§\ ‚Å∫ denotes the smallest universe containing \ab ùìû, \ab ùì•, and the successor of \ab ùì§.}
Note that the type \algebraUS doesn't define what an algebra \emph{is}. It defines a type of algebras; certain algebras inhabit this type---namely, the algebras consisting of a universe (say, ùê¥) of type \ab ùì§ Ãá , and a collection (ùëì : ‚à£ ùëÜ ‚à£) ‚Üí Op (‚à• ùëÜ ‚à• ùëì) ùê¥ of operations on ùê¥.

The Algebra type could have been defined using the following alternative syntax:\\
\\
  Algebra ùì§ (F , œÅ) = Œ£ A Íûâ ùì§ Ãá , ((ùëì : F ) ‚Üí Op (œÅ ùëì) A)\\
\\
Here ùëÜ = (F , œÅ) is the signature, F the type of operation symbols, and œÅ the arity function. Although this syntax type checks, and although it may seem more familiar to algebraists, we mention it here merely to demonstrate the flexibility of Agda; throughout the \agdaualib, ùëì~:~‚à£~ùëÜ~‚à£ is used for an operation symbol of the signature ùëÜ, and ‚à•~ùëÜ~‚à•~ùëì for the arity of that symbol, as these tend to be more convenient for programming.

\subsubsection{Example}
A monoid signature has two operation symbols, \AgdaInductiveConstructor{e} and \AgdaInductiveConstructor{¬∑}; the first is nullary and the second binary. Thus, the types are (ùüò ‚Üí A) ‚Üí A and (ùüö ‚Üí A) ‚Üí A), respectively.
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{ùì§‚ÇÄ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\>[1]\AgdaInductiveConstructor{¬∑}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{ùüò}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{¬∑}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{ùüö}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
The types indicate that e is nullary (i.e., takes no arguments, equivalently, takes arguments of type ùüò ‚Üí A), while ¬∑ is binary (as indicated  by argument type ùüö ‚Üí A).

We will have more to say about the type of algebras later.  For now, we continue describing the key definitions and syntax used in the \agdaualib to represent the basic objects of universal algebra.

\subsubsection{Syntactic sugar for operation interpretation}
The \agdaualib defines some syntactic sugar that lets us replace ‚à•~ùë®~‚à•~ùëì with the slightly more natural ùëì ÃÇ ùë®. (The latter is a metaphor for \(f^\mathbf{A}\), which is the universally accepted way to denote an operation symbol ùëì interpreted in the algebra ùë®.)
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaGeneralizable{ùìû}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSymbol{\}}%
\>[30]\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ÃÇ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{‚Üí}%
\>[6]\AgdaSymbol{(}\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{‚Üí}%
\>[6]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëì}%
\>[16]\AgdaSymbol{‚Üí}%
\>[19]\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ÃÇ}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à•}}\AgdaSpace{}%
\AgdaBound{ùëì}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{40}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ÃÇ\AgdaUnderscore{}}}\<%
\end{code}
Thus, ùëì ÃÇ ùë® denotes the interpretation of the basic operation symbol ùëì in the algebra ùë® (although the slightly different notation, ùë° Ãá ùë®, will be used to represent the interpretation of a \emph{term} ùë° in the algebra ùë®).

\subsection{Products of algebras}
The (indexed) product of a collection of algebras is also an algebra if we define such a product as follows:
\begin{code}%
%
\>[1]\AgdaFunction{‚®Ö}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùìò}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}(}\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùìò}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ùëÜ}\<%
\\
%
\>[1]\AgdaFunction{‚®Ö}\AgdaSpace{}%
\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[8]\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}%
\>[31]\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùëì}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ÃÇ}}\AgdaSpace{}%
\AgdaBound{ùíú}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{ùì•}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{-1}\AgdaSpace{}%
\AgdaFunction{‚®Ö}\<%
\end{code}
(In agda2-mode ‚®Ö is typed as \textbackslash Glb.)

\subsection{Arbitrarily many variable symbols}

Finally, since we typically want to assume that we have an arbitrarily large collection X of variable symbols at our disposal (so that, in particular, given an algebra ùë® we can always find a surjective map h‚ÇÄ : X ‚Üí ‚à£ ùë® ‚à£ from X to the universe of ùë®), we define a type for use when making this assumption.

\begin{code}%
%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}‚Ü†\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùìß}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùìß}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
%
\>[1]\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚Ü†}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{h}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaBound{h}\<%
\end{code}



%% \input{prelude.tex}
%% \input{basic.tex}
\section{Congruences in Agda}\label{congruences-in-agda}
This section describes the \congruencesmodule of the \agdaualib.
%% , although we don't discuss parts of that module which duplicate functionality of the \href{https://agda.github.io/agda-stdlib/}{Agda standard library} (\texttt{Binary/Core.agda}).

%% \subsection{Preliminaries}\label{preliminaries}
%% \begin{code} \input{congruences/conprelim.tex} \end{code}

\subsection{Binary relation type}\label{binary-relation-type}
Heterogeneous binary relations.
\begin{code}%
\>[0]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\end{code}

Homogeneous binary relations.
\begin{code}%
\>[0]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚Å∫}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùìù}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ùìù}\<%
\end{code}

\subsubsection{Kernels}\label{kernels}
The kernel of a function can be defined in many ways. For example,
\begin{code} \input{congruences/KER.tex} \end{code}
or as a relation\ldots{}
\begin{code} \input{congruences/KER-rel.tex} \end{code}
or a binary predicate ‚Ä¶
\begin{code}\input{congruences/KER-pred.tex}\end{code}

%% \subsubsection{Implication}\label{implication}
%% We denote and define implication or containment (which could also be
%% written \_‚äÜ\_) as follows.
%% \begin{code}\input{congruences/implication.tex}\end{code}
%% Here is a more general version of implication.
%% \begin{code}\input{congruences/generalImplication.tex}\end{code}

\subsubsection{Properties of binary relations}\label{properties-of-binary-relations}
Reflexivity of a binary relation (say, \texttt{‚âà}) on \texttt{X}, can be defined without an underlying equality as follows.
\begin{code}
\>[0]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaGeneralizable{ùì°}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{‚âà}}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
Similarly, we have the usual notion of symmetric and transitive binary relation (though we won't reproduce their implementations here).
%% \begin{code}\input{congruences/symmtrans.tex}\end{code}

\subsubsection{Classes of a binary relation}
For a binary relation ‚âà on A, the \agdaualib denotes the ‚âà-class containing ùëé by {[} ùëé {]} ‚âà. Indeed,
\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{[\AgdaUnderscore{}]\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[8]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}%
\>[22]\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{ùì°}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaBound{‚âà}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaFunction{,}%
\>[21]\AgdaBound{‚âà}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
The collection of all ‚âà-classes of ùê¥ is represented by ùê¥ // ‚âà, defined by
\begin{code}\input{congruences/relationClasses.tex}\end{code}
The ``trivial'' or ``diagonal'' or ``identity'' relation could be defined in many ways.  Here are two that are particularly easy to employ.
\begin{code}
\>[0]\AgdaFunction{ùüé}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{ùüé}\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Œ£}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaFunction{Íûâ}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ùüé-rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\<%
\\
\>[0]\AgdaFunction{ùüé-rel}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{‚â°}}\AgdaSpace{}%
\AgdaBound{b}\<%
\end{code}
%% or, in various other guises,
%% \begin{code}\input{congruences/trivialRelationPred.tex}\end{code}
The ``universal'' or ``total'' or ``all'' relation is defined similarly.
%% \begin{code}\input{congruences/universalRelation.tex}\end{code}

\subsection{Types for equivalences}\label{types-for-equivalences}
A useful representation of an equivalence relation in Agda is the one defined in \agdaualib as a record.
\begin{code}\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{IsEquivalence}\AgdaSpace{}%
\>[10]\AgdaSymbol{\{}\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\<%
\\
\>[10]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[10]\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{ùì°}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaBound{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{rfl}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaField{sym}%
\>[10]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaField{trans}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\end{code}
An alternative that is sometimes useful is
\begin{code}\>[0]\AgdaFunction{is-equivalence-relation}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaGeneralizable{ùì°}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì°}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{is-equivalence-relation}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaFunction{is-subsingleton-valued}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{√ó}}\AgdaSpace{}%
\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{√ó}}\AgdaSpace{}%
\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{√ó}}\AgdaSpace{}%
\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}‚âà\AgdaUnderscore{}}}\<%
\end{code}

As an example application of the first version, we can prove that the trivial relation, ùüé, defined above is an equivalence relation.
\begin{code}\>[0]\AgdaFunction{ùüé-IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[10]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaSymbol{‚Üí}%
\>[10]\AgdaRecord{IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{ùì§}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSymbol{\}\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaFunction{ùüé-rel}\<%
\\
\>[0]\AgdaFunction{ùüé-IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\>[740I]\AgdaKeyword{record}\<%
\\
\>[.][@{}l@{}]\<[740I]%
\>[25]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{rfl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaInductiveConstructor{ùìá‚ÑØùíªùìÅ}\<%
\\
\>[.][@{}l@{}]\<[740I]%
\>[25]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{sym}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{x‚â°y}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x‚â°y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚Åª¬π}}\<%
\\
\>[.][@{}l@{}]\<[740I]%
\>[25]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{trans}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaBound{x‚â°y}\AgdaSpace{}%
\AgdaBound{y‚â°z}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x‚â°y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚àô}}\AgdaSpace{}%
\AgdaBound{y‚â°z}\<%
\\
\>[.][@{}l@{}]\<[740I]%
\>[25]\AgdaSymbol{\}}\<%
\end{code}

Two more definitions that will be important in some of the proofs appearing in later sections are that of a \textbf{lift} of a binary relation from pairs to pairs of tuples, and that of \textbf{compatibility} of a given function-relation pair. These are defined in the \agdaualib as follows:
\begin{code}\>[0]\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaSymbol{:}
\>[10]\AgdaSymbol{\{}\AgdaBound{Œ≥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaSymbol{‚Üí}%
\>[10]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSpace{}%
\AgdaGeneralizable{ùì¶}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Œ≥}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Œ≥}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaSymbol{‚Üí}%
\>[10]\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{‚àÄ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\end{code}

\begin{code}\>[0]\AgdaFunction{compatible-fun}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[806I]\AgdaSymbol{\{}\AgdaBound{Œ≥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[806I]%
\>[17]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Œ≥}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)(}\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSpace{}%
\AgdaGeneralizable{ùì¶}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaSymbol{‚Üí}%
\>[17]\AgdaGeneralizable{ùì•}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{‚äî}}\AgdaSpace{}%
\AgdaGeneralizable{ùì¶}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ãá}}\<%
\\
\>[0]\AgdaFunction{compatible-fun}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{R}%
\>[20]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaBound{R}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{=[}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]‚áí}}\AgdaSpace{}%
\AgdaBound{R}\<%
\end{code}

\subsection{Types for congruences}\label{types-for-congruences}
Finally, we come to the important definition of congruence. The \agdaualib defines congruence inside a module so that an ambient signature \ab ùëÜ is available.
\begin{code}\input{congruences/TypesForCongruences.tex}\end{code}

For example, one constructs the ``trivial'' (or ``diagonal'' or ``identity'') congruence relation as follows:
\begin{code}\input{congruences/TrivialCongruence.tex}\end{code}
(For the sake of brevity, we omitted the proof of \AgdaFunction{ùüé-compatible}, but see the \congruencesmodule for the full code listing.)

\subsection{Quotient algebras}
An important type for algebraic work is that of a quotient algebra, which the \agdaualib defines as follows:
\begin{code}\input{congruences/quotient.tex}\end{code}

\noindent (In agda2-mode one types \texttt{\textbackslash ---} and then \texttt{C-f} or the right-arrow key until the symbol ‚ï± appears.)

We would like to round out this section with a formalization of the trivial congruence of the free algebra ùîΩ(ùí¶, ùëã), which we call Œ®(ùí¶, ùëª(ùëã)) (see the appendix Section XX). Unfortunately, this will have to wait until we have formalized the concepts of subalgebra and closure on which this congruence depends. Thus, our Agda definition of Œ®(ùí¶, ùëª(ùëã)) appears later, in the \closuremodule described in Section XX.

%% -----------------------------------------------------
%% \input{homomorphisms.tex}
\section{Homomorphisms in Agda}\label{homomorphisms-in-agda}
This section describes the \homomorphismsmodule of the \agdaualib.

\subsection{Types for homomorphisms}\label{types-for-homomorphisms}
%% We begin the \homomorphismsmodule by declaring a fixed signature \texttt{ùëÜ} an importing the
%% required dependencies.
%% \begin{code}\input{homomorphisms/homprelude.tex}\end{code}
The notion of homomorphisms that we use most often is an extensional one, but the \agdaualib also provides an ``intensional'' definition of this notion for special situations in which such a version may be useful. What we mean here by ex-/in-tensional will become clear when we compare the two definitions of compatibility below.

\subsection{Homomorphisms, intensionally}
Here is what we mean when we say that an operation ùëì (interpreted in algebras, say, ùë® and ùë©) is \emph{intensionally compatible} (or \emph{commutes intensionally}) with a function \(g : A ‚Üí B\) .
\begin{code}\input{homomorphisms/commutes.tex}\end{code}
The type of homomorphism that corresponds to this notion of compatibility is defined in the \agdaualib as follows:
\begin{code}\input{homomorphisms/hom.tex}\end{code}

\subsection{Homomorphisms, extensionally}
Here is what we mean when we say that an operation ùëì (interpreted in algebras, say, ùë® and ùë©) is \emph{extensionally compatible} (or \emph{commutes extensionally}) with a function \(g : A ‚Üí B\) .
\begin{code}\input{homomorphisms/commext.tex}\end{code}
The type of homomorphism that corresponds to this notion of compatibility is defined in the \agdaualib as follows:
\begin{code}\input{homomorphisms/homext.tex}\end{code}
An example of such a homomorphism is the identity map.
\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ùíæùíπ}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[6]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ùì§}\AgdaSpace{}%
\AgdaBound{ùëÜ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{hom}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{ùíæùíπ}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(Œª}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaInductiveConstructor{ùìá‚ÑØùíªùìÅ}\<%
\end{code}
\subsubsection{Composing homomorphisms}
To give an example of how one applies the definition of (extensional) homomorphism in proofs, let us show that the composition of such homomorphisms is again a homomorphism.
\begin{code}\input{homomorphisms/homcomp.tex}\end{code}

\subsubsection{Factoring homomorphisms}
As another example, we could prove that if ùëî : hom ùë® ùë©, if ‚Ñé : hom ùë® ùë™, if ‚Ñé is surjective, and if ker ‚Ñé ‚äÜ ker ùëî, then there exists \{œï : hom ùë™ ùë©\} such that ùëî = œï ‚àò ‚Ñé.
%% , that is, such that the following diagram commutes:
%% \begin{verbatim}
%%    ùë®---- ‚Ñé -->>ùë™
%%     \         .
%%      \       .
%%       ùëî     ‚àÉœï
%%        \   .
%%         \ .
%%          V
%%          ùë©
%% \end{verbatim}
The proof of this fact is a bit longer than the previous one, so we will just give the theorem statement here.
However, we note that the \agdaualib proves this result, and the proof is constructive. (See \homomorphismsmodule for the full program listing.)
\begin{code}\input{homomorphisms/homfactor.tex}\end{code}

\subsubsection{Isomorphisms in Agda}\label{isomorphism}
Here is how we represent the notion of isomorphism between two algebras using the (extensional) definition of homomorphism in the \agdaualib.
\begin{code}\input{homomorphisms/iso.tex}\end{code}

%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< COMMENT
\begin{comment}
  \subsection{Homomorphic images}\label{homomorphic-images}
  The following seem to be (for our purposes) the two most useful types for representing homomomrphic images of an algebra.
  \begin{code}\input{homomorphisms/homimage.tex}\end{code}

  Here are some further definitions, derived from the one above, that will come in handy later.
  \begin{code}\input{homomorphisms/homimageextras.tex}\end{code}

  Here ùìõùìö represents a (universe-indexed) collection of classes.
  \begin{code}\input{homomorphisms/hclosed.tex}\end{code}
\end{comment}
%%                                       COMMENT >>>>>>>>>>>>>>>>>>>>>>>>>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Terms in Agda}\label{terms-in-agda}
This section describes the \termsmodule of the \agdaualib which, after the usual assortment of preliminaries, begins by defining
%% \subsection{Types for terms}\label{types-for-terms}
%% We developed the notion of a term in a signature informally in Section XX above. Here we formalize this concept in Agda. We start by declaring the module and importing the required dependencies.
%% \begin{code}\input{terms/termsprelude.tex}\end{code}
%% Next, we
a datatype called \texttt{Term} which, naturally, represents the type of terms. Type \ab ùëã : \ab ùí∞ Ãá is used to represent an arbitrary collection of ``variables.'' Then the term algebra type ùëª(X) is defined.
\begin{code}\input{terms/term.tex}\end{code}
\begin{code}\input{terms/termalg.tex}\end{code}

%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< COMMENT
\begin{comment}

  \subsection{The universal property}\label{the-universal-property}
  We prove
  \begin{enumerate}
  \item every map \texttt{h\ :\ ùëã\ ‚Üí\ ‚à£\ ùë®\ ‚à£} lifts to a homomorphism from ùëª(X) to ùë®, and
  \item the induced homomorphism is unique.
  \end{enumerate}
  First, every map \texttt{X\ ‚Üí\ ‚à£\ ùë®\ ‚à£} lifts to a homomorphism.
  \begin{code}\input{terms/freelift.tex}\end{code}
  Next, the lift to (ùëª X ‚Üí ùë®) is unique.
  \begin{code}\input{terms/uniquelift.tex}\end{code}
  Next we note the easy fact that the lift induced by \texttt{h‚ÇÄ} agrees with \texttt{h‚ÇÄ} on \texttt{X} and that the lift is surjective if the \texttt{h‚ÇÄ} is.
  \begin{code}\input{terms/liftagreement.tex}\end{code}

  \subsection{Interpretation}\label{interpretation}
  Let \texttt{t\ :\ Term} be a term and \texttt{ùë®} an ùëÜ-algebra. We define the ùëõ-ary operation \texttt{t\ Ãá\ ùë®} on \texttt{ùë®} by structural recursion on \texttt{t}.
  \begin{itemize}
  \item if \texttt{t\ =\ x\ ‚àà\ X} (a variable) and
    \texttt{a\ :\ X\ ‚Üí\ ‚à£\ ùë®\ ‚à£} is a tuple of elements of
    \texttt{‚à£\ ùë®\ ‚à£}, then \texttt{(t\ Ãá\ ùë®)\ a\ =\ a\ x}.
  \item if \texttt{t\ =\ f\ args}, where \texttt{f\ ‚àà\ ‚à£\ ùëÜ\ ‚à£} is an op
    symbol and \texttt{args\ :\ ‚à•\ ùëÜ\ ‚à•\ f\ ‚Üí\ Term} is an
    (\texttt{‚à•\ ùëÜ\ ‚à•\ f})-tuple of terms and \texttt{a\ :\ X\ ‚Üí\ ‚à£\ ùë®\ ‚à£}
    is a tuple from \texttt{ùë®}, then
    \texttt{(t\ Ãá\ ùë®)\ a\ =\ ((f\ args)\ Ãá\ ùë®)\ a\ =\ (f\ ÃÇ\ ùë®)\ Œª\{\ i\ ‚Üí\ ((args\ i)\ Ãá\ ùë®)\ a\ \}}
  \end{itemize}
  Here is the Agda implementation of this concept.
  \begin{code}\input{terms/termalg.tex}\end{code}
  Next we show that if \texttt{p\ :\ ‚à£\ ùëª(X)\ ‚à£} is a term, then there exists \texttt{ùìÖ\ :\ ‚à£\ ùëª(X)\ ‚à£} and \texttt{ùíï\ :\ X\ ‚Üí\ ‚à£\ ùëª(X)\ ‚à£} such that \texttt{p\ ‚â°\ (ùìÖ\ Ãá\ ùëª(X))\ ùíï}. We prove this fact in the following module:
  \begin{code}\input{terms/termagreement.tex}\end{code}
  Next we have some definitions that are sometimes useful when dealing
  with the interpretations of terms in a product structure.
  \begin{code}\input{terms/interpprod.tex}\end{code}

  \subsection{Compatibility of terms}\label{compatibility-of-terms}
  In this section we present the formal proof of the fact that homomorphisms commute with terms. More precisely, if ùë® and ùë© are ùëÜ-algebras, h : ùë® ‚Üí ùë© a homomorphism, and t a term in the language of ùëÜ, then for all a : X ‚Üí ‚à£ ùë® ‚à£ we have \(h (t^{ùë®} a) = t^{ùë©} (h ‚àò a)\).

  \subsubsection{Homomorphisms commute with terms}\label{homomorphisms-commute-with-terms}

  \begin{code}\input{terms/commhom.tex}\end{code}


  \subsubsection{Congruences commute with terms}\label{congruences-commute-with-terms}

  Rounding out this section is an formal proof of the fact that terms respect congruences. More precisely, we show that for every term \texttt{t}, every \texttt{Œ∏\ ‚àà\ Con(ùë®)}, and all tuples \texttt{a,\ b\ :\ ùëã\ ‚Üí\ A}, we have


  TODO

\end{comment}
%%                                       COMMENT >>>>>>>>>>>>>>>>>>>>>>>>>>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{Subalgebras in Agda}\label{subalgebras-in-agda}
This section describes the \subuniversesmodule of the \agdaualib where subuniverses and subalgebras are defined and some basic facts about them are proved.

%% \subsection{Preliminaries}\label{preliminaries}
%% The \subuniversesmodule starts, as usual, by fixing a signature ùëÜ and satisfying some dependencies.

%% \subsection{Types for subuniverses}\label{types-for-subuniverses}
%% \begin{code}\input{subuniverses/subprelude.tex}\end{code}

The module begins with a straightforward definition of the collection of subuniverses of an algebra ùë®. Since a subuniverse is a subset of the domain of ùê¥, it is defined as a predicate on ‚à£~ùë®~‚à£. Thus, the collection of subuniverses is a predicate on predicates on ‚à£~ùë®~‚à£.
\begin{code}\input{subuniverses/sub.tex}\end{code}

%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< COMMENT
\begin{comment}
Before describing subuniverse generation, we will need to dispense with some more technicalities.
\begin{code}\input{subuniverses/technical.tex}\end{code}
\end{comment}
%%                                       COMMENT >>>>>>>>>>>>>>>>>>>>>>>>>>


\subsection{Subuniverse generation}\label{subuniverse-generation}
Next we demonstrate how to formalize an important theorem about subuniverse generation. Recall, if \(A = ‚ü®ùê¥, ‚Ä¶‚ü©\) is an ùëÜ-algebra, if \(‚àÖ ‚â† ùê¥‚ÇÄ ‚äÜ ùê¥\), and if we define by recursion the sets \(A_{n+1} = A‚Çô ‚à™ \{ f a : f ‚àà F, a : œÅ f ‚Üí A‚Çô \}\), then the subuniverse of A generated by ùê¥‚ÇÄ is \(\mathrm{Sg}^A(A‚ÇÄ) = ‚ãÉ‚Çô A‚Çô\).
\begin{code}\input{subuniverses/sg.tex}\end{code}

%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< COMMENT
\begin{comment}
\subsection{Closure under intersection}\label{closure-under-intersection}
Recall from Obs 6 that the intersection ‚ãÇ·µ¢ ùê¥·µ¢ of a collection \{ùê¥·µ¢ ‚à£ ùê¥·µ¢ ‚â§ ùë®\} of subuniverses of an algebra ùë® is
again a subuniverse of ùë®. We formalize the statement and proof of this easy fact in Agda as follows.
\begin{code}\input{subuniverses/subintersection.tex}\end{code}

\subsubsection{Homomorphic images are subuniverses}\label{homomorphic-images-are-subuniverses}
In this subsection we show that the image of an (extensional)
homomorphism is a subuniverse. (A version for intensional homomorphisms
appears in the intensional-hom-image module, but the proof is
essentially the same.) Before implementing the result formally in Agda,
let us recall the steps of the informal proof.

Let ùëì be an operation symbol, let \(b : œÅ f ‚Üí ‚à£ B ‚à£\) be a (œÅ ùëì)-tuple
of elements of ‚à£ ùë© ‚à£, and assume the image \texttt{Im\ ùëè} of ùëè belongs
to the image \texttt{Image\ ‚Ñé} of ‚Ñé. We must show that
\(f^ùë© b ‚àà Image h\). The assumption \texttt{Im\ ùëè\ ‚äÜ\ Image\ ‚Ñé} implies
that there is a (œÅ ùëì)-tuple \(ùëé : œÅ f ‚Üí ‚à£ ùë® ‚à£\) such that ‚Ñé ‚àò ùëé = ùëè.
Since ‚Ñé is a homomorphism, we have
\(f^ùë© ùëè  = f^ùë© (‚Ñé ‚àò ùëé) = ‚Ñé (f^ùë® ùëé) ‚àà\) Image ‚Ñé.

Finally, recall the definition of \texttt{HomImage} from the \homomorphismsmodule.
%% \begin{Shaded}
%% \begin{Highlighting}[]
%% \NormalTok{HomImage }\OtherTok{:}\NormalTok{ ‚à£ B ‚à£ }\OtherTok{‚Üí}\NormalTok{ ùì§ Ãá}
%% \NormalTok{HomImage }\OtherTok{=} \OtherTok{Œª}\NormalTok{ b }\OtherTok{‚Üí}\NormalTok{ Image ‚à£ h ‚à£ ‚àã b}
%% \end{Highlighting}
%% \end{Shaded}
\begin{verbatim}
  HomImage : ‚à£ B ‚à£ ‚Üí ùì§ Ãá
  HomImage = Œª b ‚Üí Image ‚à£ h ‚à£ ‚àã b
\end{verbatim}
We are now ready to formalize the proof the proof that homomorphic images are subuniverses.
\begin{code}\input{subuniverses/homimagesub.tex}\end{code}
\subsection{Generation with terms}\label{generation-with-terms}
Recall Obs 12 presenting subuniverse generation using the images of terms: If ùëå is a subset of ùê¥, then \(\mathrm{Sg}^ùë®(Y) = \{t^ùë® a : t ‚àà T(X), a : X ‚Üí Y\}\). To formalize this in Agda, we first prove that subuniverses are closed under the action of term operations.
\begin{code}\input{subuniverses/subtermclosed.tex}\end{code}
This proves \(\mathrm{Sg}^ùë®(Y) ‚äá \{ t^ùë® a : t ‚àà ùëá(ùëã), a : ùëã ‚Üí ùëå \}\).

Next we prove \(\mathrm{Sg}^ùë®(Y) ‚äÜ \{ t^ùë® a : t ‚àà ùëá(ùëã), a : ùëã ‚Üí ùëå \}\) by the following steps:
\begin{enumerate}
\item The image of ùëå under all terms, which we call TermImage ùëå, is a subuniverse of ùë®; i.e., TermImage ùëå =
  \(\{ t^ùë® a : t ‚àà ùëá(ùëã), a : ùëã ‚Üí ùëå \} ‚â§ ùë®\).
\item ùëå ‚äÜ TermImage ùëå (obvious)
\item \(\mathrm{Sg}^ùë®(Y)\) is the smallest subuniverse containing ùëå (see sgIsSmallest) so \(\mathrm{Sg}^ùë®(Y)\) ‚äÜ TermImage ùëå.
\end{enumerate}
\noindent (The last item was already proved above; see \texttt{sgIsSmallest}.)
\begin{code}\input{subuniverses/termimagesub.tex}\end{code}
Finally, we can prove the desired inclusion.
\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[1]\AgdaFunction{SgY‚äÜTermImageY}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùë®}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à£}}\AgdaSpace{}%
\AgdaBound{ùì§}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{Sg}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚äÜ}}\AgdaSpace{}%
\AgdaDatatype{TermImage}\AgdaSpace{}%
\AgdaBound{Y}\<%
\\
%
\>[1]\AgdaFunction{SgY‚äÜTermImageY}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sgIsSmallest}%
\>[775I]\AgdaSymbol{(}\AgdaFunction{TermImageIsSub}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[775I]%
\>[33]\AgdaSymbol{(}\AgdaFunction{Y‚äÜTermImageY}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\<%
\end{code}

%% \textbf{Exercise}. Prove the following by generalizing the relation ‚âÉ to predicates:
%% \begin{Shaded}
%% \begin{Highlighting}[]
%% \NormalTok{SgY‚âÉTermImageY }\OtherTok{:} \OtherTok{(}\NormalTok{Y }\OtherTok{:}\NormalTok{ Pred ‚à£ ùë® ‚à£ k}\OtherTok{)} \OtherTok{‚Üí} \OtherTok{(}\NormalTok{TermImage Y}\OtherTok{)}\NormalTok{ ‚âÉ }\OtherTok{(}\NormalTok{Sg Y}\OtherTok{)}
%% \NormalTok{SgY‚âÉTermImageY }\OtherTok{\{}\NormalTok{x}\OtherTok{\}}\NormalTok{ Y }\OtherTok{=}\NormalTok{ ?}
%% \end{Highlighting}
%% \end{Shaded}

\subsection{Types for subalgebras}\label{types-for-subalgebras}
The next submodule is a generalization of MHE's implementation of subgroups. We consider the subalgebras of an single arbitrary(but fixed) algebra ùë® and we present a module that generalizes \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#subgroups-sip}{MHE's ambient module} . It does for subuniverses what MHE does for subgroups.
\begin{code}\input{subuniverses/mheprelude.tex}\end{code}

Note that we introduce a new definition of the \texttt{subuniverse} type here. In cotrast to our earlier definition of \texttt{Subuniverses}, which uses a predicate on \texttt{‚à£\ ùë®\ ‚à£} to represent the underlying set of the subuniverse, here we use the type \texttt{ùìü\ ‚à£\ ùë®\ ‚à£}, the powerset of the universe of \texttt{ùë®}.
\begin{code}\input{subuniverses/mhepart1.tex}\end{code}

For a subuniverse B of ùë®, we want to form a subalgebra ùë© = ‚ü®B, \ldots{}‚ü© of ùë® such that the operations of ùë© are those of ùë® restricted to B. Here are some useful lemmas extracted from MHE's proof of subgroup-equality. The first is called f in MHE's proof.
\begin{code}\input{subuniverses/mhepart2.tex}\end{code}

So, two subuniverses are equal if and only if they have the same elements (cf.~\href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#371022}{MHE's notes on subgroup-equality}):
\begin{code}\input{subuniverses/mhepart3.tex}\end{code}

The converse of membership-equiv-gives-carrier-equality is obvious.
\begin{code}\input{subuniverses/mhepart4.tex}\end{code}

\subsection{The type of Subalgebras in Agda}\label{the-type-of-subalgebras-in-agda}
Finally, we define, once and for all, the type of subalgebras of an algebra (resp., subalgebras of algebras in a class of algebras) that we will use in the sequel.
\begin{code}\input{subuniverses/newsub.tex}\end{code}
\end{comment}
%%                                       COMMENT >>>>>>>>>>>>>>>>>>>>>>>>>>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Equational Logic in Agda}\label{equational-logic-in-agda}
This section describes the \closuremodule of the \agdaualib.

\subsection{Preliminaries}\label{preliminaries}
As usual, the development begins by satisfying dependencies, although this time we postpone some imports until the start of the \closuremodule so that these later imports can share the same signature with the module.

%\\[\AgdaEmptyExtraSkip]%
\begin{code}
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{basic}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{prelude}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{global-dfunext}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{dfunext}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{im}\AgdaSymbol{)}\<%
\end{code}

\subsection{Closure operators}\label{closure-operators}
Fix a signature ùëÜ. Let ùí¶ be a class of ùëÜ-algebras. Define
\begin{itemize}
\item H(ùí¶) = homomorphic images of members of ùí¶;
\item S(ùí¶) = algebras isomorphic to a subalgebra of a member of ùí¶;
\item P(ùí¶) = algebras isomorphic to a direct product of members of ùí¶.
\end{itemize}
As a straight-forward verification confirms, H, S, and P are closure operators. A class ùí¶ of ùëÜ-algebras is said to be \emph{closed under the formation of homomorphic images} if H(ùí¶) ‚äÜ ùí¶. Similarly, ùí¶ is \emph{closed under the formation of subalgebras} (resp., \emph{products}) provided S(ùí¶) ‚äÜ ùí¶ (resp., P(ùí¶) ‚äÜ ùí¶).

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class H(ùí¶) (resp., S(ùí¶); resp., P(ùí¶)) is closed under isomorphism.

The operators H, S, and P can be composed with one another repeatedly, forming yet more closure operators. If C‚ÇÅ and C‚ÇÇ are closure operators on classes of structures, let us say that C‚ÇÅ ‚â§ C‚ÇÇ if for every class ùí¶ we have C‚ÇÅ(ùí¶) ‚äÜ C‚ÇÇ(ùí¶).

\subsection{Equational classes}\label{equational-classes}
A class ùí¶ of ùëÜ-algebras is called a \textbf{variety} if it is closed under each of the closure operators H, S, and P introduced above; the corresponding closure operator is often denoted ùïç. Thus, if ùí¶ is a class of similar algebras, then the \textbf{variety generated by} ùí¶ is denoted by ùïç(ùí¶) and defined to be the smallest class that contains ùí¶ and is closed under H, S, and P.

We would like to know how to construct ùïç(ùí¶) directly from ùí¶, but it's not immediately obvious how many times we would have to apply the operators H, S, P before the result stabilizes to form a variety---the \textbf{variety generated by} ùí¶. Fortunately, Garrett Birkhoff proved that if we apply the operators in the correct order, then it suffices to apply each one only once.

\subsection{Types for identities}\label{types-for-identities}
In his treatment of Birhoff's HSP theorem, Cliff Bergman (at the start of Section 4.4 of his universal algebra textbook Bergman:2012) proclaims, ``Now, finally, we can formalize the idea we have been using since the first page of this text.'' He then proceeds to define \textbf{identities of terms} as follows (paraphrasing for notational consistency):

Let ùëÜ be a signature. An \textbf{identity} or \textbf{equation} in ùëÜ is an ordered pair of terms, written ùëù ‚âà ùëû, from the term algebra ùëª(X). If A is an ùëÜ-algebra we say that A \textbf{satisfies} ùëù ‚âà ùëû if ùëù~Ãá~A~‚â°~ùëû~Ãá~A. In this situation, we write A ‚äß ùëù ‚âà ùëû.
If ùí¶ is a class of ùëÜ-algebras, we write ùí¶ ‚äß ùëù ‚âã ùëû if, for every A ‚àà ùí¶, A ‚äß ùëù ‚âà ùëû. Finally, if ùìî is a set of equations, we write ùí¶ ‚äß ùìî if every member of ùí¶ satisfies every member of ùìî.

We formalize these notions in Agda in the \closuremodule, which begins with the usual assortment of preliminaries that we won't describe here.  Thereafter, the module begins in earnest with
%% as follows. (Note the imports that were postponed until after the start of the closure module so that the imports share the same signature ùëÜ with the \closuremodule).
%% \begin{code}\input{closure/clo1.tex}\end{code}
%% Our first definition in the \closuremodule is 
notation that represents the satisfaction of equations. The standard notation is \texttt{ùë®\ ‚äß\ p\ ‚âà\ q}, which means that the identity \texttt{p\ ‚âà\ q} is satisfied in ùë®. In otherwords, for all assignments \texttt{a\ :\ X\ ‚Üí\ ‚à£\ ùë®\ ‚à£} of values to variables, we have \texttt{(p\ Ãá\ ùë®)\ a\ ‚â°\ (q\ Ãá\ ùë®)\ a}.

If ùí¶ is a class of structures, it is standard to write \texttt{ùí¶\ ‚äß\ p\ ‚âà\ q} just in case all structures in the class ùí¶ model the identity p ‚âà q. However, because a class of structures has a different type than a single structure, we will need different notation, so we have settled on writing \texttt{ùí¶\ ‚äß\ p\ ‚âã\ q} to denote this concept.

We will also formalize the notions of closure under the taking of products, subalgebras, and homomorphic images, and later prove that each of these closures preserves identities.
\begin{code}\input{closure/clomod.tex}\end{code}

%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< COMMENT
\begin{comment}
\subsection{Compatibility of identities}\label{compatibility-of-identities}
Identities are compatible with the formation of subalgebras, homomorphic images and products. More precisely, for every class ùí¶ of structures, each of the classes S(ùí¶), H(ùí¶), P(ùí¶), ùïç(ùí¶) satisfies the same set of identities as does ùí¶. We prove that identities satisfied by all factors of a product are also satisfied by the product.
\begin{code}\input{closure/prodcomp.tex}\end{code}

\subsubsection{Closure under subalgebras}\label{closure-under-subalgebras}
Above we define a datatype SClo that represents a class of algebraic structures that is closed under the taking of subalgebras.

Let S(ùí¶) denote the class of algebras isomorphic to a subalgebra of a member of ùí¶. With our new formal definition of Subalgebra, we will show that every term equation, \texttt{p\ ‚âà\ q}, that is satisfied by all \texttt{ùë®\ ‚àà\ ùí¶} is also satisfied by all \texttt{B\ ‚àà\ S(ùí¶)}. In other words, the collection of identities modeled by a given class of algebras is also modeled by all of the subalgebras of that class.
\begin{code}\input{closure/subcomp.tex}\end{code}

\subsubsection{Closure under hom images}\label{closure-under-hom-images}
Recall (Obs 14) that an identity is satisfied by all algebras in a class if and only if that identity is compatible with all homomorphisms from the term algebra ùëª(X) into algebras of the class. More precisely, if ùìö is a class of ùëÜ-algebras and ùëù, ùëû terms in the language of ùëÜ, then,
\[ùí¶ ‚äß p ‚âà q \; ‚áî \; ‚àÄ ùë® ‚àà ùí¶, ‚àÄ h ‚àà \mathrm{Hom}(ùëª(X), ùë®), h ‚àò p^{ùëª(X)} = h ‚àò q^{ùëª(X)}.\]
We now formalize this result in Agda. Similarly, we define a datatype that represents classes of algebras that include all homomorphic images of algebras in the class, and we prove that identities satisfied by all algberas in a class are also satsified by all homomorphic images of algebras in the class.
\begin{code}\input{closure/homcomp.tex}\end{code}

Finally, we prove a useful result about the compatibility of identities with interpretation of terms.
\begin{code}\input{closure/homidcomp.tex}\end{code}

\subsection{Equational theories and classes}\label{equational-theories-and-classes}
Here we define the notation \texttt{Th} for the identities satisfied by all structures in a given class, and \texttt{Mod} for all structures that satisfy a given collection of identities.

%% \begin{verbatim}
%% Th : Pred (Algebra ùì§ ùëÜ)(ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ ‚Å∫ ) ‚Üí   Pred (Term{X = X} √ó Term) (ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ ‚Å∫)
%% Th ùí¶ = Œª (p , q) ‚Üí ùí¶ ‚äß p ‚âã q
%% Mod : Pred (Term{X = X} √ó Term) (ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ ‚Å∫) ‚Üí    Pred (Algebra ùì§ ùëÜ)(ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ ‚Å∫ )
%% Mod ‚Ñ∞ = Œª A ‚Üí ‚àÄ p q ‚Üí (p , q) ‚àà ‚Ñ∞ ‚Üí A ‚äß p ‚âà q
%% \end{verbatim}

\subsection{The free algebra in Agda}\label{the-free-algebra-in-agda}
Recall, we proved above that term algebra ùëª(ùëã) is the absolutely free algebra in the class ùìö(ùëÜ) of all ùëÜ-structures. In this section, we formalize, for a given class ùí¶ of ùëÜ-algebras, the (relatively) free algebra in SP(ùí¶) over ùëã. Recall, this was defined above in free algebras as follows:
\[ùîΩ(ùí¶, ùëã) := ùëª(ùëã)/Œ®(ùí¶, ùëª(ùëã)).\]
Thus, we must first formalize the congruence œà(ùí¶, ùëª(ùëã)) which is defined by
\[Œ®(ùí¶, ùëª(ùëã)) := ‚ãÄ œà(ùí¶, ùëª(ùëã)),\]
where œà(ùí¶, ùëª(ùëã)) := \{Œ∏ ‚àà Con ùëª(ùëã) : ùë®/Œ∏ ‚àà S(ùí¶)\}.
%% Strictly speaking, ùëã is not a subset of ùîΩ(ùí¶, ùëã) so it doesn't make sense to say that ``ùëã generates ùîΩ(ùí¶, ùëã).'' But as long as ùí¶ contains a nontrivial algebra, we will have Œ®(ùí¶, ùëª(ùëã)) ‚à© ùëã¬≤ ‚â† ‚àÖ, and we can identify ùëã with ùëã/Œ®(ùí¶, ùëª(ùëã)) in ùîΩ(ùí¶, ùëã). (See Obs \%s \textless{}obs 9.6\textgreater{}.)
\begin{code}\input{closure/free.tex}\end{code}

N.B. Œ® is the kernel of ùëª(X) ‚Üí ùîΩ(ùí¶, ùëª(X)). Therefore, to prove ùë® is a homomorphic image of ùîΩ(ùí¶, ùëª(X)), it suffices to show that the kernel of the lift h : ùëª(X) ‚Üí ùë® contains Œ®.

\begin{verbatim}
   ùëª---- ùëî --->>ùîΩ  (ker ùëî = Œ®)
    \         .
     \       .
      ‚Ñé     ‚àÉœï     (want: Œ® ‚äÜ ker ‚Ñé)
       \   .
        \ .
         V
         ùë®
\end{verbatim}

\subsection{More tools for Birkhoff's theorem}\label{more-tools-for-birkhoffs-theorem}
Here are some of the key facts and identities we need to complete the proof of Birkhoff's HSP theorem.
\begin{code}\input{closure/birkhofftools.tex}\end{code}


\subsection{Closure under HSP}\label{closure-under-hsp}
Finally, we have a datatype that represents classes of algebras that are close under the taking of homomorphic images, subalgebras, and products of algebras in the class.
%% \begin{verbatim}
%% -- Variety Closure
%% data VClo (ùí¶ : Pred (Algebra ùì§ ùëÜ) (ùì§ ‚Å∫)) :
%%  Pred (Algebra ùì§ ùëÜ)(ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ ‚Å∫ ) where
%%   vbase : {ùë® : Algebra ùì§ ùëÜ} ‚Üí ùë® ‚àà ùí¶ ‚Üí ùë® ‚àà VClo ùí¶
%%   vprod : {I : ùì§ Ãá }{ùíú : I ‚Üí Algebra _ ùëÜ}
%%    ‚Üí      (‚àÄ i ‚Üí ùíú i ‚àà VClo ùí¶) ‚Üí ‚®Ö ùíú ‚àà VClo ùí¶
%%   vsub : {ùë® : Algebra ùì§ ùëÜ} ‚Üí ùë® ‚àà VClo ùí¶
%%    ‚Üí     (sa : SubalgebrasOf ùë®) ‚Üí ‚à£ sa ‚à£ ‚àà VClo ùí¶
%%   vhom : {ùë® : Algebra ùì§ ùëÜ}
%%    ‚Üí     ùë® ‚àà VClo ùí¶ ‚Üí ((ùë© , _ , _) : HomImagesOf ùë®)
%%    ‚Üí     ùë© ‚àà VClo ùí¶
%% \end{verbatim}
\subsubsection{Identities for product closure}\label{identities-for-product-closure}
\begin{code}\input{closure/pclo-id.tex}\end{code}


\subsubsection{Identities for subalgebra closure}\label{identities-for-subalgebra-closure}
\begin{code}\input{closure/sclo-id.tex}\end{code}

\subsubsection{Identities for hom image closure}\label{identities-for-hom-image-closure}
\begin{code}\input{closure/hclo-id.tex}\end{code}

\subsubsection{Identities for HSP closure}\label{identities-for-hsp-closure}
\begin{code}\input{closure/vclo-id.tex}\end{code}


\subsection{Axiomatization of a class}\label{axiomatization-of-a-class}
We conclude the \closuremodule by proving that a class ùí¶ of structures is axiomatized by \texttt{Th\ (VClo\ ùí¶)}, which is the set of equations satisfied by all members of the varietal closure of ùí¶.
\begin{code}\input{closure/vclo-th.tex}\end{code}

\end{comment}
                     %%%  COMMENT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%   Birkhoff's Theorem   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HSP Theorem in Agda}\label{hsp-theorem-in-agda}
Here we give a formal proof in Agda of Birkhoff's theorem, which says that a variety is an equational class. In other terms, if a class ùí¶ of algebras is closed under the operators ùëØ, ùë∫, ùë∑, then ùí¶ is an equational class (i.e., ùí¶ is the class of algebras that model a particular set of identities).

\subsection{The birkhoff module}\label{the-birkhoff-module}
In addition to the usual importing of dependencies, We start the \birkhoffmodule with a fixed signature and a type \texttt{X}. As in the \termsmodule, \texttt{X} represents an arbitrary (infinite) collection of ``variables'' (which will serve as the generators of the term algebra ùëª(X)).
\begin{code}\input{birkhoff/birkprelude.tex}\end{code}

\subsection{Equalizers in Agda}\label{equalizers-in-agda}
The equalizer of two functions (resp., homomorphisms) \texttt{g\ h\ :\ A\ ‚Üí\ B} is the subset of \texttt{A} on which the values of the functions \texttt{g} and \texttt{h} agree. We formalize this notion in Agda as follows.
\begin{code}\input{birkhoff/equalizers.tex}\end{code}
It turns out that the equalizer of two homomorphisms is closed under the operations of \texttt{A} and is therefore a subalgebra of the common domain, as we now prove.
\begin{code}\input{birkhoff/equalizersClosed.tex}\end{code}
Thus, \texttt{ùë¨ùëØ} is a subuniverse of \texttt{A}.

\subsection{Hom determination}\label{hom-determination}
The \homomorphismsmodule formalizes the notion of homomorphism and proves some basic facts about them. Here we show that homomorphisms are determined by their values on a generating set, as stated and proved informally in Obs 3. This is proved here, and not in the \homomorphismsmodule because we need \texttt{Sg} from the \texttt{subuniverses} module. % See Section XX
\begin{code}\input{birkhoff/homUnique.tex}\end{code}

\subsection{The Agda proof of Birkhoff's theorem}\label{the-agda-proof-of-birkhoffs-theorem}
The proof is quite lengthy and uses all of the formalized definitions and results described above and more.  We do not reproduce the proof here, but refer the reader to the full listing of the \birkhoffmodule.  Suffice it to see how the statement of the theorem is formulated in Agda.
\begin{code}\input{birkhoff/birkhoffsTheoremStatement.tex}\end{code}

(TODO: Explain why this statement captures the full extend of the informal statement of the theorem.)

\section{Future work}
Some of our intermediate-term objectives include
\begin{itemize}
\item developing domain specific ``proof tactics'' to express the idioms of universal algebra,
\item incorporating automated proof search for universal algebra, and
\item formalizing theorems emerging from our own mathematics research,
\item documenting the resulting software libraries so they are usable by other working mathematicians.
\end{itemize}


\section{Acknowledgments}\label{acknowledgments}
%% Besides the main authors and developers of \agdaualib, a number of other people have contributed to the project in one way or another.

%% Special thanks go to Clifford Bergman, Venanzio Capretta, Andrej Bauer, Mikl√≥s Mar√≥ti, and Ralph Freese, for many helpful discussions, as well as the invaluable instruction, advice, and encouragement that they continue to lend to this project, often without even knowing it.

%% The first author would also like to thank his postdoctoral advisors and their institutions for supporting work on this project. These include Peter Mayr and University of Colorado in Boulder (Aug 2017--May 2019), Ralph Freese and the University of Hawaii in Honolulu (Aug 2016--May 2017), and Cliff Bergman and Iowa State University in Ames (Aug 2014--May 2016).

%% \subsubsection{Attributions and citations}\label{attributions-and-citations}
%% Regarding the mathematical results that are implemented in the \agdaualib library, as well as the presentation and informal statements of these results in the documentation, The Authors makes no claims to originality.

%% Regarding the Agda source code in the \agdaualib library, this is mainly due to The Authors.

We have benefited enormously from the outstanding lecture notes on \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes}{Univalent Foundations and Homotopy Type Theory} and the \href{https://github.com/martinescardo/TypeTopology}{Type Topology} Agda Library, both by \href{https://www.cs.bham.ac.uk/~mhe}{Martin H√∂tzel Escardo}.

Of course, the (current incarnation\footnote{previous versions were based on Coq and Lean}) \agdaualib library depends on the wonderful Agda programming language~\cite{Norell:2009}.

%% The first author is greatly indebted to Martin for teaching him about type theory in Agda at the \href{http://events.cs.bham.ac.uk/mgs2019/}{Midlands Graduate School in the Foundations of Computing Science} in Birmingham in 2019.

%% The development of the \agdaualib and its documentation is informed by and benefits from the references listed in the references section below.

%% \subsection{References}\label{references}
%% The following Agda documentation and tutorials are excellent. They have been quite helpful to The Author of \agdaualib, and have informed the development of the latter and its documentation.

%% \begin{itemize}
%% \tightlist
%% \item Altenkirk, \href{}{Computer Aided Formal Reasoning}
%% \item Bove and Dybjer, \href{}{Dependent Types at Work}
%% \item Escardo, \href{}{Introduction to Univalent Foundations of Mathematics with Agda}
%% \item Gunther, Gadea, Pagano, \href{}{Formalization of Universal Algebra in Agda}
%% \item J√°nos, \href{}{Agda Tutorial}
%% \item Norell and Chapman, \href{}{Dependently Typed Programming in Agda}
%% \item Wadler, \href{}{Programming Language Foundations in Agda}
%% \end{itemize}

%% Finally, the official \href{}{Agda Wiki}, \href{}{Agda User's Manual}, \href{}{Agda Language Reference}, and the (open source) \href{}{Agda Standard Library} source code are also quite useful.

\bibliographystyle{ACM-Reference-Format}
\bibliography{ualib_refs}
\end{document}

\vskip1cm

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\appendix

\begin{center}
\large{APPENDIX}
\end{center}

\section{Algebras}\label{algebras}
In this section we use the informal language of universal algebra to present foundational definitions and theorems about subalgebras, terms, and clones. In Section XX we show how the definitions and results presented in this section can be formalized (or ``implemented'') in type theory using Agda.

The idea is to demonstrate the power and utility of implementing our mathematical are of expertise in a formal language that supports dependent and inductive types, which are essential for expressing and working with infinite objects in a constructive and computable way, and for proving properties of these objects.


\subsection{Operations}\label{operations}
The symbols ‚Ñï, œâ, and \texttt{nat} are used interchangeably; they all denote the set of natural numbers. If ùëö is a natural number, we write ùëö : ‚Ñï and say that ùëö \emph{has type} ‚Ñï.\footnote{Viewing ùëö : ‚Ñï as roughly equivalent to ùëö ‚àà ‚Ñï is not totally unreasonable at this point.} We typically denote and define natural numbers by ùëö := \{0, 1, \ldots, ùëö-1\}, and we sometimes formally identify a function with its graph when convenient. For example, the function ùëé : ùëö ‚Üí ùê¥ may be viewed as the tuple \((ùëé\,0, ùëé\,1, ‚Ä¶, ùëé\,(ùëö-1)) : ùê¥^m\).
%% If ‚Ñé : ùê¥ ‚Üí ùê¥ and ùëé : ùëö ‚Üí ùê¥ are functions, then ‚Ñé ‚àò ùëé : ùëö ‚Üí ùê¥ denotes the composition of ‚Ñé with ùëé; this is the function that maps each ùëñ \textless{} ùëö to the element (‚Ñé ‚àò ùëé)(ùëñ) = ‚Ñé(ùëé ùëñ) of ùê¥. We may formally identify the function ‚Ñé ‚àò ùëé : ùëö ‚Üí ùê¥ with its graph, which of course is the ùëö-tuple, (‚Ñé(ùëé 0), ‚Ñé(ùëé 1), ‚Ä¶, ‚Ñé(ùëé (ùëö-1))).

If ùê¥ is a nonempty set and ùëõ ‚àà ‚Ñï, then an ùëõ-\textbf{ary operation} on ùê¥ is a function ùëì : \ensuremath{ùê¥^n} ‚Üí ùê¥ which (for \(ùëõ > 0\)) maps each ùëõ-tuple \((ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, ùëé_{n-1})\) in \ensuremath{ùê¥^n} to a particular element \(ùëì(ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, ùëé_{n-1})\) in ùê¥. If \(ùëõ = 0\), then ùëì : () ‚Üí ùê¥ may be viewed as a function that takes no arguments and returns an element of ùê¥, in which case ùëì is merely notation for a particular element of ùê¥, denoted ùëì : ùê¥.
An operation is called \textbf{nullary} (or constant) if its arity is zero. \textbf{Unary}, \textbf{binary}, and \textbf{ternary} operations have arities 1, 2, and 3, respectively.
%% An operation gives rise to a special kind of (ùëõ+1)-ary relation, namely
%% \[Gf := \{(a_0, a_1, \dots, a_{n-1}, b) \in A^{n+1} ‚à£ b = f(a_0, a_1, \dots, a_{n-1})\},\]
%% which is sometimes called the \textbf{graph} of ùëì.

For two sets ùê¥, ùêµ, the collection of functions ùëì : ùêµ ‚Üí ùê¥ is denoted by \(A^B\). Taking ùêµ = \ensuremath{ùê¥^n}, we have \(A^{A^n}\), which is the collection of ùëõ-ary operations on ùê¥; as noted above, this can be represented by the function type (ùëõ ‚Üí ùê¥) ‚Üí ùê¥.

If we let Op(ùê¥) denote the collection of all finitary operations on ùê¥, then,
\[\mathrm{Op}(ùê¥) = ‚ãÉ_{n ‚àà ‚Ñï} A^{A^n} = ‚ãÉ_{n<œâ} ((ùëõ ‚Üí A) ‚Üí A).\]

If ùêπ ‚äÜ Op(ùê¥) is a set of operations on ùê¥, let us denote by \(ùêπ_n\) the ùëõ-ary operations in ùêπ. Clearly, \(F_n = F ‚à© A^{A^n}\).

Given an ùëõ-tuple \(a = (a_0, a_1, \dots, a_{n-1}) ‚àà A^n\), it helps to be able to refer to the set \(\{a_i : 0 ‚â§ i < n\}\) of elements that occur in the tuple without explicitly naming each element in this set. In fact, we already have notation for this, since an ùëõ-tuple is truly a function, with domain ùëõ := \{0, 1, ‚Ä¶, ùëõ-1\}, and image the set of
elements occuring in the tuple. Thus, im ùëé is \(\{ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, ùëé_{n-1}\}\), where each value is included in the set only once (no repeats). In particular, ‚à£im ùëé‚à£ is a convenient way to write the number of distinct elements that occur in the tuple ùëé. For example, if ùëé = (1, 1, 3), then im ùëé = \{1, 3\}, and ‚à£im ùëé‚à£ = 2.

\subsection{Signatures}\label{signatures}
Recall (from model theory) that a \textbf{signature} ùëÜ = (ùê∂, ùêπ, ùëÖ, œÅ) consists of three (possibly empty) sets ùê∂, ùêπ, and ùëÖ (the \emph{constant symbols}, \emph{function symbols}, and \emph{relation symbols}, respectively), along with a function œÅ : ùê∂ + ùêπ + ùëÖ ‚Üí ùëÅ that assigns an arity to each symbol. Often (but not always), ùëÅ = ‚Ñï.

As our focus here is universal algebra, we are more concerned with the restricted notion of an \textbf{algebraic signature}, by which we mean a pair ùëÜ = (ùêπ, œÅ) consisting of a collection ùêπ of \emph{operation symbols} and an arity function \(œÅ : ùêπ ‚Üí ùëÅ\) that maps each operation symbol to its arity; here, ùëÅ denotes the ``arity type'' (which is sometimes taken to be ‚Ñï). (Intuitively, the arity œÅ ùëì of an operation symbol ùëì ‚àà ùêπ may be thought of as the ``number of arguments'' that ùëì takes as ``input''.)

If ùê¥ is a set and ùëì is a (œÅ ùëì)-ary operation on ùê¥, we often indicate this by writing \(f : A^{œÅ f} ‚Üí A\). On the other hand, the arguments of such an operation form a (œÅ ùëì)-tuple, say, \((ùëé‚ÇÄ, ùëé‚ÇÅ, ‚Ä¶, a_{œÅf-1})\), which may be viewed as the graph of the function ùëé : œÅùëì ‚Üí ùê¥, where \(ùëé\, ùëñ = ùëé_i\).

(When the codomain of œÅ is ‚Ñï, we may view œÅùëì as the finite set \{0, 1, ‚Ä¶, œÅùëì - 1\}. Thus, by identifying the œÅùëì-th power \(A^{œÅf}\) with the type œÅùëì ‚Üí ùê¥ of functions from \{0, 1, ‚Ä¶, œÅùëì - 1\} to ùê¥, we identify the function type \(A^{œÅf} ‚Üí A\) with the function (or ``functional'') type (œÅùëì ‚Üí ùê¥) ‚Üí ùê¥.

Our formal implementation of the concept of signature in Agda is described in Section XX.

\subsection{Algebraic Structures}\label{algebraic-structures}
Our first goal is to develop a working vocabulary and formal library for classical (single-sorted, set-based) universal algebra. In this section we define the main objects of study.


An \textbf{algebraic structure} (or \textbf{algebra}) in the signature ùëÜ = (ùêπ, œÅ) is denoted by ùë® = \( ‚ü®A, F^{\mathbf A}‚ü©\) and consists of

\begin{itemize}
\item ùê¥ := a set (or type), called the \textbf{carrier} (or \textbf{universe}) of the algebra,
\item \(F^{ùë®} := \{ f^{ùë®} ‚à£ f ‚àà F, \ f^{ùë®} : (œÅùëì ‚Üí A) ‚Üí A \}\), a collection of \textbf{operations} on ùê¥, and
\item a collection of identities satisfied by elements of ùê¥ and the operations in \(F^{ùë®}\).
\end{itemize}

Note that to each operation symbol ùëì ‚àà ùêπ corresponds an operation \(f^{ùë®}\) on ùê¥ of arity œÅùëì; we call such \(f^{ùë®}\) an
\textbf{interpretation} of the symbol ùëì in the algebra ùë®. We call an algebra in the signature ùëÜ an ùëÜ-\textbf{algebra}. An algebra is called \textbf{finite} if it has a finite universe, and is called \textbf{trivial} if its universe is a singleton.
%% Given two algebras ùë® and ùë©, we say that ùë© is a \textbf{reduct} of ùë® if both algebras have the same universe and ùë© can be obtained from ùë® by removing some operations.

Our formal implementation of the concept of algebraic structure is described in Section XX.

\subsection{Subalgebras}\label{subalgebras}
This section introduces two important concepts in universal algebra, \textbf{subuniverse} and \textbf{subalgebra}. Suppose \(ùë® = ‚ü®A, F^{ùë®}‚ü©\) is an algebra. Recall, the (nonempty) set ùê¥ is called the \textbf{universe} of ùë®. We call a subset ùêµ ‚äÜ ùê¥ \textbf{closed under} (the operations in) \(F^{ùë®}\) if for each ùëì ‚àà ùêπ and all ùëè : œÅùëì ‚Üí ùêµ we have \(f^{ùë®} \, b ‚àà B\). If a subset ùêµ ‚äÜ ùê¥ is closed under \(F^{ùë®}\), then we call ùêµ a \textbf{subuniverse} of ùë®.

If ùêµ ‚â† ‚àÖ is a subuniverse of ùë®, and if we let \(F^{ùë©} = \{ f^{ùë®} ‚Üæ B : f ‚àà F \}\), then \(ùë© = ‚ü® B, F^{ùë©} ‚ü©\) is an algebra,
called a \textbf{subalgebra} of ùë®. Conversely, all subalgebras are of this form.

If ùë© is a subalgebra of ùë®, we denote this fact by ùë© ‚â§ ùë®. Similarly, we write ùêµ ‚â§ ùë® if ùêµ is a subuniverse of ùë® (relying on context and notation to disambiguate).

%% It helps to keep in mind the following consequence of the definitions:
%% \begin{quote}\emph{The empty set is a subuniverse of every algebra, but the universe of an algebra is never empty}.\end{quote} In other terms, if S(ùë®) denotes the collection of all subalgebras of ùë®, then \[\mathrm S(ùë®) = \{‚ü®B, F^{ùë©}‚ü© : ‚àÖ ‚â† B ‚â§ ùë®\}.\]

If ùí¶ is a class of ùëÜ-algebras, then the class of all subalgebras of algebras in ùí¶ is denoted by S(ùí¶).

It is obvious that the intersection of subuniverses is again a subuniverse. Nevertheless, we will record this fact below (see Obs XX of Sec XX). %%\%s \textless{}obs 5\textgreater{}).
We will also formalize the statement and proof of this fact in Agda; see Section XX. %% (obs 5 in Agda).

\subsubsection{Subuniverse generation}\label{subuniverse-generation}
As above S(ùë®) denotes the collection of all subalgebras of ùë®. If ùë® is an algebra and ùê¥‚ÇÄ ‚äÜ ùê¥ a subset of the universe of ùë®, then the \textbf{subuniverse of} ùë® \textbf{generated by} ùê¥‚ÇÄ is denoted by \(\mathrm{Sg}^{ùë®}(A_0)\) and defined to be the smallest subuniverse of ùë® containing ùê¥‚ÇÄ. Equivalently,
\[\mathrm{Sg}^{ùë®}(A_0)  =  ‚ãÇ \{ U ‚àà \mathrm S(ùë®) ‚à£ A_0 ‚äÜ U \}.\]

We can also use recursion to define the \textbf{subuniverse of} ùë® \textbf{generated by a set} and prove that this new definition is equivalent to the one given above. We will do this below in Obs. XX of Sec XX. % (obs 7)

%% \subsection{Subdirect products}\label{subdirect-products}
%% If ùëò, ùëõ ‚àà ‚Ñï, if \(A = (A_0, A_1, \dots, A_{n-1})\) is a list of sets, and if œÉ : ùëò ‚Üí ùëõ is a ùëò-tuple, then a relation ùëÖ over ùê¥ with scope œÉ is a subset of the Cartesian product \(A_{œÉ(0)} √ó A_{œÉ(1)} √ó \cdots √ó A_{œÉ(k-1)}\).

%% Let ùëÜ = (ùêπ, œÅ) be a signature and for each ùëñ \textless{} ùëõ let \(ùë®_i = ‚ü® A_i, F ‚ü©\) be an ùëÜ-algebra. If \(ùë® = ‚àè_{i<n}ùë®_i\) is the product of these algebras, then a relation ùëÖ over ùê¥ with scope œÉ is called \textbf{compatible with} ùê¥ if it is closed under the basic operations in ùêπ. In other words, ùëÖ is compatible if the induced algebra ùëπ = ‚ü®ùëÖ, ùêπ‚ü© is a subalgebra of \(\prod_{j<k} ùë®_{œÉ(j)}\).

%% If ùëÖ is compatible with the product algebra and if the projection of ùëÖ onto each factor is surjective, then ùëπ is called a \textbf{subdirect product} of the algebras in the list \((ùë®_{œÉ(0)}, ùë®_{œÉ(1)}, \dots, ùë®_{œÉ(k-1)})\); we denote this situation by writing \(ùëπ ‚â§_{\mathrm{sd}} \prod_{j< k} ùë®_{œÉ(j)}\).
%% \textbf{Formalization}. (not yet implemented)

\subsection{Homomorphisms}\label{homomorphisms}
Let \(ùë© = ‚ü®B, F^{ùë©}‚ü©\) and \(ùë™ = ‚ü®C, F^{ùë™}‚ü©\) be algebras of the same signature, and let ‚Ñé : ùêµ ‚Üí ùê∂ be a function (e.g., on sets).

Take an operation symbol ùëì ‚àà ùêπ, and suppose that for all \(œÅ f\)-tuples ùëè : œÅùëì ‚Üí ùêµ of ùêµ the following equation holds:
\[h (f^{ùë©} \, b) = f^{ùë™} (h ‚àò b).\]

Then ‚Ñé is said to \textbf{respect the interpretation of} ùëì.

If ‚Ñé respects the interpretation of every ùëì ‚àà ùêπ, then we call ‚Ñé a \textbf{homomorphism} from ùë© to ùë™, and we write ‚Ñé ‚àà Hom(ùë©, ùë™), or simply, ‚Ñé : ùë© ‚Üí ùë™. (Later, in Agda, we will typically use notation like \texttt{h\ :\ hom\ B\ C}, or sometimes \texttt{h\ :\ Hom\ ùë©\ ùë™}.)

A homomorphism ‚Ñé : ùë© ‚Üí ùë™ is called an \textbf{epimorphism} if for every algebra ùë´ and pair \(g_1, g_2: ùë™ ‚Üí ùë´\) of homomorphisms, the equation \(g_1 ‚àò h = g_2 ‚àò h\) implies \(g_1 = g_2\). We often write ‚Ñé : ùë© ‚Ü† ùë™, and say that ``‚Ñé is \textbf{epi}'' and ``‚Ñé maps ùë© \textbf{homomorphically onto} ùë™'' in this case.

A homomorphism ‚Ñé : ùë© ‚Üí ùë™ is called a \textbf{monomorphism} if for every algebra ùë® and every pair \(g_1, g_2: ùë® ‚Üí ùë©\) of homomorphisms, the equation \(h ‚àò g_1 = h ‚àò g_2\) implies \(g_1 = g_2\). We sometimes write ‚Ñé : ùë® ‚Ü£ ùë©, and say that ``‚Ñé is \textbf{mono}'' and ``‚Ñé maps ùë© \textbf{homomorphically into} ùë™'' in this case.
‚Ü£
If ùë®, ùë© are ùëÜ-algebras and ‚Ñé : ùë® ‚Üí ùë© is a homomorphism, then the image ‚Ñé(ùê¥) of ùê¥ under ‚Ñé is called a \textbf{homomorphic image} of ùë®. The collection of all homomorphic images of an ùëÜ-algebra ùë® is the class denoted and defined by
\[\mathrm H(ùë®) := \{h(ùê¥) : h \text{ is a hom from ùë® to some ùëÜ-algebra}\}.\]

If ùí¶ is a class of ùëÜ-algebras, then the class of all homomorphic images of algebras in ùí¶ is denoted by H(ùí¶).

\subsection{Clones}\label{clones}
An \textbf{operational clone} (or just \textbf{clone}) on a nonempty set ùê¥ is a collection of operations on ùê¥ that contains the projection operations and is closed under general composition.
%% Let \(ùìí‚Ñì(ùê¥)\) denote the collection of all clones on ùê¥.

The smallest clone on ùê¥ is the \textbf{clone of projections}, which we denote and define as follows:
\[\mathrm{Proj}  A = ‚ãÉ_{i < n < œâ}  \{œÄ^n_i : ‚àÄ a ‚àà A^n,\ œÄ^n_i\, a = a(i)\}.\]

Recall, the natural number ùëò \textless{} œâ can be constructed as (or at least identified with) the set \{0, 1, ‚Ä¶, ùëò-1\}. For each ùëò \textless{} œâ, denote and define the tuple œÄ·µè : (ùëò ‚Üí ùê¥) ‚Üí ùê¥ of all ùëò-ary projections on ùê¥ as follows: for each 0 ‚â§ ùëñ \textless{} ùëò, œÄ·µè(ùëñ) is the ùëñ-th ùëò-ary projection operation that takes each ùëò-tuple \(ùëé : ùëò ‚Üí ùê¥\) to its
entry at index ùëñ, \[œÄ^k (i) a = a(i).\]
The \textbf{clone of term operations} of an ùëÜ-algebra ùë® is the smallest clone on ùê¥ containing the basic operations of ùë®; this is denoted and defined by \[\mathrm{Clo}(F^{ùë®}) = ‚ãÇ \{ U ‚àà ùìíùìµ A ‚à£ F^{ùë®} ‚äÜ U\}.\]

The set of ùëõ-ary members of \(\mathrm{Clo}(F^{ùë®})\) is sometimes denoted by \(\mathrm{Clo}_n (F^{ùë®})\) (despite the fact that the latter is obviously not a clone).

The \textbf{clone of polynomial operations} (or \textbf{polynomial clone}) of an ùëÜ-algebra ùë® is denoted by \(\mathrm{Pol} (F^{ùë®})\) and is defined to be the clone generated by the collection consisting of the basic operations (i.e., \(F^{ùë®}\)) of ùë® along with the \textbf{constants} on ùê¥.\footnote{By ``the constants on \(A\)'' we mean the \textbf{constant operations}; i.e., functions \(f: A ‚Üí A\) such that \(‚àÄ a ‚àà A, f(a) = c\), for some \(c ‚àà A\).} The set of ùëõ-ary members of \(\mathrm{Pol} (F^{ùë®})\) is sometimes denoted by \(\mathrm{Pol}_n (F^{ùë®})\).

The clone \(\mathrm{Clo}(F^{ùë®})\) is associated with the algebra ùë® only insofar as the former is constructed out of the basic operations of ùë® and the set ùê¥ on which those operations are defined. However, all that is required when defining a clone is a set ùê¥ and some collection ùêπ of operations defined on \(A\); from only these ingredients, we can construct the clone generated by ùêπ, which we denote by Clo(ùêπ). Thus \emph{the clone of terms operations can be implemented as an inductive type}. We will make this precise below (see Obs XX). %(obs 7)

\subsection{Terms and free algebras}\label{terms-and-free-algebras}
This section is based on the section of the same title in Cliff Bergman's excellent textbook (\cite{Bergman:2012}). Apart from notation, our presentation is quite similar in style and content to Cliff's, but we have attempted to give a more compact, abridged treatment in order to get more quickly to our ultimate goal (in the next section), which is to show how it is possible to express the concepts and theorems of universal algebra in type theory and to formalize them in the Agda language. We refer the reader to Section 4.3 of \cite{Bergman:2012} for more details and examples about ``classical'' (informal) universal algebra than we present here.

\subsubsection{Terms}\label{terms}
Fix a signature ùëÜ = (ùêπ, œÅ), let ùëã be a set of \textbf{variables}, and assume ùëã ‚à© ùêπ = ‚àÖ.

By a \textbf{word} on ùëã ‚à™ ùêπ we mean a nonempty, finite sequence of members of ùëã ‚à™ ùêπ, and we will denote the concatenation of such sequences by simple juxtaposition.

Let ùêπ‚ÇÄ denote the set of nullary operation symbols of ùëÜ. We define by induction on ùëõ the sets \(ùëá_n\) of \textbf{terms on} ùëã ‚à™ ùêπ as follows (cf.~\cite{Bergman:2012} Def.~4.19):
\begin{align*}
  T_0 &:= X ‚à™ F_0;\\
  T_{n+1} &:= T_n ‚à™ \{ f\, s ‚à£ f ‚àà  F, \ s: œÅf ‚Üí T_n \},
\end{align*}
and we define the collection of \textbf{terms of signature} ùëÜ \textbf{over} ùëã by ùëá(ùëã) = \(‚ãÉ_{n < œâ}T_n\). By an ùëÜ-\textbf{term} we mean a term in the signature ùëÜ. If ùë° is a term, then the \textbf{height} of ùë° is denoted by ‚à£ùë°‚à£ and defined to be the least ùëõ such that \(ùë° ‚àà ùëá_n\). The height is a useful index for recursion and induction.

The definition of ùëá(ùëã) is recursive, suggesting that terms can be implemented as an inductive type. We will confirm this in Section XX when we implement terms in Agda. Moreover, we will formalize an algebraic structure on ùëá(ùëã), called the \textbf{term algebra} in the signature ùëÜ. We describe it here and then state and prove some basic facts about this important algebra. These will be formalized in Sections XX and XX. % types for terms and birkhoffs theorem in agda

If ùëá(ùëã) is nonempty (equivalently, ùëã ‚à™ ùêπ‚ÇÄ is nonempty), then we can impose upon it an algebraic structure, which we will denote by ùëª(ùëã). We call ùëª(ùëã) the \textbf{term algebra in the signature} ùëÜ \textbf{over} ùëã; it is constructed as follows:
\begin{itemize}
\item for each operation symbol ùëì ‚àà ùêπ, let \(f^{ùëª(X)}\) be the operation on ùëá(ùëã) that maps each tuple \(ùë† : œÅùëì ‚Üí ùëá(ùëã)\) to the formal term ùëì ùë†;
\item define ùëª(ùëã) to be the algebra with universe ùëá(ùëã) and operations \(\{f^{ùëª(X)} | f ‚àà F\}\).
\end{itemize}

\subsubsection{Free algebras}\label{free-algebras}
Fix a signature ùëÜ = (ùêπ, œÅ), let ùí¶ be a class of ùëÜ-algebras, let \(ùëº = ‚ü®ùëà, ùêπ^{ùëº}‚ü©\) be an ùëÜ-algebra, and let ùëã be a subset of ùëà. We say that
\begin{itemize}
\item ùëº has the universal mapping property for ùí¶ over ùëã if for every ùë® ‚àà ùí¶ and every function ‚Ñé : ùëã ‚Üí ùê¥, there is a homomorphism \(h' : ùëº ‚Üí ùë®\) that agrees with ‚Ñé on ùëã;
\item ùëº is free for ùí¶ over ùëã if it has the universal mapping property and is generated by ùëã;
\item ùëº is free in ùí¶ over ùëã if it is free for ùí¶ over ùëã and belongs to ùí¶.
\end{itemize}
We use the next definition to take a free algebra \emph{for} a class ùí¶ and produce the free algebra \emph{in} ùí¶. Let ùí¶ be a class of ùëÜ-algebras and ùë® an ùëÜ-algebra. Define \(œà(ùí¶, ùë®) := \{Œ∏ ‚àà Con ùë® : ùë®/Œ∏ ‚àà S(ùí¶)\}\) and \(Œ®(ùí¶, ùë®) := ‚ãÄ œà(ùí¶, ùë®)\). Notice that \(œà(ùí¶, ùë®)\) may be empty, in which case \(Œ®(ùí¶, ùë®) = 1_A\) and \(ùë®/Œ®(ùí¶, ùë®)\) is trivial.

The free algebra is constructed using the above definitions for the special case in which ùë® is the algebra ùëª(ùëã) of ùëÜ-terms over ùëã. Since ùëª(ùëã) is free for the class ùìö(ùëÜ) of all ùëÜ-algebras, it follows that ùëª(ùëã) is free for every subclass ùí¶ of ùìö(ùëÜ). Of course, ùëª(ùëã) is not necessarily a member of ùí¶, but we can form the quotient of ùëª(ùëã) modulo the congruence Œ®(ùí¶, ùëª(ùëã)), which we denote by \(ùîΩ(ùí¶, ùëã) := ùëª(ùëã)/Œ®(ùí¶, ùëª(ùëã))\). The algebra ùîΩ(ùí¶, ùëã) is called the \textbf{free algebra over} ùí¶ \textbf{generated by} ùëã. It should be clear that ùîΩ(ùí¶, ùëã) is a subdirect product of the algebras \{ùëª(ùëã)/Œ∏\}, where Œ∏ ranges over œà(ùí¶, ùëª(ùëã))\}, so it belongs to SP(ùí¶). Therefore, we say that ùîΩ(ùí¶, ùëã) is free \emph{in} SP(ùí¶).

We formalize the free algebra in Section XX. %the free algebra in agda.

\subsection{Arity}\label{arity}
We denote and define the set \(X := \{x_0,x_1,\dots \}\) of variable symbols, and for each natural number \(n\) we let \(X_n:=\{x_0,x_1,\dots, x_{n-1}\}\).

Let ùëÜ = (ùêπ, œÅ) be a signature, ùë® an ùëÜ-algebra, and ùëª(X) the term algebra over ùëã; that is,
\[ùë® := ‚ü®A, F^{ùë®}‚ü© \quad \text{ and } \quad ùëª(X) := ‚ü®T(X), F^{ùëª(X)}‚ü©.\]
Each operation symbol ùëì ‚àà ùêπ gives rise to
\begin{itemize}
\item a œÅùëì-ary operation on ùëá(ùëã), denoted by \(f^{ùëª(X)}\), which maps each tuple \(ùë† : œÅùëì ‚Üí ùëá(ùëã)\) to the formal term ùëì ùë† in ùëá(ùëã), and
\item a œÅùëì-ary operation on ùê¥, denoted by \(f^{ùë®}\), which maps each tuple \(ùëé : œÅùëì ‚Üí ùê¥\) to the element \(f^{ùë®} \,a\) in ùê¥. The operation \(f^{ùë®}\) is called the \textbf{interpretation of} ùëì \textbf{in the algebra} \(ùë®\).
\end{itemize}

\begin{comment}
\subsubsection{Essential arity}\label{essential-arity}
The definition of arity of an operation or term is a bit nuanced as the next example demonstrates.
\textbf{Example}.
\begin{quote}
Suppose ùëì is a binary term, and ùëù and ùëû are ternary terms. What is the arity of the following term?
\[ùë°(ùë¢, ùë£, ùë§, ùë•, ùë¶, ùëß) = ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))\]
On the face of it, it seems safe to say that ùë° has arity 6, since it is expressible as a function of 6 variables.

But what if we decided to throw in some useless (or ``dummy'') variables, like so,
\[t'(ùë¢', ùë£', ùë¢, ùë£, ùë§, ùë•, ùë¶, ùëß, ùëß') = ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))?\]

And what happens if \(ùëù(ùë•, ùë¶, ùëß) = ùëß\), so that ùëù depends on just one of its arguments? Then we could replace it with \(ùëù'(ùëß) = ùëù(ùë•, ùë¶, ùëß)\), and ùë° could be expressed as,
\[ùë°''(ùë¢, ùë£, ùë§, ùë•, ùëß) = ùëì(ùëù'(ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))).\]

The respective arities of \(ùë°, ùë°'\) and \(ùë°''\) are 6, 9, and 5, yet arity1--arity3 merely give three different ways to present the term \(ùëì(ùëù(ùë•, ùë¶, ùëß), ùëì(ùë§, ùë•), ùëû(ùë¢, ùë£, ùë§))\).
\end{quote}

As the example demonstrates, the notion of arity of a term is not uniquely defined (modulo equivalence of terms). As such, it is sometimes useful to speak of the \textbf{essential arity} of a term, which is defined to be the minimum number of variables required to express that term; it should be clear that this is equal to the number of arguments
with respect to which the term is not constant.
\textbf{Example}.
\begin{quote} It is impossible to know the essential arity of a term until we know
that of each of its subterms. Picking up where we left off in the previous example, suppose ùëì depends on both of its arguments and \(ùëû(ùë¢, ùë£, ùë§) = ùëì(ùë£, ùë§)\). Then ùë° is expressible as
\[s(ùë£, ùë§, ùë•, ùëß) = ùëì(ùëù'(ùëß), ùëì(ùë§, ùë•), ùëì(ùë£, ùë§))\]
and we finally see the lower bound on the number of variables required to express ùë°, namely 4. Therefore, ùë° has essential arity 4.
\end{quote}
\end{comment}

\subsection{Term Operations}\label{term-operations}
In terms we defined a term in a given signature. When we interpret such a term in a particular algebraic structure, we get what is known as a term operation. In this section we explain how one defines the interpretation of an ùëÜ-term in an ùëÜ-algebra, and thus how one obtains a term \emph{operation}.

%% As usual, for each 0 \textless{} ùëõ \textless{} œâ we identify the ùëõ-tuple \((x_0, x_1, \dots, x_{n-1})\) with the function \(x:  ùëõ ‚Üí X_n\) defined by \(x\, i = x_i\) (0 ‚â§ ùëñ \textless{} ùëõ).

Recall, a term ùë° is either a variable, say, ùë° = ùë•, or has the form ùë° = ùëì ùë† for some operation symbol ùëì ‚àà ùêπ, and some œÅùëì-tuple ùë† : œÅùëì ‚Üí ùëá(ùëã) of terms.

Let ùë° ‚àà ùëá(ùëã) be an ùëÜ-term. Given an arbitrary ùëÜ-algebra ùë®, we will define a \textbf{term operation} on ùë® by giving ùë° an \emph{interpretation} in ùë®. Diverging from standard notation slightly, we will denote this operation by ùë° Ãá ùë® for reasons that will hopefully be clear when (in interpretation) we define term operations in Agda. Similarly, ùë° Ãá ùë© will denote the interpretation of the term ùë° in the algebra ùë©.

The \textbf{term operation} ùë° Ãá ùë® is defined by recursion on the height ‚à£ùë°‚à£ of ùë° as follows: for each assignment ùëé : ùëã ‚Üí ùê¥ (of values in ùê¥ to variables in ùëã),
\begin{itemize}
\item (‚à£ùë°‚à£ = 0) if ùë° is the variable ùë•, then (ùë° Ãá ùë®) ùëé = ùëé ùë•,
\item (‚à£ùë°‚à£ = ùëõ+1) if ùë° = ùëì ùë† where ùëì is an operation symbol and ùë† : œÅùëì ‚Üí ùëá(X) is a tuple of terms whose heights are at most ùëõ (i.e., ‚àÄ ùëñ, ‚à£ùë† ùëñ‚à£ ‚â§ ùëõ), then ùë° Ãá ùë® = \(f^{ùë®} \, s^{ùë®}\).
\end{itemize}

\subsection{Models and theories}\label{models-and-theories}
Let ùëÜ = (ùêπ, œÅ) be a signature and \(X := \{x_0, x_1, \dots\}\) a countable collection of variable symbols.

An \textbf{identity in the signature} ùëÜ (or ``ùëÜ-identity'') is an ordered pair of terms (ùëù, ùëû) ‚àà ùëá(ùëã) √ó ùëá(ùëã). We usually write ùëù ‚âà ùëû to indicate such an identity. Although, when we have a collection of identities, say, Œ£, we could indicate that ùëù ‚âà ùëû is among the identities in Œ£ by writing (ùëù, ùëû) ‚àà Œ£. We sometimes refer to an identity as an \textbf{equation}; for us, the words ``identity'' and ``equation'' are synonyms.

Let ùìö(ùëÜ) and ùìî(ùëÜ) denote the classes of all ùëÜ-algebras and ùëÜ-identities, respectively. For \(ùë® ‚àà ùí¶ ‚äÜ ùìö(ùëÜ)\) and \((ùëù, ùëû) ‚àà ‚Ñ∞ ‚äÜ ùìî(ùëÜ)\), we say that
\begin{itemize}
\item ùë® \textbf{models} ùëù ‚âà ùëû, denoted ùë® ‚äß ùëù ‚âà ùëû, just in case ùëù Ãá ùë® = ùëû Ãá ùë® extensionally (i.e., ‚àÄ ùëé : ùëã ‚Üí ùê¥, (ùëù Ãá ùë®) ùëé = (ùëû Ãá ùë®) ùëé);
\item ùë® \textbf{models} ‚Ñ∞, denoted ùë® ‚äß ‚Ñ∞, just in case ùë® ‚äß ùëù ‚âà ùëû holds for every (ùëù, ùëû) ‚àà ‚Ñ∞;
\item ùí¶ \textbf{models} ùëù ‚âà ùëû just in case ùë® ‚äß ùëù ‚âà ùëû holds for every ùë® in ùí¶;
\item ùí¶ \textbf{models} ‚Ñ∞ just in case ùë® ‚äß ‚Ñ∞ for every ùë® ‚àà ùí¶.
\end{itemize}

\noindent \textbf{Notation}. To produce the symbols ‚âà and ‚äß in Emacs \texttt{agda2-mode}, type \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}} and \texttt{\textbackslash{}models} (resp.). To denote ``ùí¶ models ùëù ‚âà ùëû'' we will use ùí¶ ‚äß ùëù ‚âã ùëû instead of the more standard ùí¶ ‚äß ùëù ‚âà ùëû because we distinguish it from ùë® ‚äß ùëù ‚âà ùëû in our Agda implementation. The symbol ‚âã is produced in Emacs \texttt{agda2-mode} with \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}\textasciitilde{}}.

The binary relation \(‚äß\) induces an obvious Galois connection. Indeed, the Galois pair (Mod, Th) is defined as follows: for all ‚Ñ∞ ‚äÜ ùìî(ùëÜ) and ùí¶ ‚äÜ ùìö(ùëÜ),
\begin{align*}
\mathrm{Mod} ‚Ñ∞ &:= \{ ùë® ‚àà ùìö(ùëÜ) : ùë® ‚äß ‚Ñ∞ \}, \text{ and }\\
\mathrm{Th} ùí¶ &:= \{‚ÑØ ‚àà ùìî(ùëÜ) : ùí¶ ‚äß ‚ÑØ \}.
\end{align*}

The first of these, the class of \textbf{models} of ‚Ñ∞, contains those and only those algebras modeling every identity in ‚Ñ∞. It is called an \textbf{equational class}, and ‚Ñ∞ is called an \textbf{equational base} for, or an \textbf{axiomatization} of, the class. Dually, Th ùí¶ is the class of identities modeled by every algebra in ùí¶. Such a class of identities is called an \textbf{equational theory}.

Alternatively and equivalently we could define ``equational class'' and ``equational theory'' in terms of the two
closure operators \textless{}closure operator\textgreater{} induced by the Galois pair (Mod, Th). Indeed, Mod Th : ùí´ ùìö(ùëÜ) ‚Üí ùí´ ùìö(ùëÜ) is a closure operator on ùìö(ùëÜ) and Th Mod : ùí´ ùìî(ùëÜ) ‚Üí ùí´ ùìî(ùëÜ) is a closure operator on ùìî(ùëÜ), and

\begin{itemize}
\item an \textbf{equational class} is a Mod Th-closed class \textless{}closed set\textgreater{} of ùëÜ-algebras;
\item an \textbf{equational theory} is a Th Mod-closed set of ùëÜ-identities
\end{itemize}
(Here, ùí´ denotes the powerset functor.)

\noindent \textbf{N.B.} An equational class is sometimes referred to as a \textbf{variety}; this is because of the celebrated Birkhoff theorem which states that a class of algebraic structures is an equational class if and only if it is closed under the taking of homomorphic images (H), subalgebras (S), and products (P). A formal Agda proof of Birkhoff's theorem is one of our main goals which we achieve in the \birkhoffmodule described in Section XX.

\subsection{Basic facts}\label{basic-facts}
We conclude this section with a list of basic facts and their (informal) proofs. These results are classical, straightforward consequences of the definitions above. We will need them below and when we cite them later, we will refer to them as, e.g, Obs 1, Obs 2, etc. Each of these observations is formalized in Agda in the \agdaualib.

Throughout this section, \(ùë® = ‚ü®A, F^{ùë®}‚ü©, \ ùë© = ‚ü®B, F^{ùë©}‚ü©, \ ùë™ = ‚ü®C, F^{ùë™}‚ü©\ \) are algebras in the same signature ùëÜ = (ùêπ, œÅ).

\subsubsection{Equalizers}\label{equalizers}
We start with the simple observation that equalizers of homomorphisms are subuniverses. The Agda formalization of this result and its proof is presented in obs 1 in agda.

\subsubsection{Homomorphisms}\label{homomorphisms-1}
Another easy fact is that composing homomorphisms results in a homomorphism. The easy proof of this fact is formalized in obs 2 in agda .

Another elementary result is that homomorphisms are uniquely determined by the values they take on generating sets. Our Agda proof of Obs \%s \textless{}obs 3\textgreater{} is called
\texttt{HomUnique}. It is presented obs 3 in agda.

%A corollary of the last result is an easily proved bound on the cardinality of \(|\mathrm{Hom}(ùë®, ùë©)|\).

Here is an elementary result about factorability of homomorphisms. The informal proof is presented below and its formalization in obs 5 in agda.

We formalize Obs \%s \textless{}obs 5\textgreater{} in the \homomorphismsmodule of the \agdaualib; see obs 5 in agda.

Next we observe that the intersection of subuniverses is again a subuniverse, a fact that we prove formally in the \subuniversesmodule of the \agdaualib; see obs 6 in agda.

Next is a theorem that provides a means of generating subuniverses recursively.

We formally implement the concept of subalgebra in the \subuniversesmodule of the \agdaualib, which we describe in subuniverses in agda. In particular, we describe the formalization of Obs 7 in Section XX. %obs 7.1 in agda.

Our formalization of Obs 7.1 is presented in Section XX. %obs 7.1 in agda.

We implement terms and the term algebra in Agda in the \termsmodule, as described in terms. Also in the \termsmodule is a formal proof of the next result; see Section XX. %obs 9 in agda.

Let ùí¶ be the class of ùëÜ-algebras. Then Obs 9 can be restated as: ùëª(ùëã) is free in ùí¶ over ùëã. This is sometimes expressed by saying that ùëª(ùëã) is \textbf{absolutely free} over ùëã.

It follows from Obs 9.2 that, up to isomorphism, a free algebra is determined by the cardinality of a free generating set.

Next we observe that freeness extends from a class ùí¶ to the variety it generates.

As Bergman notes (see the remark after Def 4.29 in~\cite{Bergman:2012}), ``strictly speaking, ùëã is not a subset of ùîΩ(ùí¶, X), so it doesn't make sense to talk about ùëã generating ùîΩ(ùí¶, X), [but] as long as ùí¶ contains a nontrivial algebra, \(Œ®(ùí¶, ùëã) ‚à© ùëã¬≤ = 0_X\). In light of Obs 9.2, we can identify ùëã with ùëã/Œ®(ùí¶, ùëã) in ùîΩ(ùí¶, ùëã). All of these considerations are accounted for in the following corollary.''

In the next observation, assume ùë® = \(‚ü®A, F^{ùë®}‚ü©\) and ùë© = \(‚ü®B, F^{ùë©}‚ü©\) are ùëÜ-algebras , and let ùë° ‚àà ùëá(ùëã) be a term in the language of ùëÜ. In particular, as explained in term operations, ùë° has an interpretation in ùë®, which (for reasons that will become clear when we define term operations in Agda) we will denote by ùë° Ãá ùë® and we call a \textbf{term operation}. Similarly, \(t^{ùë©}\) is the interpretation of ùë° in ùë©.

We formalize Obs 10 and its proof in the \termsmodule of the \agdaualib, as described in Section XX. %obs 10 in agda.

We formalize Obs 11 and its proof in the \termsmodule of the \agdaualib, as described in Section XX. %obs 11 in agda.

We formalize Obs12 and its proof in the \subuniversesmodule of the \agdaualib, as described in Section XX. %obs 12 in agda.

%% \emph{Proof}.
%% We prove the result for H(ùí¶). ùí¶ ‚äÜ H(ùí¶), so Th H (ùí¶) ‚äÜ Th ùí¶ ‚Ä¶

We present a formalization of this result and its proof in Section XX. %obs 13 in agda.

We formalize Obs 14 and its proof in the \birkhoffmodule of the \agdaualib, as described in Section XX. %obs 14 in agda.

The last result tells us that we can determine whether an identity is true in a variety ùí± by consulting a particular algebra, namely ùîΩ(ùí±, ùëã), the free algebra in ùí±.

\subsection{Birkhoff's theorem}\label{birkhoffs-theorem}
It follows from Obs 13 that every equational class is a variety. The converse is the celebrated HSP Theorem of Birkhoff.

\noindent \textbf{Theorem}~\cite{Birkhoff:1935}. Every class of algebraic structures that is closed under the taking of homomorphisms, subalgebras, and arbitrary products is an equational class.

In other terms, if a class ùí¶ of algebras is closed under H, S, P, then there exists a set ‚Ñ∞ of identities such that ùí¶ is the class of all algebras that model ‚Ñ∞.

%% The statement and proof we give here is essentially the same as that given in Theorem 4.41 of Cliff Bergman's textbook~\cite{Bergman:2012}. It is this statement and proof that we will formalize in Agda in the \href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/birkhoff.lagda.rst}{birkhoff module} of the \agdaualib; see birkhoffs theorem in agda.

%% \section{Notation dictionary}
%% \begin{Shaded}
%% \begin{Highlighting}[]
%% \NormalTok{Agda              MHE/agda-ualib}
%% \NormalTok{====              ==============}
%% \NormalTok{Level             Universe}
%% \NormalTok{lzero             ùì§‚ÇÄ}
%% \NormalTok{ùì§ }\OtherTok{:}\NormalTok{ Level         ùì§ }\OtherTok{:}\NormalTok{ Universe}
%% \DataTypeTok{Set}\NormalTok{ lzero         ùì§‚ÇÄ Ãá}
%% \DataTypeTok{Set}\NormalTok{ ùì§             ùì§ Ãá}
%% \NormalTok{lsuc lzero        ùì§‚ÇÄ ‚Å∫}
%% \NormalTok{lsuc ùì§            ùì§ ‚Å∫}
%% \DataTypeTok{Set} \OtherTok{(}\NormalTok{lsuc lzero}\OtherTok{)}\NormalTok{  ùì§‚ÇÄ ‚Å∫ Ãá}
%% \DataTypeTok{Set} \OtherTok{(}\NormalTok{lsuc ùì§}\OtherTok{)}\NormalTok{      ùì§ ‚Å∫ Ãá}
%% \NormalTok{Setœâ              ùì§œâ}
%% \end{Highlighting}
%% \end{Shaded}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555




\subsubsection{Public imports}\label{public-imports}
Next we import other parts of MHE's
\href{\%3Chttps://github.com/martinescardo/TypeTopology\%3E\%60_}{Type
Topology} library, using the Agda directive \texttt{public}, which means
these imports will be available wherever the \texttt{prelude} module in
imported. We describe some of these imports later, when making use of
them, but we don't describe each one in detail. (The interested or
confused reader should consult
\href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html}{HoTT-UF-in-Agda}
to learn more.)

\begin{verbatim}
open import Identity-Type renaming (_‚â°_ to infix 0 _‚â°_ ;
 refl to ùìá‚ÑØùíªùìÅ) public

pattern refl x = ùìá‚ÑØùíªùìÅ {x = x}

open import Sigma-Type renaming (_,_ to infixr 50 _,_) public

open import MGS-MLTT using (_‚àò_; domain; codomain; transport;
 _‚â°‚ü®_‚ü©_; _‚àé; pr‚ÇÅ; pr‚ÇÇ; -Œ£; Œ†; ¬¨; _√ó_; ùëñùëë; _‚àº_; _+_; ùüò; ùüô; ùüö;
 _‚áî_; lr-implication; rl-implication; id; _‚Åª¬π; ap) public

open import MGS-Equivalences using (is-equiv; inverse;
 invertible) public

open import MGS-Subsingleton-Theorems using (funext;
 dfunext; is-singleton; is-subsingleton; is-prop; Univalence;
 global-dfunext; univalence-gives-global-dfunext; _‚óè_; _‚âÉ_;
 logically-equivalent-subsingletons-are-equivalent;
 Œ†-is-subsingleton) public

open import MGS-Powerset renaming (_‚àà_ to _‚àà‚ÇÄ_; _‚äÜ_ to _‚äÜ‚ÇÄ_)
 using (ùìü; ‚àà-is-subsingleton; equiv-to-subsingleton;
 powersets-are-sets'; subset-extensionality'; propext) public

open import MGS-Embeddings using (is-embedding; pr‚ÇÅ-embedding;
 is-set; _‚Ü™_; embedding-gives-ap-is-equiv; embeddings-are-lc;
 √ó-is-subsingleton) public

open import MGS-Solved-Exercises using (to-subtype-‚â°) public

open import MGS-Subsingleton-Truncation hiding (refl; _‚àà_; _‚äÜ_) public
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Dependent pair type}\label{dependent-pair-type}

Our preferred notations for the first and second projections of a
product are \texttt{‚à£\_‚à£} and \texttt{‚à•\_‚à•}, respectively; however, we
will sometimes use the more standard \texttt{pr‚ÇÅ} and \texttt{pr‚ÇÇ}, or
even \texttt{fst} and \texttt{snd}, for emphasis, readability, or
compatibility with other libraries.

\begin{verbatim}
‚à£_‚à£ fst : {X : ùì§ Ãá }{Y : X ‚Üí ùì• Ãá} ‚Üí Œ£ Y ‚Üí X
‚à£ x , y ‚à£ = x
fst (x , y) = x

‚à•_‚à• snd : {X : ùì§ Ãá }{Y : X ‚Üí ùì• Ãá } ‚Üí (z : Œ£ Y) ‚Üí Y (pr‚ÇÅ z)
‚à• x , y ‚à• = y
snd (x , y) = y
\end{verbatim}

For the dependent pair type, we prefer the notation
\texttt{Œ£\ x\ Íûâ\ X\ ,\ y}, which is more pleasing (and more standard in
the literature) than Agda's default syntax
(\texttt{Œ£\ Œª(x\ Íûâ\ X)\ ‚Üí\ y}), and MHE has a useful trick that makes
the preferred notation available by making index type explicit.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{infixr}\NormalTok{ -1 -Œ£}
\NormalTok{-Œ£ }\OtherTok{:} \OtherTok{\{}\NormalTok{ùì§ ùì• }\OtherTok{:}\NormalTok{ Universe}\OtherTok{\}} \OtherTok{(}\NormalTok{X }\OtherTok{:}\NormalTok{ ùì§ Ãá }\OtherTok{)} \OtherTok{(}\NormalTok{Y }\OtherTok{:}\NormalTok{ X }\OtherTok{‚Üí}\NormalTok{ ùì• Ãá }\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ ùì§ ‚äî ùì• Ãá}
\NormalTok{-Œ£ X Y }\OtherTok{=}\NormalTok{ Œ£ Y}
\KeywordTok{syntax}\NormalTok{ -Œ£ X }\OtherTok{(Œª}\NormalTok{ x }\OtherTok{‚Üí}\NormalTok{ y}\OtherTok{)} \OtherTok{=}\NormalTok{ Œ£ x Íûâ X , y }\CommentTok{-- type `Íûâ` as `\textbackslash{}:4`}
\end{Highlighting}
\end{Shaded}

The symbol Íûâ is not the same as : despite how similar they may appear.
The correct colon in the expression \texttt{Œ£\ x\ Íûâ\ X\ ,\ y} above is
obtained by typing \texttt{\textbackslash{}:4} in
\href{https://agda.readthedocs.io/en/v2.6.0.1/tools/emacs-mode.html}{agda2-mode}.

MHE explains Sigma induction as follows: "To prove that \texttt{A\ z}
holds for all \texttt{z\ :\ Œ£\ Y}, for a given property \texttt{A}, we
just prove that we have \texttt{A\ (x\ ,\ y)} for all \texttt{x\ :\ X}
and \texttt{y\ :\ Y\ x}. This is called \texttt{Œ£} induction or
\texttt{Œ£} elimination (or \texttt{uncurry}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Œ£-induction }\OtherTok{:} \OtherTok{\{}\NormalTok{X }\OtherTok{:}\NormalTok{ ùì§ Ãá }\OtherTok{\}\{}\NormalTok{Y }\OtherTok{:}\NormalTok{ X }\OtherTok{‚Üí}\NormalTok{ ùì• Ãá }\OtherTok{\}\{}\NormalTok{A }\OtherTok{:}\NormalTok{ Œ£ Y }\OtherTok{‚Üí}\NormalTok{ ùì¶ Ãá }\OtherTok{\}}
 \OtherTok{‚Üí}            \OtherTok{((}\NormalTok{x }\OtherTok{:}\NormalTok{ X}\OtherTok{)(}\NormalTok{y }\OtherTok{:}\NormalTok{ Y x}\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ A }\OtherTok{(}\NormalTok{x , y}\OtherTok{))}
              \CommentTok{-------------------------------}
 \OtherTok{‚Üí}            \OtherTok{((}\NormalTok{x , y}\OtherTok{)} \OtherTok{:}\NormalTok{ Œ£ Y}\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ A }\OtherTok{(}\NormalTok{x , y}\OtherTok{)}
\NormalTok{Œ£-induction g }\OtherTok{(}\NormalTok{x , y}\OtherTok{)} \OtherTok{=}\NormalTok{ g x y}

\NormalTok{curry }\OtherTok{:} \OtherTok{\{}\NormalTok{X }\OtherTok{:}\NormalTok{ ùì§ Ãá }\OtherTok{\}\{}\NormalTok{Y }\OtherTok{:}\NormalTok{ X }\OtherTok{‚Üí}\NormalTok{ ùì• Ãá }\OtherTok{\}\{}\NormalTok{A }\OtherTok{:}\NormalTok{ Œ£ Y }\OtherTok{‚Üí}\NormalTok{ ùì¶ Ãá }\OtherTok{\}}
 \OtherTok{‚Üí}      \OtherTok{(((}\NormalTok{x , y}\OtherTok{)} \OtherTok{:}\NormalTok{ Œ£ Y }\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ A }\OtherTok{(}\NormalTok{x , y}\OtherTok{))}
       \CommentTok{---------------------------------}
 \OtherTok{‚Üí}      \OtherTok{((}\NormalTok{x }\OtherTok{:}\NormalTok{ X}\OtherTok{)} \OtherTok{(}\NormalTok{y }\OtherTok{:}\NormalTok{ Y x}\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ A }\OtherTok{(}\NormalTok{x , y}\OtherTok{))}
\NormalTok{curry f x y }\OtherTok{=}\NormalTok{ f }\OtherTok{(}\NormalTok{x , y}\OtherTok{)}
\end{Highlighting}
\end{Shaded}

The special case in which the type \texttt{Y} doesn't depend on
\texttt{X} is of course the usual Cartesian product.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{infixr} \DecValTok{30} \OtherTok{_}\NormalTok{√ó}\OtherTok{_}
\OtherTok{_}\NormalTok{√ó}\OtherTok{_} \OtherTok{:}\NormalTok{ ùì§ Ãá }\OtherTok{‚Üí}\NormalTok{ ùì• Ãá }\OtherTok{‚Üí}\NormalTok{ ùì§ ‚äî ùì• Ãá}
\NormalTok{X √ó Y }\OtherTok{=}\NormalTok{ Œ£ x Íûâ X , Y}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Dependent function type}\label{dependent-function-type}

To make the syntax for \texttt{Œ†} conform to the standard notation for
``Pi types'' (or dependent function type), MHE uses the same trick as
the one used above for ``Sigma types.''

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Œ† }\OtherTok{:} \OtherTok{\{}\NormalTok{X }\OtherTok{:}\NormalTok{ ùì§ Ãá }\OtherTok{\}} \OtherTok{(}\NormalTok{A }\OtherTok{:}\NormalTok{ X }\OtherTok{‚Üí}\NormalTok{ ùì• Ãá }\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ ùì§ ‚äî ùì• Ãá}
\NormalTok{Œ† }\OtherTok{\{}\NormalTok{ùì§}\OtherTok{\}} \OtherTok{\{}\NormalTok{ùì•}\OtherTok{\}} \OtherTok{\{}\NormalTok{X}\OtherTok{\}}\NormalTok{ A }\OtherTok{=} \OtherTok{(}\NormalTok{x }\OtherTok{:}\NormalTok{ X}\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ A x}

\NormalTok{-Œ† }\OtherTok{:} \OtherTok{\{}\NormalTok{ùì§ ùì• }\OtherTok{:}\NormalTok{ Universe}\OtherTok{\}(}\NormalTok{X }\OtherTok{:}\NormalTok{ ùì§ Ãá }\OtherTok{)(}\NormalTok{Y }\OtherTok{:}\NormalTok{ X }\OtherTok{‚Üí}\NormalTok{ ùì• Ãá }\OtherTok{)} \OtherTok{‚Üí}\NormalTok{ ùì§ ‚äî ùì• Ãá}
\NormalTok{-Œ† X Y }\OtherTok{=}\NormalTok{ Œ† Y}
\KeywordTok{infixr}\NormalTok{ -1 -Œ†}
\KeywordTok{syntax}\NormalTok{ -Œ† A }\OtherTok{(Œª}\NormalTok{ x }\OtherTok{‚Üí}\NormalTok{ b}\OtherTok{)} \OtherTok{=}\NormalTok{ Œ† x Íûâ A , b}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Application}\label{application}

An important tool that we use often in Agda proofs is application of a
function to an identification \texttt{p\ :\ x\ ‚â°\ x\textquotesingle{}}.
We apply the \texttt{ap} operator to obtain the identification
\texttt{ap\ f\ p\ :\ f\ x\ ‚â°\ f\ x\textquotesingle{}} when given
\texttt{p\ :\ x\ ‚â°\ x\textquotesingle{}} and \texttt{f\ :\ X\ ‚Üí\ Y}.

Since \texttt{ap} is already defined in MHE's Type Topolgy library, we
don't redefine it here. However, we do define some variations of
\texttt{ap} that are sometimes useful.

\begin{verbatim}
ap-cong : {X : ùì§ Ãá } {Y : ùì• Ãá }
          {f g : X ‚Üí Y} {a b : X}
 ‚Üí         f ‚â° g   ‚Üí   a ‚â° b
         -----------------------
 ‚Üí            f a ‚â° g b

ap-cong (refl _) (refl _) = refl _
\end{verbatim}

Here is a related tool that we borrow from the
\texttt{Relation/Binary/Core.agda} module of the
\href{https://agda.github.io/agda-stdlib/}{Agda standard library}.

\begin{verbatim}
cong-app : {A : ùì§ Ãá } {B : A ‚Üí ùì¶ Ãá }
           {f g : (a : A) ‚Üí B a}
 ‚Üí          f ‚â° g   ‚Üí   (a : A)
          -----------------------
 ‚Üí              f a ‚â° g a

cong-app (refl _) a = refl _
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Function extensionality}\label{function-extensionality}

Extensional equality of functions, or function extensionality, means
that any two point-wise equal functions are equal. As MHE points out,
this is known to be not provable or disprovable in Martin-L√∂f Type
Theory (MLTT).

Nonetheless, we will mainly work with pointwise equality of functions,
which MHE defines (in
\href{\%3Chttps://github.com/martinescardo/TypeTopology\%3E\%60_}{Type
Topology} ) as follows:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{_}\NormalTok{‚àº}\OtherTok{_} \OtherTok{:} \OtherTok{\{}\NormalTok{X }\OtherTok{:}\NormalTok{ ùì§ Ãá }\OtherTok{\}} \OtherTok{\{}\NormalTok{A }\OtherTok{:}\NormalTok{ X }\OtherTok{‚Üí}\NormalTok{ ùì• Ãá }\OtherTok{\}} \OtherTok{‚Üí}\NormalTok{ Œ† A }\OtherTok{‚Üí}\NormalTok{ Œ† A }\OtherTok{‚Üí}\NormalTok{ ùì§ ‚äî ùì• Ãá }
\NormalTok{f ‚àº g }\OtherTok{=} \OtherTok{‚àÄ}\NormalTok{ x }\OtherTok{‚Üí}\NormalTok{ f x ‚â° g x}
\KeywordTok{infix} \DecValTok{0} \OtherTok{_}\NormalTok{‚àº}\OtherTok{_}
\end{Highlighting}
\end{Shaded}

(The \texttt{\_‚àº\_} relation will be equivalent to equality of
functions, once we have the principle of \emph{univalence} at our
disposal.)

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Predicates, Subsets}\label{predicates-subsets}

We need a mechanism for implementing the notion of subsets in Agda. A
typical one is called \texttt{Pred} (for predicate). More generally,
\texttt{Pred\ A\ ùì§} can be viewed as the type of a property that
elements of type \texttt{A} might satisfy. We write
\texttt{P\ :\ Pred\ A\ ùì§} (read ``\texttt{P} has type
\texttt{Pred\ A\ ùì§}'') to represent the subset of elements of \texttt{A}
that satisfy property \texttt{P}.

Here is the definition (which is similar to the one found in the
\texttt{Relation/Unary.agda} file of
\href{https://agda.github.io/agda-stdlib/}{Agda standard library} ).

\begin{verbatim}
Pred : ùì§ Ãá ‚Üí (ùì• : Universe) ‚Üí ùì§ ‚äî ùì• ‚Å∫ Ãá
Pred A ùì• = A ‚Üí ùì• Ãá
\end{verbatim}

Below we will often consider predicates over the class of all algebras
of a particular type. We will define the type of algebras
\texttt{Algebra\ ùì§\ ùëÜ} (for some universe level ùì§). Like all types,
\texttt{Algebra\ ùì§\ ùëÜ} itself has a type which happens to be ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫
Ãá (as we will see in algebra type). Therefore, the type of
\texttt{Pred\ (Algebra\ ùì§\ ùëÜ)\ ùì§} will be ùìû ‚äî ùì• ‚äî ùì§ ‚Å∫ Ãá as well.

The inhabitants of the type \texttt{Pred\ (Algebra\ ùì§\ ùëÜ)\ ùì§} are maps
of the form ùë® ‚Üí ùì§ Ãá; indeed, given an algebra ùë® : Algebra ùì§ ùëÜ, we have
Pred ùë® ùì§ = ùë® ‚Üí ùì§ Ãá.

\subsubsection{The membership relation}\label{the-membership-relation}

We introduce notation so that we may indicate that \texttt{x} ``belongs
to'' a ``subset'' \texttt{P}, or that \texttt{x} ``has property''
\texttt{P}, by writing either \texttt{x\ ‚àà\ P} or \texttt{P\ x} (cf.
\texttt{Relation/Unary.agda} in the
\href{https://agda.github.io/agda-stdlib/}{Agda standard library} ).

\begin{verbatim}
infix 4 _‚àà_ _‚àâ_
_‚àà_ : {A : ùì§ Ãá } ‚Üí A ‚Üí Pred A ùì¶ ‚Üí ùì¶ Ãá
x ‚àà P = P x

_‚àâ_ : {A : ùì§ Ãá } ‚Üí A ‚Üí Pred A ùì¶ ‚Üí ùì¶ Ãá
x ‚àâ P = ¬¨ (x ‚àà P)
\end{verbatim}

\subsubsection{Subset relations}\label{subset-relations}

The subset relation is then denoted, as usual, with the \texttt{‚äÜ}
symbol (cf. \texttt{Relation/Unary.agda} in the
\href{https://agda.github.io/agda-stdlib/}{Agda standard library} ).

\begin{verbatim}
infix 4 _‚äÜ_ _‚äá_
_‚äÜ_ : {A : ùì§ Ãá } ‚Üí Pred A ùì¶ ‚Üí Pred A ùì£ ‚Üí ùì§ ‚äî ùì¶ ‚äî ùì£ Ãá
P ‚äÜ Q = ‚àÄ {x} ‚Üí x ‚àà P ‚Üí x ‚àà Q

_‚äá_ : {A : ùì§ Ãá } ‚Üí Pred A ùì¶ ‚Üí Pred A ùì£ ‚Üí ùì§ ‚äî ùì¶ ‚äî ùì£ Ãá
P ‚äá Q = Q ‚äÜ P
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Miscellany}\label{miscellany}

Finally, we include the following list of ``utilities'' that will come
in handy later. Most of these are self-explanatory, but we make a few
remarks below when we feel there is something worth noting.

\begin{verbatim}
_‚àà‚àà_ : {A : ùì§ Ãá } {B : ùì¶ Ãá } ‚Üí (A  ‚Üí  B) ‚Üí Pred B ùì£ ‚Üí ùì§ ‚äî ùì£ Ãá
_‚àà‚àà_ f S = (x : _) ‚Üí f x ‚àà S

Im_‚äÜ_ : {A : ùì§ Ãá } {B : ùì• Ãá } ‚Üí (A ‚Üí B) ‚Üí Pred B ùì£ ‚Üí ùì§ ‚äî ùì£ Ãá
Im_‚äÜ_ {A = A} f S = (x : A) ‚Üí f x ‚àà S

img : {X : ùì§ Ãá } {Y : ùì§ Ãá }
      (f : X ‚Üí Y) (P : Pred Y ùì§)
 ‚Üí    Im f ‚äÜ P ‚Üí  X ‚Üí Œ£ P
img {Y = Y} f P Imf‚äÜP = Œª x‚ÇÅ ‚Üí f x‚ÇÅ , Imf‚äÜP x‚ÇÅ

‚â°-elim-left : {A‚ÇÅ A‚ÇÇ : ùì§ Ãá } {B‚ÇÅ B‚ÇÇ : ùì¶ Ãá }
 ‚Üí            (A‚ÇÅ , B‚ÇÅ) ‚â° (A‚ÇÇ , B‚ÇÇ)
              ----------------------
 ‚Üí                   A‚ÇÅ ‚â° A‚ÇÇ
‚â°-elim-left e = ap pr‚ÇÅ e

‚â°-elim-right : {A‚ÇÅ A‚ÇÇ : ùì§ Ãá }{B‚ÇÅ B‚ÇÇ : ùì¶ Ãá }
 ‚Üí             (A‚ÇÅ , B‚ÇÅ) ‚â° (A‚ÇÇ , B‚ÇÇ)
              -----------------------
 ‚Üí                    B‚ÇÅ ‚â° B‚ÇÇ
‚â°-elim-right e = ap pr‚ÇÇ e

‚â°-√ó-intro : {A‚ÇÅ A‚ÇÇ : ùì§ Ãá } {B‚ÇÅ B‚ÇÇ : ùì¶ Ãá }
 ‚Üí           A‚ÇÅ ‚â° A‚ÇÇ  ‚Üí  B‚ÇÅ ‚â° B‚ÇÇ
          ------------------------
 ‚Üí          (A‚ÇÅ , B‚ÇÅ) ‚â° (A‚ÇÇ , B‚ÇÇ)
‚â°-√ó-intro (refl _ ) (refl _ ) = (refl _ )

cong-app-pred : ‚àÄ{A : ùì§ Ãá }{B‚ÇÅ B‚ÇÇ : Pred A ùì§}
                (x : A) ‚Üí  x ‚àà B‚ÇÅ  ‚Üí  B‚ÇÅ ‚â° B‚ÇÇ
               ------------------------------
 ‚Üí                         x ‚àà B‚ÇÇ
cong-app-pred x x‚ààB‚ÇÅ (refl _ ) = x‚ààB‚ÇÅ

cong-pred : {A : ùì§ Ãá }{B : Pred A ùì§}
            (x y : A) ‚Üí  x ‚àà B  ‚Üí  x ‚â° y
            ----------------------------
 ‚Üí                       y ‚àà B
cong-pred x .x x‚ààB (refl _ ) = x‚ààB


data Image_‚àã_ {A : ùì§ Ãá }{B : ùì¶ Ãá }(f : A ‚Üí B) : B ‚Üí ùì§ ‚äî ùì¶ Ãá
  where
  im : (x : A) ‚Üí Image f ‚àã f x
  eq : (b : B) ‚Üí (a : A) ‚Üí b ‚â° f a ‚Üí Image f ‚àã b

-- image_ : {A : ùì§ Ãá } {B : ùì¶ Ãá } ‚Üí (A ‚Üí B) ‚Üí Pred B (ùì§ ‚äî ùì¶)
-- image f = Œª b ‚Üí ‚àÉ Œª a ‚Üí b ‚â° f a

ImageIsImage : {A : ùì§ Ãá }{B : ùì¶ Ãá }
               (f : A ‚Üí B) (b : B) (a : A)
 ‚Üí              b ‚â° f a
              ----------------------------
 ‚Üí              Image f ‚àã b
ImageIsImage {A = A}{B = B} f b a b‚â°fa = eq b a b‚â°fa
\end{verbatim}

N.B. the assertion \texttt{Image\ f\ ‚àã\ y} must come with a proof, which
is of the form \texttt{‚àÉa\ f\ a\ =\ y}, so we have a witness. Thus, the
inverse can be ``computed'' in the following way:

\begin{verbatim}
Inv : {A : ùì§ Ãá }{B : ùì¶ Ãá }(f : A ‚Üí B)(b : B) ‚Üí Image f ‚àã b  ‚Üí  A
Inv f .(f a) (im a) = a
Inv f b (eq b a b‚â°fa) = a
\end{verbatim}

The special case for Set (i.e., \texttt{ùì§‚ÇÄ\ Ãá}) is

\begin{verbatim}
inv : {A B : ùì§‚ÇÄ Ãá }(f : A ‚Üí B)(b : B) ‚Üí Image f ‚àã b ‚Üí A
inv {A} {B} = Inv {ùì§‚ÇÄ}{ùì§‚ÇÄ}{A}{B}

InvIsInv : {A : ùì§ Ãá } {B : ùì¶ Ãá } (f : A ‚Üí B)
           (b : B) (b‚ààImgf : Image f ‚àã b)
          ---------------------------------
 ‚Üí         f (Inv f b b‚ààImgf) ‚â° b
InvIsInv f .(f a) (im a) = refl _
InvIsInv f b (eq b a b‚â°fa) = b‚â°fa ‚Åª¬π
\end{verbatim}

An epic (or surjective) function from ùì§ Ãá to ùì¶ Ãá (and the special case for
\texttt{ùì§‚ÇÄ\ Ãá}) is defined as follows.

\begin{verbatim}
Epic : {A : ùì§ Ãá } {B : ùì¶ Ãá } (g : A ‚Üí B) ‚Üí  ùì§ ‚äî ùì¶ Ãá
Epic g = ‚àÄ y ‚Üí Image g ‚àã y

epic : {A B : ùì§‚ÇÄ Ãá } (g : A ‚Üí B) ‚Üí ùì§‚ÇÄ Ãá
epic = Epic {ùì§‚ÇÄ} {ùì§‚ÇÄ}
\end{verbatim}

The (pseudo-)inverse of an epic function is

\begin{verbatim}
EpicInv : {A : ùì§ Ãá } {B : ùì¶ Ãá } (f : A ‚Üí B) ‚Üí Epic f ‚Üí B ‚Üí A
EpicInv f fEpic b = Inv f b (fEpic b)


-- The (psudo-)inverse of an epic is the right inverse.
EInvIsRInv : funext ùì¶ ùì¶ ‚Üí {A : ùì§ Ãá } {B : ùì¶ Ãá }
             (f : A ‚Üí B)  (fEpic : Epic f)
            ---------------------------------
 ‚Üí           f ‚àò (EpicInv f fEpic) ‚â° ùëñùëë B
EInvIsRInv fe f fEpic = fe (Œª x ‚Üí InvIsInv f x (fEpic x))
\end{verbatim}

Monics (or injective) functions are defined this way.

\begin{verbatim}
monic : {A : ùì§ Ãá } {B : ùì¶ Ãá } (g : A ‚Üí B) ‚Üí ùì§ ‚äî ùì¶ Ãá
monic g = ‚àÄ a‚ÇÅ a‚ÇÇ ‚Üí g a‚ÇÅ ‚â° g a‚ÇÇ ‚Üí a‚ÇÅ ‚â° a‚ÇÇ
monic‚ÇÄ : {A B : ùì§‚ÇÄ Ãá } (g : A ‚Üí B) ‚Üí ùì§‚ÇÄ Ãá
monic‚ÇÄ = monic {ùì§‚ÇÄ}{ùì§‚ÇÄ}

--The (pseudo-)inverse of a monic function
monic-inv : {A : ùì§ Ãá } {B : ùì¶ Ãá } (f : A ‚Üí B) ‚Üí monic f
 ‚Üí           (b : B) ‚Üí Image f ‚àã b ‚Üí A
monic-inv f fmonic  = Œª b Imf‚àãb ‚Üí Inv f b Imf‚àãb

--The (psudo-)inverse of a monic is the left inverse.
monic-inv-is-linv : {A : ùì§ Ãá }{B : ùì¶ Ãá }
                    (f : A ‚Üí B) (fmonic : monic f)(x : A)
                   ----------------------------------------
  ‚Üí                 (monic-inv f fmonic) (f x) (im x) ‚â° x
monic-inv-is-linv f fmonic x = refl _
\end{verbatim}

Finally, we define bijective functions as follows.

\begin{verbatim}
bijective : {A B : ùì§‚ÇÄ Ãá }(g : A ‚Üí B) ‚Üí ùì§‚ÇÄ Ãá
bijective g = epic g √ó monic g

Bijective : {A : ùì§ Ãá }{B : ùì¶ Ãá }(g : A ‚Üí B) ‚Üí ùì§ ‚äî ùì¶ Ãá
Bijective g = Epic g √ó monic g
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{More extensionality}\label{more-extensionality}

Here we collect miscellaneous definitions and proofs related to
extensionality that will come in handy later.

\begin{verbatim}
-------------------------------------------------------
--Function extensionality from univalence

--Ordinary function extensionality
extensionality : ‚àÄ ùì§ ùì¶  ‚Üí ùì§ ‚Å∫ ‚äî ùì¶ ‚Å∫ Ãá
extensionality ùì§ ùì¶ = {A : ùì§ Ãá } {B : ùì¶ Ãá } {f g : A ‚Üí B}
 ‚Üí                f ‚àº g   ‚Üí   f ‚â° g

--Opposite of function extensionality
intensionality : ‚àÄ {ùì§ ùì¶} {A : ùì§ Ãá } {B : ùì¶ Ãá } {f g : A ‚Üí B}
 ‚Üí                f ‚â° g  ‚Üí  (x : A)
                  ------------------
 ‚Üí                    f x ‚â° g x

intensionality  (refl _ ) _  = refl _

--Dependent intensionality
dep-intensionality : ‚àÄ {ùì§ ùì¶}{A : ùì§ Ãá }{B : A ‚Üí ùì¶ Ãá }
                     {f g : ‚àÄ(x : A) ‚Üí B x}
 ‚Üí                   f ‚â° g  ‚Üí  (x : A)
                    ------------------
 ‚Üí                    f x ‚â° g x

dep-intensionality (refl _ ) _ = refl _

--------------------------------------
--Dependent function extensionality
dep-extensionality : ‚àÄ ùì§ ùì¶ ‚Üí ùì§ ‚Å∫ ‚äî ùì¶ ‚Å∫ Ãá
dep-extensionality ùì§ ùì¶ = {A : ùì§ Ãá } {B : A ‚Üí ùì¶ Ãá }
  {f g : ‚àÄ(x : A) ‚Üí B x} ‚Üí  f ‚àº g  ‚Üí  f ‚â° g

‚àÄ-extensionality : ùì§œâ
‚àÄ-extensionality = ‚àÄ  {ùì§ ùì•} ‚Üí extensionality ùì§ ùì•

‚àÄ-dep-extensionality : ùì§œâ
‚àÄ-dep-extensionality = ‚àÄ {ùì§ ùì•} ‚Üí dep-extensionality ùì§ ùì•

extensionality-lemma : {I : ùìò Ãá }{X : ùì§ Ãá }{A : I ‚Üí ùì• Ãá }
                       (p q : (i : I) ‚Üí (X ‚Üí A i) ‚Üí ùì£ Ãá )
                       (args : X ‚Üí (Œ† A))
 ‚Üí                     p ‚â° q
   -------------------------------------------------------------
 ‚Üí (Œª i ‚Üí (p i)(Œª x ‚Üí args x i)) ‚â° (Œª i ‚Üí (q i)(Œª x ‚Üí args x i))

extensionality-lemma p q args p‚â°q =
 ap (Œª - ‚Üí Œª i ‚Üí (- i) (Œª x ‚Üí args x i)) p‚â°q
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Unicode Hints}\label{unicode-hints}

Here is a table of some of the unicode characters used in the
\href{https://gitlab.com/ualib/ualib.gitlab.io}{agda-ualib}.

\begin{quote}
\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
To get\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
Type\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùìò, ùìô\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}MCI}, \texttt{\textbackslash{}MCJ}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùì§ Ãá \textbar{}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}MCU\ \textbackslash{}\^{}.}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùì§ ‚Å∫\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}MCU\ \textbackslash{}\^{}+}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
ùì§‚ÇÄ\strut
\end{minipage} & \begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\begin{quote}
\texttt{\textbackslash{}MCU\textbackslash{}\_0}
\end{quote}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\begin{quote}
‚äî
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\begin{quote}
\texttt{\textbackslash{}sqcup}
\end{quote}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùê¥, ùêµ\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}MiA}, \texttt{\textbackslash{}MiB}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùë®, ùë©\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}MIA}, \texttt{\textbackslash{}MIB}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùíú, ‚Ñ¨\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}McA}, \texttt{\textbackslash{}McB}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùìê, ùìë\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}MCA}, \texttt{\textbackslash{}MCB}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
t Ãá ùë® \textbar{}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{t\ \textbackslash{}\^{}.\ \textbackslash{}MIA}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùëì ÃÇ ùë® \textbar{}\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}Mif\ \textbackslash{}\^{}\ \textbackslash{}MIA}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚â°\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}equiv}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\begin{quote}
ùìá‚ÑØùíªùìÅ
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\texttt{\textbackslash{}Mcr\textbackslash{}Mce\textbackslash{}Mcf\textbackslash{}Mcl}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚â°‚ü® ‚ü©\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}equiv\textbackslash{}\textless{}\ \textbackslash{}\textgreater{}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚àé, ‚ñ†\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}qed}, \texttt{\textbackslash{}sq}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
Œ£, Œ†\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}Sigma}, \texttt{\textbackslash{}Pi}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
¬¨, ‚Åª¬π\strut
\end{minipage} & \begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\begin{quote}
\texttt{\textbackslash{}neg},
\texttt{\textbackslash{}\^{}-\textbackslash{}\^{}1}
\end{quote}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
√ó\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}times}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùëñùëë\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}Mii\textbackslash{}Mid}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùìü\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}MCP}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚Ü™\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}hookrightarrow}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
ùüò, ùüô\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}b0}, \texttt{\textbackslash{}b1}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚áî\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}lr2}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚àò, ‚óè\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}cdot}, \texttt{\textbackslash{}cib}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\begin{quote}
√ó
\end{quote}\strut
\end{minipage} & \begin{minipage}[t]{0.48\columnwidth}\raggedright\strut
\texttt{\textbackslash{}times}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚à£\_‚à£\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}\textbar{}\_\textbackslash{}\textbar{}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚à•\_‚à•\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}\textbar{}\textbar{}\_\textbackslash{}\textbar{}\textbar{}}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚àº, ‚âÉ\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}\textasciitilde{}},
\texttt{\textbackslash{}\textasciitilde{}-}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚àà‚ÇÄ\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}in\textbackslash{}\_0}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
‚äÜ‚ÇÄ\strut
\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright\strut
\texttt{\textbackslash{}subseteq\textbackslash{}\_0}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}
\end{quote}

At the end of each section of this documentation we show how to produce
in Emacs
\href{https://agda.readthedocs.io/en/v2.6.0.1/tools/emacs-mode.html}{agda2-mode}
some of the fancy unicode characters that we use in our code.

We hope these hints are convenient for the reader, but they are not
meant to be comprehensive.

Instead use these

\begin{quote}
\textbf{Emacs commands providing information about special
characters/input methods:}

\begin{quote}
\begin{itemize}
\tightlist
\item
  \texttt{M-x\ describe-char} (or \texttt{M-m\ h\ d\ c}) with the cursor
  on the character of interest
\item
  \texttt{M-x\ describe-input-method} (or \texttt{C-h\ I})
\end{itemize}
\end{quote}
\end{quote}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}
