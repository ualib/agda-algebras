%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigplan')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigplan,screen]{acmart}
%\usepackage{amsmath,amscd,amssymb,amsthm}
%\usepackage{amsfonts}
%\usepackage{latexsym,enumerate,scalefnt,ifthen}
%\usepackage{mathtools}
%\usepackage{stmaryrd}

%% \usepackage[colorlinks=true,urlcolor=black,linkcolor=black,citecolor=black]{hyperref}
%% \usepackage{url}
%\usepackage{scalefnt}
%% \usepackage{tikz}
\usepackage{xspace}
%% \usetikzlibrary{math} %needed tikz library
%% \usepackage{color}
%% \usepackage[margin=4cm]{geometry}
%% \usepackage{scrextend}
\usepackage[newwjd]{agda}

%% \usepackage{fontspec,unicode-math}
%% \setmainfont{TeX Gyre Pagella}
%% \setmathfont{XITS Math}

\usepackage{unixode}
%\newcommand\mathscr[1]{\ensuremath{\mathcal{#1}}}
%% \usepackage{newunicodechar}
%% \newunicodechar{ğ‘¨}{\ensuremath{\mathbf{A}}}
%% \usepackage{pdfcomment}
%% \usepackage{color}
%% \usepackage{todonotes}
%% \usepackage[yyyymmdd,hhmmss]{datetime}
%% \usepackage{background}
%% \backgroundsetup{
%%   position=current page.east,
%%   angle=-90,
%%   nodeanchor=east,
%%   vshift=-1cm,
%%   hshift=8cm,
%%   opacity=1,
%%   scale=1,
%%   contents={\textcolor{gray!80}{WORK IN PROGRESS.  DO NOT DISTRIBUTE. (compiled on \today\ at \currenttime)}}
%% }

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[CPP '21]{CPP 2021}{January, 2021}{online}
\acmBooktitle{}
\acmPrice{}
\acmISBN{XXX-X-XXXX-XXXX-X/XX/XX}

\usepackage[mathcal]{euscript}
%\usepackage{amsfonts}

\newcommand\ab[1]{\AgdaBound{#1}}
\newcommand{\alg}[1]{\ensuremath{\mathbf{#1}}}  % algebraic structures
\newcommand{\var}[1]{\ensuremath{\mathscr{#1}}}  % algebraic structures
\newcommand{\agdaualib}{\href{https://ualib.org}{agda-ualib}\xspace}
\newcommand{\agda}{\href{https://wiki.portal.chalmers.se/agda/pmwiki.php}{Agda}\xspace}
\newcommand\signatureOV{\AgdaFunction{Signature}\AgdaSpace{}\AgdaBound{ğ“}\AgdaSpace{}\AgdaBound{ğ“¥}}
\newcommand\algebraUS{\AgdaFunction{Algebra}\AgdaSpace{}\AgdaBound{ğ“¤}\AgdaSpace{}\AgdaBound{ğ‘†}\xspace}
\newcommand\algebraOVUS{\AgdaFunction{Algebra}\AgdaSpace{}\AgdaBound{ğ“¤}\AgdaSpace{}\AgdaSymbol{\{}\AgdaBound{ğ“}\AgdaSymbol{\}\{}\AgdaBound{ğ“¥}\AgdaSymbol{\}}\AgdaSpace{}\AgdaBound{ğ‘†}}

\newcommand\preludemodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/prelude.lagda.rst}{prelude module}\xspace}
\newcommand\basicmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/basic.lagda.rst}{basic module}\xspace}
\newcommand\congruencesmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/congruences.lagda.rst}{congruences module}\xspace}
\newcommand\homomorphismsmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/homomorphisms.lagda.rst}{homomorphisms module}\xspace}
\newcommand\termsmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/terms.lagda.rst}{terms module}\xspace}
\newcommand\subuniversesmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/subuniverses.lagda.rst}{subuniverses module}\xspace}
\newcommand\closuremodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/congruences.lagda.rst}{closure module}\xspace}
\newcommand\birkhoffmodule{\href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/birkhoff.lagda.rst}{birkhoff module}\xspace}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{A Constructive, Machine-checked Proof\break of Birkhoff's Theorem}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{\protect{\href{https://williamdemeo.gitlab.io/}{William DeMeo}}}
\author{}
%% \author{William DeMeo}
%% \email{williamdemeo@gmail.com}
%% \affiliation{% \\
%%   \institution{\href{https://www.mff.cuni.cz/en/ka}{Department of Algebra}\\Charles University} %\\ Katedra Algebry, Univerzita Karlova\\
%%   \streetaddress{Sokolovska 83}
%%   \city{Prague}
%%   \state{Czech Republic} %186 00 Praha 8, 186 00 Praha 8, \v{C}esk\'{a} Republika}
%%   \postcode{186 00} % Prague 8, Czech Republic}
%% }
%% %\author{\href{https://hyeyoungshin.github.io/}{Hyeyoung Shin}}
%% \author{Hyeyoung Shin}
%% \email{hyeyoungshinw@gmail.com}
%% \affiliation{
%%   \institution{\href{https://prl-prg.github.io/}{Faculty of Information Technology}\\Czech Technical University}
%%   \streetaddress{ThÃ¡kurova 9}
%%   \city{Prague} % 6
%%   \state{Czech Republic}
%%   \postcode{160 00} 
%% }

%% %\author{\href{http://www.cs.cmu.edu/~ssomayya/}{Siva Somayyajula}}
%% \author{Siva Somayyajula}
%% \email{ssomayya@andrew.cmu.edu}
%% \affiliation{%
%%   \institution{\href{https://www.cs.cmu.edu/}{Department of Computer Science}\\
%%   Carnegie Mellon University}
%%   \streetaddress{}
%%   \city{Pittsburgh}
%%   \state{PA}
%%   \postcode{}
%% }
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%% \renewcommand{\shortauthors}{DeMeo, Shin and Somayyajula}
%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We introduce the \href{https://ualib.org}{Agda Universal Algebra Library}, a project for the formalization of universal algebra in the Agda functional programming language. The primary aim of the project is to develop a usable library that makes Agda more accessible as a tool for producing new mathematics and for formally verifying "known" results.  The authors have implemented a collection of fundamental definitions and theorems from universal algebra in Agda, exhibiting the power of inductive and dependent types for this purpose.  To demonstrate the effectiveness of the library, we describe a major milestone of the project---a formal proof of Birkhoff's HSP Theorem.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10003796</concept_id>
       <concept_desc>Theory of computation~Constructive mathematics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10002990</concept_id>
       <concept_desc>Theory of computation~Logic and verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10010147.10010148.10010164</concept_id>
       <concept_desc>Computing methodologies~Representation of mathematical objects</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010125.10010130</concept_id>
       <concept_desc>Theory of computation~Type structures</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Constructive mathematics}
\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Logic and verification}
\ccsdesc[300]{Computing methodologies~Representation of mathematical objects}
\ccsdesc[300]{Theory of computation~Type structures}


\keywords{universal algebra, formalization of mathematics, equational logic, type theory}

\maketitle

\section{Introduction}\label{introduction}
To support formalization in type theory of research level mathematics in universal algebra and related fields, the authors are contributing to the development of the Agda Universal Algebra Library (\agdaualib), a software library containing formal statements and proofs of the core definitions and results of universal algebra.

The library and is written in \agda~\cite{Norell:2009}, a programming language and proof assistant based on Martin-L\"of Type Theory that not only supports dependent and inductive types, but also provides powerful \emph{proof tactics} for proving things about the objects that inhabit these types.

\subsection{Vision and Goals}\label{vision-and-goals}
The idea for the the Agda Universal Algebra Library originated with the observation that, on the one hand a number of basic and important constructs in universal algebra can be defined recursively, and theorems about them proved inductively, while on the other hand the \emph{types}---in particular, dependent and inductive types---make possible precise formal representations of recursively defined objects as well as constructive proofs of their properties, proofs that are computable and composable. These observations suggest that there is much to gain from implementing universal algebra in a language that supports dependent and inductive types.

\subsubsection{Primary Goals}\label{primary-goals}
The first goal of the project is to express the foundations of universal algebra in (constructive, Martin-L\"of) type theory, and to formally verify these foundations using the Agda programming language. Thus we aim to codify the edifice upon which our mathematical research stands, and demonstrate that advancements in our field can also be expressed in type theory and formally verified in a way that we and other working mathematicians can easily understand and check the results. We hope the library inspires and encourages others to formalize and verify their own mathematics research so that we may more easily understand and verify their results.

Our field is deep and broad, so codifying all of its foundations may seem like a daunting task and a risky investment of time and resources. However, we believe the subject is well served by a new, modern, \emph{constructive} presentation of its foundations.  Finally, the mere act of reinterpreting the foundations in an alternative system offers a fresh perspective, yielding new insights into our mathematics research.

%% Our new presentation expresses the foundations of universal algebra in the language of type theory, and uses the Agda proof assistant to codify and formally verify all aspects of the presentation.

\subsubsection{Secondary Goals}\label{secondary-goals}
We wish to emphasize that our ultimate objective is not merely to translate existing results into a more modern and formal language. Indeed, one important goal is to develop a system that is useful for conducting research in mathematics, and that is how we intend to use our library once we have achieved our immediate objective of implementing
the basic foundational core of universal algebra in Agda.

To this end, our intermediate-term objectives include
\begin{itemize}
\item developing domain specific ``proof tactics'' to express the idioms of universal algebra,
\item incorporating automated proof search for universal algebra, and
\item formalizing theorems emerging from our own mathematics research,
\item documenting the resulting software libraries so they are usable by other working mathematicians.
\end{itemize}

In our own mathematics research, experience has taught us that a proof assistant equipped with specialized libraries for universal algebra, as well as domain-specific tactics to automate proof idioms of our field, is extremely useful. Thus, a second goal of the agda-ualib project is to demonstrate the utility of such libraries and tactics for proving new theorems.

%% \subsection{Intended audience}\label{intended-audience}
%% This paper describes the Agda Universal Algebra Library (\agdaualib) in enough detail so that working mathematicians (and possibly some normal people, too) might be able to learn enough about Agda and its libraries to put them to use when creating, formalizing, and verifying new mathematics.

%% While there are no strict prerequisites, we expect anyone with an interest in this work will have been motivated by prior exposure to universal algebra, as presented in, say, \cite{Bergman:2012} or \cite{McKenzie:1987}, and to a lesser extent category theory, as presented in \cite{Riehl:2017}.

%% Some prior exposure to type theory and Agda would be helpful, but even without this background one should be able to gain something from reading article, by referring to the appendix and glossary, while simultaneously consulting one or more of the references mentioned in the references to fill in gaps as needed.

%% Finally, readers of this paper will benefit most from actively experimenting with Agda and the agda-ualib.

%% \subsection{Installing the library}\label{installing-the-library}
%% The main repository for the \agdaualib is \url{https://gitlab.com/ualib/ualib.gitlab.io}.

%% There are installation instructions in the main README.md file in that repository, but really all one needs is a working Agda installation and a clone of the \agdaualib repository.



\section{Algebras}\label{algebras}
In this chapter we use the informal language of universal algebra to present foundational definitions and theorems about subalgebras, terms, and clones. In Section XX we show how the definitions and results presented in this section can be formalized (or ``implemented'') in type theory using Agda.

The idea is to demonstrate the power and utility of implementing our mathematical are of expertise in a formal language that supports dependent and inductive types, which are essential for expressing and working with infinite objects in a constructive and computable way, and for proving properties of these objects.

One goal of our project is to provide, as a ``proof of concept'' a formal implementation of a deep result in universal algebra. As the focus of this goal, we have chosen what was among the first major results of the theory of universal algebras---namely, Garrett Birkhoff's celebrated HSP Theorem~\cite{Birkhoff:1935}.

A nice (informal) proof of the HSP Theorem appears on pages 106 and 107 of Cliff Bergman's book~\cite{Bergman:2012}. Naturally, the proof relies on many defeinitions and results developed in earlier chapters of the book. Nonetheless, Professor Bergman's path to a proof of the HSP theorem is the most straightforward and efficient one we know, and we will follow his presentation quite closely.

On the other hand, in order to get as directly as possible to a formal proof of the HSP Theorem, we will extract all the ingredients we need from~\cite{Bergman:2012}, and present them as a list of results at the end of this section, and then later, in Section XX, we will formalize each of these results in Agda.

Whenever we quote or paraphrase a result from~\cite{Bergman:2012}, we will include a citation that indicates where the corresponding result is found in the book.

\subsection{Operations}\label{operations}
The symbols â„•, Ï‰, and \texttt{nat} are used interchangeably; they all denote the set of natural numbers. If ğ‘š is a natural number, we write ğ‘š : â„• and say that ğ‘š \emph{has type} â„•.\footnote{Viewing ğ‘š : â„• as roughly equivalent to ğ‘š âˆˆ â„• is not totally unreasonable at this point.} We typically denote and define natural numbers by ğ‘š := \{0, 1, \ldots, ğ‘š-1\}, and we sometimes formally identify a function with its graph when convenient. For example, the function ğ‘ : ğ‘š â†’ ğ´ may be viewed as the tuple \((ğ‘\,0, ğ‘\,1, â€¦, ğ‘\,(ğ‘š-1)) : ğ´^m\).
%% If â„ : ğ´ â†’ ğ´ and ğ‘ : ğ‘š â†’ ğ´ are functions, then â„ âˆ˜ ğ‘ : ğ‘š â†’ ğ´ denotes the composition of â„ with ğ‘; this is the function that maps each ğ‘– \textless{} ğ‘š to the element (â„ âˆ˜ ğ‘)(ğ‘–) = â„(ğ‘ ğ‘–) of ğ´. We may formally identify the function â„ âˆ˜ ğ‘ : ğ‘š â†’ ğ´ with its graph, which of course is the ğ‘š-tuple, (â„(ğ‘ 0), â„(ğ‘ 1), â€¦, â„(ğ‘ (ğ‘š-1))).

If ğ´ is a nonempty set and ğ‘› âˆˆ â„•, then an ğ‘›-\textbf{ary operation} on ğ´ is a function ğ‘“ : \ensuremath{ğ´^n} â†’ ğ´ which (for \(ğ‘› > 0\)) maps each ğ‘›-tuple \((ğ‘â‚€, ğ‘â‚, â€¦, ğ‘_{n-1})\) in \ensuremath{ğ´^n} to a particular element \(ğ‘“(ğ‘â‚€, ğ‘â‚, â€¦, ğ‘_{n-1})\) in ğ´. If \(ğ‘› = 0\), then ğ‘“ : () â†’ ğ´ may be viewed as a function that takes no arguments and returns an element of ğ´, in which case ğ‘“ is merely notation for a particular element of ğ´, denoted ğ‘“ : ğ´.
An operation is called \textbf{nullary} (or constant) if its arity is zero. \textbf{Unary}, \textbf{binary}, and \textbf{ternary} operations have arities 1, 2, and 3, respectively.
%% An operation gives rise to a special kind of (ğ‘›+1)-ary relation, namely
%% \[Gf := \{(a_0, a_1, \dots, a_{n-1}, b) \in A^{n+1} âˆ£ b = f(a_0, a_1, \dots, a_{n-1})\},\]
%% which is sometimes called the \textbf{graph} of ğ‘“.

For two sets ğ´, ğµ, the collection of functions ğ‘“ : ğµ â†’ ğ´ is denoted by \(A^B\). Taking ğµ = \ensuremath{ğ´^n}, we have \(A^{A^n}\), which is the collection of ğ‘›-ary operations on ğ´; as noted above, this can be represented by the function type (ğ‘› â†’ ğ´) â†’ ğ´.

If we let Op(ğ´) denote the collection of all finitary operations on ğ´, then,
\[\mathrm{Op}(ğ´) = â‹ƒ_{n âˆˆ â„•} A^{A^n} = â‹ƒ_{n<Ï‰} ((ğ‘› â†’ A) â†’ A).\]

If ğ¹ âŠ† Op(ğ´) is a set of operations on ğ´, let us denote by \(ğ¹_n\) the ğ‘›-ary operations in ğ¹. Clearly, \(F_n = F âˆ© A^{A^n}\).

Given an ğ‘›-tuple \(a = (a_0, a_1, \dots, a_{n-1}) âˆˆ A^n\), it helps to be able to refer to the set \(\{a_i : 0 â‰¤ i < n\}\) of elements that occur in the tuple without explicitly naming each element in this set. In fact, we already have notation for this, since an ğ‘›-tuple is truly a function, with domain ğ‘› := \{0, 1, â€¦, ğ‘›-1\}, and image the set of
elements occuring in the tuple. Thus, im ğ‘ is \(\{ğ‘â‚€, ğ‘â‚, â€¦, ğ‘_{n-1}\}\), where each value is included in the set only once (no repeats). In particular, âˆ£im ğ‘âˆ£ is a convenient way to write the number of distinct elements that occur in the tuple ğ‘. For example, if ğ‘ = (1, 1, 3), then im ğ‘ = \{1, 3\}, and âˆ£im ğ‘âˆ£ = 2.

\subsection{Signatures}\label{signatures}
Recall (from model theory) that a \textbf{signature} ğ‘† = (ğ¶, ğ¹, ğ‘…, Ï) consists of three (possibly empty) sets ğ¶, ğ¹, and ğ‘… (the \emph{constant symbols}, \emph{function symbols}, and \emph{relation symbols}, respectively), along with a function Ï : ğ¶ + ğ¹ + ğ‘… â†’ ğ‘ that assigns an arity to each symbol. Often (but not always), ğ‘ = â„•.

As our focus here is universal algebra, we are more concerned with the restricted notion of an \textbf{algebraic signature}, by which we mean a pair ğ‘† = (ğ¹, Ï) consisting of a collection ğ¹ of \emph{operation symbols} and an arity function \(Ï : ğ¹ â†’ ğ‘\) that maps each operation symbol to its arity; here, ğ‘ denotes the ``arity type'' (which is sometimes taken to be â„•). (Intuitively, the arity Ï ğ‘“ of an operation symbol ğ‘“ âˆˆ ğ¹ may be thought of as the ``number of arguments'' that ğ‘“ takes as ``input''.)

If ğ´ is a set and ğ‘“ is a (Ï ğ‘“)-ary operation on ğ´, we often indicate this by writing \(f : A^{Ï f} â†’ A\). On the other hand, the arguments of such an operation form a (Ï ğ‘“)-tuple, say, \((ğ‘â‚€, ğ‘â‚, â€¦, a_{Ïf-1})\), which may be viewed as the graph of the function ğ‘ : Ïğ‘“ â†’ ğ´, where \(ğ‘\, ğ‘– = ğ‘_i\).

(When the codomain of Ï is â„•, we may view Ïğ‘“ as the finite set \{0, 1, â€¦, Ïğ‘“ - 1\}. Thus, by identifying the Ïğ‘“-th power \(A^{Ïf}\) with the type Ïğ‘“ â†’ ğ´ of functions from \{0, 1, â€¦, Ïğ‘“ - 1\} to ğ´, we identify the function type \(A^{Ïf} â†’ A\) with the function (or ``functional'') type (Ïğ‘“ â†’ ğ´) â†’ ğ´.

Our formal implementation of the concept of signature in Agda is described in Section XX.

\subsection{Algebraic Structures}\label{algebraic-structures}
Our first goal is to develop a working vocabulary and formal library for classical (single-sorted, set-based) universal algebra. In this section we define the main objects of study.


An \textbf{algebraic structure} (or \textbf{algebra}) in the signature ğ‘† = (ğ¹, Ï) is denoted by ğ‘¨ = \( âŸ¨A, F^{\mathbf A}âŸ©\) and consists of

\begin{itemize}
\item ğ´ := a set (or type), called the \textbf{carrier} (or \textbf{universe}) of the algebra,
\item \(F^{ğ‘¨} := \{ f^{ğ‘¨} âˆ£ f âˆˆ F, \ f^{ğ‘¨} : (Ïğ‘“ â†’ A) â†’ A \}\), a collection of \textbf{operations} on ğ´, and
\item a collection of identities satisfied by elements of ğ´ and the operations in \(F^{ğ‘¨}\).
\end{itemize}

Note that to each operation symbol ğ‘“ âˆˆ ğ¹ corresponds an operation \(f^{ğ‘¨}\) on ğ´ of arity Ïğ‘“; we call such \(f^{ğ‘¨}\) an
\textbf{interpretation} of the symbol ğ‘“ in the algebra ğ‘¨. We call an algebra in the signature ğ‘† an ğ‘†-\textbf{algebra}. An algebra is called \textbf{finite} if it has a finite universe, and is called \textbf{trivial} if its universe is a singleton.
%% Given two algebras ğ‘¨ and ğ‘©, we say that ğ‘© is a \textbf{reduct} of ğ‘¨ if both algebras have the same universe and ğ‘© can be obtained from ğ‘¨ by removing some operations.

Our formal implementation of the concept of algebraic structure is described in Section XX.

\subsection{Subalgebras}\label{subalgebras}
This section introduces two important concepts in universal algebra, \textbf{subuniverse} and \textbf{subalgebra}. Suppose \(ğ‘¨ = âŸ¨A, F^{ğ‘¨}âŸ©\) is an algebra. Recall, the (nonempty) set ğ´ is called the \textbf{universe} of ğ‘¨. We call a subset ğµ âŠ† ğ´ \textbf{closed under} (the operations in) \(F^{ğ‘¨}\) if for each ğ‘“ âˆˆ ğ¹ and all ğ‘ : Ïğ‘“ â†’ ğµ we have \(f^{ğ‘¨} \, b âˆˆ B\). If a subset ğµ âŠ† ğ´ is closed under \(F^{ğ‘¨}\), then we call ğµ a \textbf{subuniverse} of ğ‘¨.

If ğµ â‰  âˆ… is a subuniverse of ğ‘¨, and if we let \(F^{ğ‘©} = \{ f^{ğ‘¨} â†¾ B : f âˆˆ F \}\), then \(ğ‘© = âŸ¨ B, F^{ğ‘©} âŸ©\) is an algebra,
called a \textbf{subalgebra} of ğ‘¨. Conversely, all subalgebras are of this form.

If ğ‘© is a subalgebra of ğ‘¨, we denote this fact by ğ‘© â‰¤ ğ‘¨. Similarly, we write ğµ â‰¤ ğ‘¨ if ğµ is a subuniverse of ğ‘¨ (relying on context and notation to disambiguate).

%% It helps to keep in mind the following consequence of the definitions:
%% \begin{quote}\emph{The empty set is a subuniverse of every algebra, but the universe of an algebra is never empty}.\end{quote} In other terms, if S(ğ‘¨) denotes the collection of all subalgebras of ğ‘¨, then \[\mathrm S(ğ‘¨) = \{âŸ¨B, F^{ğ‘©}âŸ© : âˆ… â‰  B â‰¤ ğ‘¨\}.\]

If ğ’¦ is a class of ğ‘†-algebras, then the class of all subalgebras of algebras in ğ’¦ is denoted by S(ğ’¦).

It is obvious that the intersection of subuniverses is again a subuniverse. Nevertheless, we will record this fact below (see Obs XX of Sec XX). %%\%s \textless{}obs 5\textgreater{}).
We will also formalize the statement and proof of this fact in Agda; see Section XX. %% (obs 5 in Agda).

\subsubsection{Subuniverse generation}\label{subuniverse-generation}
As above S(ğ‘¨) denotes the collection of all subalgebras of ğ‘¨. If ğ‘¨ is an algebra and ğ´â‚€ âŠ† ğ´ a subset of the universe of ğ‘¨, then the \textbf{subuniverse of} ğ‘¨ \textbf{generated by} ğ´â‚€ is denoted by \(\mathrm{Sg}^{ğ‘¨}(A_0)\) and defined to be the smallest subuniverse of ğ‘¨ containing ğ´â‚€. Equivalently,
\[\mathrm{Sg}^{ğ‘¨}(A_0)  =  â‹‚ \{ U âˆˆ \mathrm S(ğ‘¨) âˆ£ A_0 âŠ† U \}.\]

We can also use recursion to define the \textbf{subuniverse of} ğ‘¨ \textbf{generated by a set} and prove that this new definition is equivalent to the one given above. We will do this below in Obs. XX of Sec XX. % (obs 7)

%% \subsection{Subdirect products}\label{subdirect-products}
%% If ğ‘˜, ğ‘› âˆˆ â„•, if \(A = (A_0, A_1, \dots, A_{n-1})\) is a list of sets, and if Ïƒ : ğ‘˜ â†’ ğ‘› is a ğ‘˜-tuple, then a relation ğ‘… over ğ´ with scope Ïƒ is a subset of the Cartesian product \(A_{Ïƒ(0)} Ã— A_{Ïƒ(1)} Ã— \cdots Ã— A_{Ïƒ(k-1)}\).

%% Let ğ‘† = (ğ¹, Ï) be a signature and for each ğ‘– \textless{} ğ‘› let \(ğ‘¨_i = âŸ¨ A_i, F âŸ©\) be an ğ‘†-algebra. If \(ğ‘¨ = âˆ_{i<n}ğ‘¨_i\) is the product of these algebras, then a relation ğ‘… over ğ´ with scope Ïƒ is called \textbf{compatible with} ğ´ if it is closed under the basic operations in ğ¹. In other words, ğ‘… is compatible if the induced algebra ğ‘¹ = âŸ¨ğ‘…, ğ¹âŸ© is a subalgebra of \(\prod_{j<k} ğ‘¨_{Ïƒ(j)}\).

%% If ğ‘… is compatible with the product algebra and if the projection of ğ‘… onto each factor is surjective, then ğ‘¹ is called a \textbf{subdirect product} of the algebras in the list \((ğ‘¨_{Ïƒ(0)}, ğ‘¨_{Ïƒ(1)}, \dots, ğ‘¨_{Ïƒ(k-1)})\); we denote this situation by writing \(ğ‘¹ â‰¤_{\mathrm{sd}} \prod_{j< k} ğ‘¨_{Ïƒ(j)}\).
%% \textbf{Formalization}. (not yet implemented)

\subsection{Homomorphisms}\label{homomorphisms}
Let \(ğ‘© = âŸ¨B, F^{ğ‘©}âŸ©\) and \(ğ‘ª = âŸ¨C, F^{ğ‘ª}âŸ©\) be algebras of the same signature, and let â„ : ğµ â†’ ğ¶ be a function (e.g., on sets).

Take an operation symbol ğ‘“ âˆˆ ğ¹, and suppose that for all \(Ï f\)-tuples ğ‘ : Ïğ‘“ â†’ ğµ of ğµ the following equation holds:
\[h (f^{ğ‘©} \, b) = f^{ğ‘ª} (h âˆ˜ b).\]

Then â„ is said to \textbf{respect the interpretation of} ğ‘“.

If â„ respects the interpretation of every ğ‘“ âˆˆ ğ¹, then we call â„ a \textbf{homomorphism} from ğ‘© to ğ‘ª, and we write â„ âˆˆ Hom(ğ‘©, ğ‘ª), or simply, â„ : ğ‘© â†’ ğ‘ª. (Later, in Agda, we will typically use notation like \texttt{h\ :\ hom\ B\ C}, or sometimes \texttt{h\ :\ Hom\ ğ‘©\ ğ‘ª}.)

A homomorphism â„ : ğ‘© â†’ ğ‘ª is called an \textbf{epimorphism} if for every algebra ğ‘« and pair \(g_1, g_2: ğ‘ª â†’ ğ‘«\) of homomorphisms, the equation \(g_1 âˆ˜ h = g_2 âˆ˜ h\) implies \(g_1 = g_2\). We often write â„ : ğ‘© â†  ğ‘ª, and say that ``â„ is \textbf{epi}'' and ``â„ maps ğ‘© \textbf{homomorphically onto} ğ‘ª'' in this case.

A homomorphism â„ : ğ‘© â†’ ğ‘ª is called a \textbf{monomorphism} if for every algebra ğ‘¨ and every pair \(g_1, g_2: ğ‘¨ â†’ ğ‘©\) of homomorphisms, the equation \(h âˆ˜ g_1 = h âˆ˜ g_2\) implies \(g_1 = g_2\). We sometimes write â„ : ğ‘¨ â†£ ğ‘©, and say that ``â„ is \textbf{mono}'' and ``â„ maps ğ‘© \textbf{homomorphically into} ğ‘ª'' in this case.
â†£
If ğ‘¨, ğ‘© are ğ‘†-algebras and â„ : ğ‘¨ â†’ ğ‘© is a homomorphism, then the image â„(ğ´) of ğ´ under â„ is called a \textbf{homomorphic image} of ğ‘¨. The collection of all homomorphic images of an ğ‘†-algebra ğ‘¨ is the class denoted and defined by
\[\mathrm H(ğ‘¨) := \{h(ğ´) : h \text{ is a hom from ğ‘¨ to some ğ‘†-algebra}\}.\]

If ğ’¦ is a class of ğ‘†-algebras, then the class of all homomorphic images of algebras in ğ’¦ is denoted by H(ğ’¦).

\subsection{Clones}\label{clones}
An \textbf{operational clone} (or just \textbf{clone}) on a nonempty set ğ´ is a collection of operations on ğ´ that contains the projection operations and is closed under general composition.
%% Let \(ğ“’â„“(ğ´)\) denote the collection of all clones on ğ´.

The smallest clone on ğ´ is the \textbf{clone of projections}, which we denote and define as follows:
\[\mathrm{Proj}  A = â‹ƒ_{i < n < Ï‰}  \{Ï€^n_i : âˆ€ a âˆˆ A^n,\ Ï€^n_i\, a = a(i)\}.\]

Recall, the natural number ğ‘˜ \textless{} Ï‰ can be constructed as (or at least identified with) the set \{0, 1, â€¦, ğ‘˜-1\}. For each ğ‘˜ \textless{} Ï‰, denote and define the tuple Ï€áµ : (ğ‘˜ â†’ ğ´) â†’ ğ´ of all ğ‘˜-ary projections on ğ´ as follows: for each 0 â‰¤ ğ‘– \textless{} ğ‘˜, Ï€áµ(ğ‘–) is the ğ‘–-th ğ‘˜-ary projection operation that takes each ğ‘˜-tuple \(ğ‘ : ğ‘˜ â†’ ğ´\) to its
entry at index ğ‘–, \[Ï€^k (i) a = a(i).\]
The \textbf{clone of term operations} of an ğ‘†-algebra ğ‘¨ is the smallest clone on ğ´ containing the basic operations of ğ‘¨; this is denoted and defined by \[\mathrm{Clo}(F^{ğ‘¨}) = â‹‚ \{ U âˆˆ ğ“’ğ“µ A âˆ£ F^{ğ‘¨} âŠ† U\}.\]

The set of ğ‘›-ary members of \(\mathrm{Clo}(F^{ğ‘¨})\) is sometimes denoted by \(\mathrm{Clo}_n (F^{ğ‘¨})\) (despite the fact that the latter is obviously not a clone).

The \textbf{clone of polynomial operations} (or \textbf{polynomial clone}) of an ğ‘†-algebra ğ‘¨ is denoted by \(\mathrm{Pol} (F^{ğ‘¨})\) and is defined to be the clone generated by the collection consisting of the basic operations (i.e., \(F^{ğ‘¨}\)) of ğ‘¨ along with the \textbf{constants} on ğ´.\footnote{By ``the constants on \(A\)'' we mean the \textbf{constant operations}; i.e., functions \(f: A â†’ A\) such that \(âˆ€ a âˆˆ A, f(a) = c\), for some \(c âˆˆ A\).} The set of ğ‘›-ary members of \(\mathrm{Pol} (F^{ğ‘¨})\) is sometimes denoted by \(\mathrm{Pol}_n (F^{ğ‘¨})\).

The clone \(\mathrm{Clo}(F^{ğ‘¨})\) is associated with the algebra ğ‘¨ only insofar as the former is constructed out of the basic operations of ğ‘¨ and the set ğ´ on which those operations are defined. However, all that is required when defining a clone is a set ğ´ and some collection ğ¹ of operations defined on \(A\); from only these ingredients, we can construct the clone generated by ğ¹, which we denote by Clo(ğ¹). Thus \emph{the clone of terms operations can be implemented as an inductive type}. We will make this precise below (see Obs XX). %(obs 7)

\subsection{Terms and free algebras}\label{terms-and-free-algebras}
This section is based on the section of the same title in Cliff Bergman's excellent textbook (\cite{Bergman:2012}). Apart from notation, our presentation is quite similar in style and content to Cliff's, but we have attempted to give a more compact, abridged treatment in order to get more quickly to our ultimate goal (in the next chapter), which is to show how it is possible to express the concepts and theorems of universal algebra in type theory and to formalize them in the Agda language. We refer the reader to Section 4.3 of \cite{Bergman:2012} for more details and examples about ``classical'' (informal) universal algebra than we present here.

\subsubsection{Terms}\label{terms}
Fix a signature ğ‘† = (ğ¹, Ï), let ğ‘‹ be a set of \textbf{variables}, and assume ğ‘‹ âˆ© ğ¹ = âˆ….

By a \textbf{word} on ğ‘‹ âˆª ğ¹ we mean a nonempty, finite sequence of members of ğ‘‹ âˆª ğ¹, and we will denote the concatenation of such sequences by simple juxtaposition.

Let ğ¹â‚€ denote the set of nullary operation symbols of ğ‘†. We define by induction on ğ‘› the sets \(ğ‘‡_n\) of \textbf{terms on} ğ‘‹ âˆª ğ¹ as follows (cf.~\cite{Bergman:2012} Def.~4.19):
\begin{align*}
  T_0 &:= X âˆª F_0;\\
  T_{n+1} &:= T_n âˆª \{ f\, s âˆ£ f âˆˆ  F, \ s: Ïf â†’ T_n \},
\end{align*}
and we define the collection of \textbf{terms of signature} ğ‘† \textbf{over} ğ‘‹ by ğ‘‡(ğ‘‹) = \(â‹ƒ_{n < Ï‰}T_n\). By an ğ‘†-\textbf{term} we mean a term in the signature ğ‘†. If ğ‘¡ is a term, then the \textbf{height} of ğ‘¡ is denoted by âˆ£ğ‘¡âˆ£ and defined to be the least ğ‘› such that \(ğ‘¡ âˆˆ ğ‘‡_n\). The height is a useful index for recursion and induction.

The definition of ğ‘‡(ğ‘‹) is recursive, suggesting that terms can be implemented as an inductive type. We will confirm this in Section XX when we implement terms in Agda. Moreover, we will formalize an algebraic structure on ğ‘‡(ğ‘‹), called the \textbf{term algebra} in the signature ğ‘†. We describe it here and then state and prove some basic facts about this important algebra. These will be formalized in Sections XX and XX. % types for terms and birkhoffs theorem in agda

If ğ‘‡(ğ‘‹) is nonempty (equivalently, ğ‘‹ âˆª ğ¹â‚€ is nonempty), then we can impose upon it an algebraic structure, which we will denote by ğ‘»(ğ‘‹). We call ğ‘»(ğ‘‹) the \textbf{term algebra in the signature} ğ‘† \textbf{over} ğ‘‹; it is constructed as follows:
\begin{itemize}
\item for each operation symbol ğ‘“ âˆˆ ğ¹, let \(f^{ğ‘»(X)}\) be the operation on ğ‘‡(ğ‘‹) that maps each tuple \(ğ‘  : Ïğ‘“ â†’ ğ‘‡(ğ‘‹)\) to the formal term ğ‘“ ğ‘ ;
\item define ğ‘»(ğ‘‹) to be the algebra with universe ğ‘‡(ğ‘‹) and operations \(\{f^{ğ‘»(X)} | f âˆˆ F\}\).
\end{itemize}

\subsubsection{Free algebras}\label{free-algebras}
Fix a signature ğ‘† = (ğ¹, Ï), let ğ’¦ be a class of ğ‘†-algebras, let \(ğ‘¼ = âŸ¨ğ‘ˆ, ğ¹^{ğ‘¼}âŸ©\) be an ğ‘†-algebra, and let ğ‘‹ be a subset of ğ‘ˆ. We say that
\begin{itemize}
\item ğ‘¼ has the universal mapping property for ğ’¦ over ğ‘‹ if for every ğ‘¨ âˆˆ ğ’¦ and every function â„ : ğ‘‹ â†’ ğ´, there is a homomorphism \(h' : ğ‘¼ â†’ ğ‘¨\) that agrees with â„ on ğ‘‹;
\item ğ‘¼ is free for ğ’¦ over ğ‘‹ if it has the universal mapping property and is generated by ğ‘‹;
\item ğ‘¼ is free in ğ’¦ over ğ‘‹ if it is free for ğ’¦ over ğ‘‹ and belongs to ğ’¦.
\end{itemize}
We use the next definition to take a free algebra \emph{for} a class ğ’¦ and produce the free algebra \emph{in} ğ’¦. Let ğ’¦ be a class of ğ‘†-algebras and ğ‘¨ an ğ‘†-algebra. Define \(Ïˆ(ğ’¦, ğ‘¨) := \{Î¸ âˆˆ Con ğ‘¨ : ğ‘¨/Î¸ âˆˆ S(ğ’¦)\}\) and \(Î¨(ğ’¦, ğ‘¨) := â‹€ Ïˆ(ğ’¦, ğ‘¨)\). Notice that \(Ïˆ(ğ’¦, ğ‘¨)\) may be empty, in which case \(Î¨(ğ’¦, ğ‘¨) = 1_A\) and \(ğ‘¨/Î¨(ğ’¦, ğ‘¨)\) is trivial.

The free algebra is constructed using the above definitions for the special case in which ğ‘¨ is the algebra ğ‘»(ğ‘‹) of ğ‘†-terms over ğ‘‹. Since ğ‘»(ğ‘‹) is free for the class ğ“š(ğ‘†) of all ğ‘†-algebras, it follows that ğ‘»(ğ‘‹) is free for every subclass ğ’¦ of ğ“š(ğ‘†). Of course, ğ‘»(ğ‘‹) is not necessarily a member of ğ’¦, but we can form the quotient of ğ‘»(ğ‘‹) modulo the congruence Î¨(ğ’¦, ğ‘»(ğ‘‹)), which we denote by \(ğ”½(ğ’¦, ğ‘‹) := ğ‘»(ğ‘‹)/Î¨(ğ’¦, ğ‘»(ğ‘‹))\). The algebra ğ”½(ğ’¦, ğ‘‹) is called the \textbf{free algebra over} ğ’¦ \textbf{generated by} ğ‘‹. It should be clear that ğ”½(ğ’¦, ğ‘‹) is a subdirect product of the algebras \{ğ‘»(ğ‘‹)/Î¸\}, where Î¸ ranges over Ïˆ(ğ’¦, ğ‘»(ğ‘‹))\}, so it belongs to SP(ğ’¦). Therefore, we say that ğ”½(ğ’¦, ğ‘‹) is free \emph{in} SP(ğ’¦).

We formalize the free algebra in Section XX. %the free algebra in agda.

\subsection{Arity}\label{arity}
We denote and define the set \(X := \{x_0,x_1,\dots \}\) of variable symbols, and for each natural number \(n\) we let \(X_n:=\{x_0,x_1,\dots, x_{n-1}\}\).

Let ğ‘† = (ğ¹, Ï) be a signature, ğ‘¨ an ğ‘†-algebra, and ğ‘»(X) the term algebra over ğ‘‹; that is,
\[ğ‘¨ := âŸ¨A, F^{ğ‘¨}âŸ© \quad \text{ and } \quad ğ‘»(X) := âŸ¨T(X), F^{ğ‘»(X)}âŸ©.\]
Each operation symbol ğ‘“ âˆˆ ğ¹ gives rise to
\begin{itemize}
\item a Ïğ‘“-ary operation on ğ‘‡(ğ‘‹), denoted by \(f^{ğ‘»(X)}\), which maps each tuple \(ğ‘  : Ïğ‘“ â†’ ğ‘‡(ğ‘‹)\) to the formal term ğ‘“ ğ‘  in ğ‘‡(ğ‘‹), and
\item a Ïğ‘“-ary operation on ğ´, denoted by \(f^{ğ‘¨}\), which maps each tuple \(ğ‘ : Ïğ‘“ â†’ ğ´\) to the element \(f^{ğ‘¨} \,a\) in ğ´. The operation \(f^{ğ‘¨}\) is called the \textbf{interpretation of} ğ‘“ \textbf{in the algebra} \(ğ‘¨\).
\end{itemize}

\begin{comment}
\subsubsection{Essential arity}\label{essential-arity}
The definition of arity of an operation or term is a bit nuanced as the next example demonstrates.
\textbf{Example}.
\begin{quote}
Suppose ğ‘“ is a binary term, and ğ‘ and ğ‘ are ternary terms. What is the arity of the following term?
\[ğ‘¡(ğ‘¢, ğ‘£, ğ‘¤, ğ‘¥, ğ‘¦, ğ‘§) = ğ‘“(ğ‘(ğ‘¥, ğ‘¦, ğ‘§), ğ‘“(ğ‘¤, ğ‘¥), ğ‘(ğ‘¢, ğ‘£, ğ‘¤))\]
On the face of it, it seems safe to say that ğ‘¡ has arity 6, since it is expressible as a function of 6 variables.

But what if we decided to throw in some useless (or ``dummy'') variables, like so,
\[t'(ğ‘¢', ğ‘£', ğ‘¢, ğ‘£, ğ‘¤, ğ‘¥, ğ‘¦, ğ‘§, ğ‘§') = ğ‘“(ğ‘(ğ‘¥, ğ‘¦, ğ‘§), ğ‘“(ğ‘¤, ğ‘¥), ğ‘(ğ‘¢, ğ‘£, ğ‘¤))?\]

And what happens if \(ğ‘(ğ‘¥, ğ‘¦, ğ‘§) = ğ‘§\), so that ğ‘ depends on just one of its arguments? Then we could replace it with \(ğ‘'(ğ‘§) = ğ‘(ğ‘¥, ğ‘¦, ğ‘§)\), and ğ‘¡ could be expressed as,
\[ğ‘¡''(ğ‘¢, ğ‘£, ğ‘¤, ğ‘¥, ğ‘§) = ğ‘“(ğ‘'(ğ‘§), ğ‘“(ğ‘¤, ğ‘¥), ğ‘(ğ‘¢, ğ‘£, ğ‘¤))).\]

The respective arities of \(ğ‘¡, ğ‘¡'\) and \(ğ‘¡''\) are 6, 9, and 5, yet arity1--arity3 merely give three different ways to present the term \(ğ‘“(ğ‘(ğ‘¥, ğ‘¦, ğ‘§), ğ‘“(ğ‘¤, ğ‘¥), ğ‘(ğ‘¢, ğ‘£, ğ‘¤))\).
\end{quote}

As the example demonstrates, the notion of arity of a term is not uniquely defined (modulo equivalence of terms). As such, it is sometimes useful to speak of the \textbf{essential arity} of a term, which is defined to be the minimum number of variables required to express that term; it should be clear that this is equal to the number of arguments
with respect to which the term is not constant.
\textbf{Example}.
\begin{quote} It is impossible to know the essential arity of a term until we know
that of each of its subterms. Picking up where we left off in the previous example, suppose ğ‘“ depends on both of its arguments and \(ğ‘(ğ‘¢, ğ‘£, ğ‘¤) = ğ‘“(ğ‘£, ğ‘¤)\). Then ğ‘¡ is expressible as
\[s(ğ‘£, ğ‘¤, ğ‘¥, ğ‘§) = ğ‘“(ğ‘'(ğ‘§), ğ‘“(ğ‘¤, ğ‘¥), ğ‘“(ğ‘£, ğ‘¤))\]
and we finally see the lower bound on the number of variables required to express ğ‘¡, namely 4. Therefore, ğ‘¡ has essential arity 4.
\end{quote}
\end{comment}

\subsection{Term Operations}\label{term-operations}
In terms we defined a term in a given signature. When we interpret such a term in a particular algebraic structure, we get what is known as a term operation. In this section we explain how one defines the interpretation of an ğ‘†-term in an ğ‘†-algebra, and thus how one obtains a term \emph{operation}.

%% As usual, for each 0 \textless{} ğ‘› \textless{} Ï‰ we identify the ğ‘›-tuple \((x_0, x_1, \dots, x_{n-1})\) with the function \(x:  ğ‘› â†’ X_n\) defined by \(x\, i = x_i\) (0 â‰¤ ğ‘– \textless{} ğ‘›).

Recall, a term ğ‘¡ is either a variable, say, ğ‘¡ = ğ‘¥, or has the form ğ‘¡ = ğ‘“ ğ‘  for some operation symbol ğ‘“ âˆˆ ğ¹, and some Ïğ‘“-tuple ğ‘  : Ïğ‘“ â†’ ğ‘‡(ğ‘‹) of terms.

Let ğ‘¡ âˆˆ ğ‘‡(ğ‘‹) be an ğ‘†-term. Given an arbitrary ğ‘†-algebra ğ‘¨, we will define a \textbf{term operation} on ğ‘¨ by giving ğ‘¡ an \emph{interpretation} in ğ‘¨. Diverging from standard notation slightly, we will denote this operation by ğ‘¡ Ì‡ ğ‘¨ for reasons that will hopefully be clear when (in interpretation) we define term operations in Agda. Similarly, ğ‘¡ Ì‡ ğ‘© will denote the interpretation of the term ğ‘¡ in the algebra ğ‘©.

The \textbf{term operation} ğ‘¡ Ì‡ ğ‘¨ is defined by recursion on the height âˆ£ğ‘¡âˆ£ of ğ‘¡ as follows: for each assignment ğ‘ : ğ‘‹ â†’ ğ´ (of values in ğ´ to variables in ğ‘‹),
\begin{itemize}
\item (âˆ£ğ‘¡âˆ£ = 0) if ğ‘¡ is the variable ğ‘¥, then (ğ‘¡ Ì‡ ğ‘¨) ğ‘ = ğ‘ ğ‘¥,
\item (âˆ£ğ‘¡âˆ£ = ğ‘›+1) if ğ‘¡ = ğ‘“ ğ‘  where ğ‘“ is an operation symbol and ğ‘  : Ïğ‘“ â†’ ğ‘‡(X) is a tuple of terms whose heights are at most ğ‘› (i.e., âˆ€ ğ‘–, âˆ£ğ‘  ğ‘–âˆ£ â‰¤ ğ‘›), then ğ‘¡ Ì‡ ğ‘¨ = \(f^{ğ‘¨} \, s^{ğ‘¨}\).
\end{itemize}

\subsection{Models and theories}\label{models-and-theories}
Let ğ‘† = (ğ¹, Ï) be a signature and \(X := \{x_0, x_1, \dots\}\) a countable collection of variable symbols.

An \textbf{identity in the signature} ğ‘† (or ``ğ‘†-identity'') is an ordered pair of terms (ğ‘, ğ‘) âˆˆ ğ‘‡(ğ‘‹) Ã— ğ‘‡(ğ‘‹). We usually write ğ‘ â‰ˆ ğ‘ to indicate such an identity. Although, when we have a collection of identities, say, Î£, we could indicate that ğ‘ â‰ˆ ğ‘ is among the identities in Î£ by writing (ğ‘, ğ‘) âˆˆ Î£. We sometimes refer to an identity as an \textbf{equation}; for us, the words ``identity'' and ``equation'' are synonyms.

Let ğ“š(ğ‘†) and ğ“”(ğ‘†) denote the classes of all ğ‘†-algebras and ğ‘†-identities, respectively. For \(ğ‘¨ âˆˆ ğ’¦ âŠ† ğ“š(ğ‘†)\) and \((ğ‘, ğ‘) âˆˆ â„° âŠ† ğ“”(ğ‘†)\), we say that
\begin{itemize}
\item ğ‘¨ \textbf{models} ğ‘ â‰ˆ ğ‘, denoted ğ‘¨ âŠ§ ğ‘ â‰ˆ ğ‘, just in case ğ‘ Ì‡ ğ‘¨ = ğ‘ Ì‡ ğ‘¨ extensionally (i.e., âˆ€ ğ‘ : ğ‘‹ â†’ ğ´, (ğ‘ Ì‡ ğ‘¨) ğ‘ = (ğ‘ Ì‡ ğ‘¨) ğ‘);
\item ğ‘¨ \textbf{models} â„°, denoted ğ‘¨ âŠ§ â„°, just in case ğ‘¨ âŠ§ ğ‘ â‰ˆ ğ‘ holds for every (ğ‘, ğ‘) âˆˆ â„°;
\item ğ’¦ \textbf{models} ğ‘ â‰ˆ ğ‘ just in case ğ‘¨ âŠ§ ğ‘ â‰ˆ ğ‘ holds for every ğ‘¨ in ğ’¦;
\item ğ’¦ \textbf{models} â„° just in case ğ‘¨ âŠ§ â„° for every ğ‘¨ âˆˆ ğ’¦.
\end{itemize}

\noindent \textbf{Notation}. To produce the symbols â‰ˆ and âŠ§ in Emacs \texttt{agda2-mode}, type \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}} and \texttt{\textbackslash{}models} (resp.). To denote ``ğ’¦ models ğ‘ â‰ˆ ğ‘'' we will use ğ’¦ âŠ§ ğ‘ â‰‹ ğ‘ instead of the more standard ğ’¦ âŠ§ ğ‘ â‰ˆ ğ‘ because we distinguish it from ğ‘¨ âŠ§ ğ‘ â‰ˆ ğ‘ in our Agda implementation. The symbol â‰‹ is produced in Emacs \texttt{agda2-mode} with \texttt{\textbackslash{}\textasciitilde{}\textasciitilde{}\textasciitilde{}}.

The binary relation \(âŠ§\) induces an obvious Galois connection. Indeed, the Galois pair (Mod, Th) is defined as follows: for all â„° âŠ† ğ“”(ğ‘†) and ğ’¦ âŠ† ğ“š(ğ‘†),
\begin{align*}
\mathrm{Mod} â„° &:= \{ ğ‘¨ âˆˆ ğ“š(ğ‘†) : ğ‘¨ âŠ§ â„° \}, \text{ and }\\
\mathrm{Th} ğ’¦ &:= \{â„¯ âˆˆ ğ“”(ğ‘†) : ğ’¦ âŠ§ â„¯ \}.
\end{align*}

The first of these, the class of \textbf{models} of â„°, contains those and only those algebras modeling every identity in â„°. It is called an \textbf{equational class}, and â„° is called an \textbf{equational base} for, or an \textbf{axiomatization} of, the class. Dually, Th ğ’¦ is the class of identities modeled by every algebra in ğ’¦. Such a class of identities is called an \textbf{equational theory}.

Alternatively and equivalently we could define ``equational class'' and ``equational theory'' in terms of the two
closure operators \textless{}closure operator\textgreater{} induced by the Galois pair (Mod, Th). Indeed, Mod Th : ğ’« ğ“š(ğ‘†) â†’ ğ’« ğ“š(ğ‘†) is a closure operator on ğ“š(ğ‘†) and Th Mod : ğ’« ğ“”(ğ‘†) â†’ ğ’« ğ“”(ğ‘†) is a closure operator on ğ“”(ğ‘†), and

\begin{itemize}
\item an \textbf{equational class} is a Mod Th-closed class \textless{}closed set\textgreater{} of ğ‘†-algebras;
\item an \textbf{equational theory} is a Th Mod-closed set of ğ‘†-identities
\end{itemize}
(Here, ğ’« denotes the powerset functor.)

\noindent \textbf{N.B.} An equational class is sometimes referred to as a \textbf{variety}; this is because of the celebrated Birkhoff theorem which states that a class of algebraic structures is an equational class if and only if it is closed under the taking of homomorphic images (H), subalgebras (S), and products (P). A formal Agda proof of Birkhoff's theorem is one of our main goals which we achieve in the \birkhoffmodule described in Section XX.

\subsection{Basic facts}\label{basic-facts}
We conclude this chapter with a list of basic facts and their (informal) proofs. These results are classical, straightforward consequences of the definitions above. We will need them below and when we cite them later, we will refer to them as, e.g, Obs 1, Obs 2, etc. Each of these observations is formalized in Agda in the \agdaualib.

Throughout this section, \(ğ‘¨ = âŸ¨A, F^{ğ‘¨}âŸ©, \ ğ‘© = âŸ¨B, F^{ğ‘©}âŸ©, \ ğ‘ª = âŸ¨C, F^{ğ‘ª}âŸ©\ \) are algebras in the same signature ğ‘† = (ğ¹, Ï).

\subsubsection{Equalizers}\label{equalizers}
We start with the simple observation that equalizers of homomorphisms are subuniverses. The Agda formalization of this result and its proof is presented in obs 1 in agda.

\subsubsection{Homomorphisms}\label{homomorphisms-1}
Another easy fact is that composing homomorphisms results in a homomorphism. The easy proof of this fact is formalized in obs 2 in agda .

Another elementary result is that homomorphisms are uniquely determined by the values they take on generating sets. Our Agda proof of Obs \%s \textless{}obs 3\textgreater{} is called
\texttt{HomUnique}. It is presented obs 3 in agda.

%A corollary of the last result is an easily proved bound on the cardinality of \(|\mathrm{Hom}(ğ‘¨, ğ‘©)|\).

Here is an elementary result about factorability of homomorphisms. The informal proof is presented below and its formalization in obs 5 in agda.

We formalize Obs \%s \textless{}obs 5\textgreater{} in the \homomorphismsmodule of the \agdaualib; see obs 5 in agda.

Next we observe that the intersection of subuniverses is again a subuniverse, a fact that we prove formally in the \subuniversesmodule of the \agdaualib; see obs 6 in agda.

Next is a theorem that provides a means of generating subuniverses recursively.

We formally implement the concept of subalgebra in the \subuniversesmodule of the \agdaualib, which we describe in subuniverses in agda. In particular, we describe the formalization of Obs 7 in Section XX. %obs 7.1 in agda.

Our formalization of Obs 7.1 is presented in Section XX. %obs 7.1 in agda.

We implement terms and the term algebra in Agda in the \termsmodule, as described in terms. Also in the \termsmodule is a formal proof of the next result; see Section XX. %obs 9 in agda.

Let ğ’¦ be the class of ğ‘†-algebras. Then Obs 9 can be restated as: ğ‘»(ğ‘‹) is free in ğ’¦ over ğ‘‹. This is sometimes expressed by saying that ğ‘»(ğ‘‹) is \textbf{absolutely free} over ğ‘‹.

It follows from Obs 9.2 that, up to isomorphism, a free algebra is determined by the cardinality of a free generating set.

Next we observe that freeness extends from a class ğ’¦ to the variety it generates.

As Bergman notes (see the remark after Def 4.29 in~\cite{Bergman:2012}), ``strictly speaking, ğ‘‹ is not a subset of ğ”½(ğ’¦, X), so it doesn't make sense to talk about ğ‘‹ generating ğ”½(ğ’¦, X), [but] as long as ğ’¦ contains a nontrivial algebra, \(Î¨(ğ’¦, ğ‘‹) âˆ© ğ‘‹Â² = 0_X\). In light of Obs 9.2, we can identify ğ‘‹ with ğ‘‹/Î¨(ğ’¦, ğ‘‹) in ğ”½(ğ’¦, ğ‘‹). All of these considerations are accounted for in the following corollary.''

In the next observation, assume ğ‘¨ = \(âŸ¨A, F^{ğ‘¨}âŸ©\) and ğ‘© = \(âŸ¨B, F^{ğ‘©}âŸ©\) are ğ‘†-algebras , and let ğ‘¡ âˆˆ ğ‘‡(ğ‘‹) be a term in the language of ğ‘†. In particular, as explained in term operations, ğ‘¡ has an interpretation in ğ‘¨, which (for reasons that will become clear when we define term operations in Agda) we will denote by ğ‘¡ Ì‡ ğ‘¨ and we call a \textbf{term operation}. Similarly, \(t^{ğ‘©}\) is the interpretation of ğ‘¡ in ğ‘©.

We formalize Obs 10 and its proof in the \termsmodule of the \agdaualib, as described in Section XX. %obs 10 in agda.

We formalize Obs 11 and its proof in the \termsmodule of the \agdaualib, as described in Section XX. %obs 11 in agda.

We formalize Obs12 and its proof in the \subuniversesmodule of the \agdaualib, as described in Section XX. %obs 12 in agda.

%% \emph{Proof}.
%% We prove the result for H(ğ’¦). ğ’¦ âŠ† H(ğ’¦), so Th H (ğ’¦) âŠ† Th ğ’¦ â€¦

We present a formalization of this result and its proof in Section XX. %obs 13 in agda.

We formalize Obs 14 and its proof in the \birkhoffmodule of the \agdaualib, as described in Section XX. %obs 14 in agda.

The last result tells us that we can determine whether an identity is true in a variety ğ’± by consulting a particular algebra, namely ğ”½(ğ’±, ğ‘‹), the free algebra in ğ’±.

\subsection{Birkhoff's theorem}\label{birkhoffs-theorem}
It follows from Obs 13 that every equational class is a variety. The converse is the celebrated HSP Theorem of Birkhoff.

\noindent \textbf{Theorem}~\cite{Birkhoff:1935}. Every class of algebraic structures that is closed under the taking of homomorphisms, subalgebras, and arbitrary products is an equational class.

In other terms, if a class ğ’¦ of algebras is closed under H, S, P, then there exists a set â„° of identities such that ğ’¦ is the class of all algebras that model â„°.

%% The statement and proof we give here is essentially the same as that given in Theorem 4.41 of Cliff Bergman's textbook~\cite{Bergman:2012}. It is this statement and proof that we will formalize in Agda in the \href{https://gitlab.com/ualib/ualib.gitlab.io/-/blob/master/birkhoff.lagda.rst}{birkhoff module} of the \agdaualib; see birkhoffs theorem in agda.

\section{Algebras in Agda}
This chapter describes the basic module of the agda-ualib, which begins our Agda formalization of the basic concepts and theorems of universal algebra. In this module we will codify such notions as operation, signature, and algebraic structure.

\subsection{Preliminaries}
Like most Agda programs, this one begins with some Agda options specifying the foundational choices we wish to make, as explained above.

\begin{code}%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
\>[0]\<%
\end{code}
We begin the basic module by invoking Agda's module directive, and then we import some dependencies that we make public so they are available to all modules that import the basic module.
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{basic}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%% \AgdaGeneralizable{ğ“£}\AgdaSymbol{;}\AgdaSpace{}%
%% \AgdaPrimitive{ğ“¤â‚€}\AgdaSymbol{;}
%\AgdaGeneralizable{ğ“˜}\AgdaSymbol{;}\AgdaSpace{}%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{prelude}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{Universe}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ğ“}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¦}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ğ“§}\AgdaSymbol{;}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPrimitive{\AgdaUnderscore{}âº}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}Ì‡}}\AgdaSymbol{;}\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}âŠ”\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{Î£}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{-Î£}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£\AgdaUnderscore{}âˆ£}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ¥\AgdaUnderscore{}âˆ¥}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ğŸ˜}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ğŸš}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}Ã—\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Î }\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}â‰¡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSymbol{)}\AgdaSpace{}\<%
%\AgdaKeyword{public}
\end{code}
This is the second module of the agda-ualib, coming after the \preludemodule described in the previous chapter.

\subsection{Operation type}

We define the type of \textbf{operations}, and give an example (the projections).

\begin{code}%
\>[0]\AgdaComment{--The type of operations}\<%
\\
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{--Example. the projections}\<%
\\
\>[0]\AgdaFunction{Ï€}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{Ï€}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\<%
\end{code}
The type Op encodes the arity of an operation as an arbitrary type \ab ğ¼ : \ab ğ“¥ Ì‡, yielding a completely general representation of an operation as a function type with domain \ab ğ¼ â†’ \ab ğ´ (heuristically, the type of ``tuples of length~|~\ab ğ¼~|'') and codomain \ab ğ´. The last two lines of the code block above codify the ğ‘–-th~|~\ab ğ¼~|-ary projection operation on \ab ğ´.

\subsection{Signature type}
We define the signature of an algebraic structure in Agda as follows:
\begin{code}%
\>[0]\AgdaComment{-- ğ“: level at which operation symbol types live}\<%
\\
\>[0]\AgdaComment{-- ğ“¥: level at which arity types live}\<%
\\
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âº}}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âº}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Î£}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{ê‰}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}%
\>[27]\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}
The \preludemodule of \agdaualib defines the syntax âˆ£\_âˆ£ and âˆ¥\_âˆ¥ for the first and second projections, resp.  Consequently, if ğ‘†~:~\signatureOV is a signature, then âˆ£ ğ‘† âˆ£ denotes the set of operation symbols (which is often called ğ¹), and âˆ¥~ğ‘†~âˆ¥ denotes the arity function (which is often called Ï). Thus, if  ğ‘“~:~âˆ£~ğ‘†~âˆ£ is an operation symbol in the signature ğ‘†, then âˆ¥~ğ‘†~âˆ¥~ğ‘“ is the arity of ğ‘“.

\subsection{Algebra type}
Finally, we are ready to define the type of algebras in the signature ğ‘†, also known as ğ‘†-\textbf{algebras}.
\begin{code}%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[98I]\AgdaSymbol{(}\AgdaBound{ğ“¤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)\{}\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[98I]%
\>[10]\AgdaSymbol{(}\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}%
\>[33]\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaBound{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âº}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaBound{ğ“¤}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ğ“}\AgdaSymbol{\}\{}\AgdaBound{ğ“¥}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}\<%
\\
\>[.][@{}l@{}]\<[98I]%
\>[10]
\AgdaFunction{Î£}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{ê‰}\AgdaSpace{}%
\AgdaBound{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{ğ‘“}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Op}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{âˆ¥}}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ¥}}\AgdaSpace{}%
\AgdaBound{ğ‘“}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\end{code}
Thus, ğ‘†-algebras with carrier types in the \AgdaBound{ğ“¤} inhabit the type \algebraUS.  (Notice that we are allowed to leave off the implicits \AgdaBound{ğ“}\AgdaBound{ğ“¥} if they can be inferred from the context.) In other words, \emph{the type} \algebraUS \emph{collects all the algebras of a particular signature ğ‘† and carrier type \ab ğ“¤, and this collection of algebras has type} \ab ğ“ âŠ” \ab ğ“¥ âŠ”  \ab ğ“¤ âº Ì‡.\footnote{Recall, \ab ğ“ âŠ” \ab ğ“¥ âŠ”  \ab ğ“¤ âº denotes the smallest universe containing \ab ğ“, \ab ğ“¥, and the successor of \ab ğ“¤.}

The type \algebraUS doesn't define what an algebra \emph{is}. It defines a type of algebras; certain algebras inhabit this type---namely, the algebras consisting of a universe (say, ğ´) of type \ab ğ“¤ Ì‡ , and a collection (ğ‘“ : âˆ£ ğ‘† âˆ£) â†’ Op (âˆ¥ ğ‘† âˆ¥ ğ‘“) ğ´ of operations on ğ´.

Alternatively, we could have defined algebras in the following equivalent way:\\
\\
  Algebra ğ“¤ (F , Ï) = Î£ A ê‰ ğ“¤ Ì‡ ,  ((ğ‘“ : F )  â†’ Op (Ï ğ‘“) A )\\
\\
Here ğ‘† = (F , Ï) is the signature, F the type of operation symbols, and Ï the arity function. Although this syntax type checks, and although it may seem more familiar to algebraists, we mention it here merely to demonstrate the flexibility of Agda; throughout the library we adhere to ğ‘“~:~âˆ£~ğ‘†~âˆ£ for an operation symbol of the signature ğ‘†, and âˆ¥~ğ‘†~âˆ¥~ğ‘“ for the arity of that symbol, as these are slightly more convenient for programming.

\subsubsection{Example}
A monoid signature has two operation symbols, \AgdaInductiveConstructor{e} and \AgdaInductiveConstructor{Â·}; the first is nullary and the second binary. Thus, the types are (ğŸ˜ â†’ A) â†’ A and (ğŸš â†’ A) â†’ A), respectively.
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{ğ“¤â‚€}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\>[1]\AgdaInductiveConstructor{Â·}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaFunction{monoid-sig}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{monoid-op}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{e}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{ğŸ˜}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{Â·}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{ğŸš}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
The types indicate that e is nullary (i.e., takes no arguments, equivalently, takes arguments of type ğŸ˜ â†’ A), while Â· is binary (as indicated  by argument type ğŸš â†’ A).

We will have more to say about the type of algebras later.  For now, we continue defining the syntax used in the \agdaualib to represent the basic objects of universal algebra.

\subsubsection{Syntactic sugar for operation interpretation}
Before proceding, we define syntax that allows us to replace âˆ¥~ğ‘¨~âˆ¥~ğ‘“ with ğ‘“ Ì‚ ğ‘¨. The latter is a metaphor for \(f^\mathbf{A}\), which is the universally accepted way to denote an operation symbol ğ‘“ interpreted in the algebra ğ‘¨.
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Signature}\AgdaSpace{}%
\AgdaGeneralizable{ğ“}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSymbol{\}}%
\>[30]\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}Ì‚\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ğ‘“}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSymbol{)}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{â†’}%
\>[6]\AgdaSymbol{(}\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{â†’}%
\>[6]\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{âˆ¥}}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ¥}}\AgdaSpace{}%
\AgdaBound{ğ‘“}%
\>[16]\AgdaSymbol{â†’}%
\>[19]\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaBound{ğ‘“}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‚}}\AgdaSpace{}%
\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{âˆ¥}}\AgdaSpace{}%
\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ¥}}\AgdaSpace{}%
\AgdaBound{ğ‘“}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{40}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}Ì‚\AgdaUnderscore{}}}\<%
\end{code}
Thus, throughout the \agdaualib, we use ğ‘“ Ì‚ ğ‘¨ to denote the interpretation of the basic operation symbol ğ‘“ in the algebra ğ‘¨ (although we use slightly different notation, ğ‘¡ Ì‡ ğ‘¨, to represent the interpretation of a \emph{term} ğ‘¡ in the algebra ğ‘¨).

\subsection{Products of algebras}

The (indexed) product of a collection of algebras is also an algebra if we define such a product as follows:

\begin{code}%
%
\>[1]\AgdaFunction{â¨…}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“˜}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}(}\AgdaBound{ğ’œ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“˜}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ğ‘†}\<%
\\
%
\>[1]\AgdaFunction{â¨…}\AgdaSpace{}%
\AgdaBound{ğ’œ}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[8]\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ’œ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}%
\>[31]\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaBound{ğ‘“}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ğ‘“}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‚}}\AgdaSpace{}%
\AgdaBound{ğ’œ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{ğ“¥}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[1]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{-1}\AgdaSpace{}%
\AgdaFunction{â¨…}\<%
\end{code}
(In agda2-mode â¨… is typed as \textbackslash Glb.)

\subsection{Arbitrarily many variable symbols}

Finally, since we typically want to assume that we have an arbitrary large collection X of variable symbols at our disposal (so that, in particular, given an algebra ğ‘¨ we can always find a surjective map hâ‚€ : X â†’ âˆ£ ğ‘¨ âˆ£ from X to the universe of ğ‘¨), we define a type for use when making this assumption.

\begin{code}%
%
\>[1]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}â† \AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“§}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“§}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
%
\>[1]\AgdaBound{X}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{â† }}\AgdaSpace{}%
\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Î£}\AgdaSpace{}%
\AgdaBound{h}\AgdaSpace{}%
\AgdaFunction{ê‰}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Epic}\AgdaSpace{}%
\AgdaBound{h}\<%
\end{code}



%% \input{prelude.tex}
%% \input{basic.tex}
\section{Congruences in Agda}\label{congruences-in-agda}
This section describes the \congruencesmodule of the \agdaualib.
%% , although we don't discuss parts of that module which duplicate functionality of the \href{https://agda.github.io/agda-stdlib/}{Agda standard library} (\texttt{Binary/Core.agda}).

\subsection{Preliminaries}\label{preliminaries}
\begin{code}
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{basic}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{congruences}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{prelude}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{ğ“¡}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¢}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{is-prop}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ğŸ™}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}â‰¡âŸ¨\AgdaUnderscore{}âŸ©\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}âˆ}}\AgdaSymbol{;}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaInductiveConstructor{refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}â»Â¹}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{funext}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{ap}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}âˆ™\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{ğ“‡â„¯ğ’»ğ“}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{public}
\end{code}

\subsection{Binary relation type}\label{binary-relation-type}
Heterogeneous binary relations.

\begin{code}%
\>[0]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âº}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\end{code}

Homogeneous binary relations.
\begin{code}%
\>[0]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âº}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ğ“}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{REL}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{ğ“}\<%
\end{code}

\subsubsection{Kernels}\label{kernels}
The kernel of a function can be defined in many ways. For example,
\begin{code} \input{congruences/KER.tex} \end{code}
or as a relation\ldots{}
\begin{code} \input{congruences/KER-rel.tex} \end{code}
or a binary predicate â€¦
\begin{code}\input{congruences/KER-pred.tex}\end{code}

\subsubsection{Implication}\label{implication}
We denote and define implication or containment (which could also be
written \_âŠ†\_) as follows.
\begin{code}\input{congruences/implication.tex}\end{code}
Here is a more general version of implication.
\begin{code}\input{congruences/generalImplication.tex}\end{code}

\subsubsection{Properties of binary relations}\label{properties-of-binary-relations}

Reflexivity of a binary relation (say, \texttt{â‰ˆ}) on \texttt{X}, can be
defined without an underlying equality as follows.

\begin{code}
\>[0]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{âˆ€}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{â‰ˆ}}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}

Similarly, we have the usual notion of symmetric (resp., transitive) binary relation.

\begin{code}
\>[0]\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{âˆ€}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{â‰ˆ}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{â‰ˆ}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{âˆ€}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{â‰ˆ}}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{â‰ˆ}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{â‰ˆ}}\AgdaSpace{}%
\AgdaBound{z}\<%
\end{code}

For a binary relation â‰ˆ on A, denote a single â‰ˆ-class (containing a) by {[} a {]} â‰ˆ,

\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{[\AgdaUnderscore{}]\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[8]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}%
\>[22]\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{[}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaBound{â‰ˆ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Î£}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{ê‰}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaFunction{,}%
\>[21]\AgdaBound{â‰ˆ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}
and denote the collection of all â‰ˆ-classes of A by A // â‰ˆ.

\begin{code}\input{congruences/relationClasses.tex}\end{code}

The ``trivial'' or ``diagonal'' or ``identity'' relation is,

\begin{code}
\>[0]\AgdaFunction{ğŸ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{ğŸ}\AgdaSymbol{\{}\AgdaBound{ğ“¤}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Î£}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaFunction{ê‰}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaFunction{Î£}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaFunction{ê‰}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{â‰¡}}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ğŸ-rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\<%
\\
\>[0]\AgdaFunction{ğŸ-rel}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{â‰¡}}\AgdaSpace{}%
\AgdaBound{b}\<%
\end{code}

or, in various other guises,

\begin{code}
\>[0]\AgdaFunction{ğŸ-pred}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ã—}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\<%
\\
\>[0]\AgdaFunction{ğŸ-pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{a'}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{â‰¡}}\AgdaSpace{}%
\AgdaBound{a'}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{--...as a binary predicate:}\<%
\\
\>[0]\AgdaFunction{ğŸ''}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{ğŸ''}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ğ“¤}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Î£}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{ê‰}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ã—}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{,}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{â‰¡}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ¥}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ¥}}\<%
\end{code}

The ``universal'' or ``total'' or ``all'' relation.

\begin{code}\>[0]\AgdaFunction{ğŸ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaPrimitive{ğ“¤â‚€}\<%
\\
\>[0]\AgdaFunction{ğŸ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{ğŸ™}\<%
\end{code}

\subsection{Types for equivalences}\label{types-for-equivalences}
Here are two ways to define an equivalence relation in Agda. The first uses a record.

\begin{code}\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ğ“¤}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Universe}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaBound{ğ“¡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{rfl}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaField{sym}%
\>[10]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaField{trans}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\<%
\end{code}

Here's an alternative.

\begin{code}\>[0]\AgdaFunction{is-equivalence-relation}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¡}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{is-equivalence-relation}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaFunction{is-subsingleton-valued}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\<%
\\
\>[1][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaFunction{Ã—}}\AgdaSpace{}%
\AgdaFunction{reflexive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ã—}}\AgdaSpace{}%
\AgdaFunction{symmetric}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ã—}}\AgdaSpace{}%
\AgdaFunction{transitive}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}â‰ˆ\AgdaUnderscore{}}}\<%
\end{code}

Of course, ğŸ is an equivalence relation, a fact we can prove as follows.

\begin{code}\>[0]\AgdaFunction{ğŸ-IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaRecord{IsEquivalence}\AgdaSymbol{\{}\AgdaArgument{ğ“¤}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSymbol{\}\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaFunction{ğŸ-rel}\<%
\\
\>[0]\AgdaFunction{ğŸ-IsEquivalence}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}%
\>[740I]\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{rfl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaInductiveConstructor{ğ“‡â„¯ğ’»ğ“}\<%
\\
\>[.][@{}l@{}]\<[740I]%
\>[25]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{sym}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{xâ‰¡y}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{xâ‰¡y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{â»Â¹}}\<%
\\
%
\>[25]\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{trans}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaBound{xâ‰¡y}\AgdaSpace{}%
\AgdaBound{yâ‰¡z}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{xâ‰¡y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ™}}\AgdaSpace{}%
\AgdaBound{yâ‰¡z}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\end{code}
We define the \textbf{lift} of a binary relation from pairs to pairs of
tuples as follows:

\begin{code}\>[0]\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Î³}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaSymbol{â†’}%
\>[11]\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¦}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Î³}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Î³}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)}\<%
\\
%
\>[1]\AgdaSymbol{â†’}%
\>[11]\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¦}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{âˆ€}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\end{code}

We define \textbf{compatibility} of a given function-relation pair as follows:

\begin{code}\>[0]\AgdaFunction{compatible-fun}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[806I]\AgdaSymbol{\{}\AgdaBound{Î³}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[.][@{}l@{}]\<[806I]%
\>[17]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Î³}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSymbol{)(}\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Rel}\AgdaSpace{}%
\AgdaBound{Z}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¦}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[1]\AgdaSymbol{â†’}%
\>[17]\AgdaGeneralizable{ğ“¥}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{âŠ”}}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¦}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{Ì‡}}\<%
\\
\>[0]\AgdaFunction{compatible-fun}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{R}%
\>[20]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{lift-rel}\AgdaSpace{}%
\AgdaBound{R}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{=[}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]â‡’}}\AgdaSpace{}%
\AgdaBound{R}\<%
\end{code}

\subsection{Types for congruences}\label{types-for-congruences}
Finally, we come to the definition of a congruence, which we define in a module so we have an ambient signature ğ‘† available.

\begin{code}\input{congruences/TypesForCongruences.tex}\end{code}

\subsubsection{The trivial congruence}\label{the-trivial-congruence}
We construct the ``trivial'' or ``diagonal'' or ``identity'' relation and prove it is a congruence as follows.
\begin{code}\input{congruences/TrivialCongruence.tex}\end{code}
\noindent (In agda2-mode one types \texttt{\textbackslash ---} and then \texttt{C-f} or the right-arrow key until the symbol â•± appears.)

We would like to round out this section with a formalization of the trivial congruence of the free algebra ğ”½(ğ’¦, ğ‘‹), which we called Î¨(ğ’¦, ğ‘»(ğ‘‹)) above. Unfortunately, this will have to wait until we have formalized the concepts of subalgebra and closure on which this congruence depends. Thus, our Agda definition of Î¨(ğ’¦, ğ‘»(ğ‘‹)) appears later, in the \closuremodule described in Section XX.

%% -----------------------------------------------------
%% \input{homomorphisms.tex}
\section{Homomorphisms in Agda}\label{homomorphisms-in-agda}
This chapter describes the \homomorphismsmodule of the \agdaualib.

\subsection{Types for homomorphisms}\label{types-for-homomorphisms}
We begin the \homomorphismsmodule by declaring a fixed signature \texttt{ğ‘†} an importing the
required dependencies.

\begin{code}\input{homomorphisms/homprelude.tex}\end{code}
%% Our implementation of the notion of homomorphisms in the \agdaualib is an extensional one. What this means will become clear once we have presented the definitions (cf. Homomorphisms intensionally \textless{}homomorphisms intensionally\textgreater{}).
Here we say what it means for an operation ğ‘“, interpreted in the algebras ğ‘¨ and ğ‘©, to commute with a function \(g : A â†’ B\).
\begin{code}\input{homomorphisms/commutes.tex}\end{code}
And now we define the type of homomorphisms.
\noindent
\begin{code}
  \input{homomorphisms/hom.tex}
\end{code}
An example of such a homomorphism is the identity map.
\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ğ’¾ğ’¹}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[6]\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Algebra}\AgdaSpace{}%
\AgdaGeneralizable{ğ“¤}\AgdaSpace{}%
\AgdaBound{ğ‘†}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaFunction{hom}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{ğ’¾ğ’¹}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(Î»}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{Î»}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaInductiveConstructor{ğ“‡â„¯ğ’»ğ“}\<%
\end{code}

\subsection{Composition}\label{composition}
As we asserted in Obs 2 above, the composition of homomorphisms is again a homomorphism.
\begin{code}\input{homomorphisms/homcomp.tex}\end{code}

\subsection{Factorization}\label{factorization}
As we saw in Obs 5 above that if ğ‘” : hom ğ‘¨ ğ‘©, if â„ : hom ğ‘¨ ğ‘ª, if â„ is surjective, and if ker â„ âŠ† ker ğ‘”, then there exists \{Ï• : hom ğ‘ª ğ‘©\} such that ğ‘” = Ï• âˆ˜ â„, that is, such that the following diagram commutes:

\begin{verbatim}
   ğ‘¨---- â„ -->>ğ‘ª
    \         .
     \       .
      ğ‘”     âˆƒÏ•
       \   .
        \ .
         V
         ğ‘©
\end{verbatim}
We now formalize the statement and proof of this basic fact. (Notice that the proof is fully constructive.)
\begin{code}\input{homomorphisms/homfactor.tex}\end{code}

\subsection{Isomorphism}\label{isomorphism}
For algebras, an isomorphism is simply a homomorphism with a trivial kernel.
\begin{code}\input{homomorphisms/iso.tex}\end{code}

\subsection{Homomorphic images}\label{homomorphic-images}
The following seem to be (for our purposes) the two most useful types for representing homomomrphic images of an algebra.
\begin{code}\input{homomorphisms/homimage.tex}\end{code}

Here are some further definitions, derived from the one above, that will come in handy later.
\begin{code}\input{homomorphisms/homimageextras.tex}\end{code}

Here ğ“›ğ“š represents a (universe-indexed) collection of classes.
\begin{code}\input{homomorphisms/hclosed.tex}\end{code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Terms in Agda}\label{terms-in-agda}
This chapter describes the \termsmodule of the \agdaualib.

\subsection{Types for terms}\label{types-for-terms}
We developed the notion of a term in a signature informally in Section XX above.
Here we formalize this concept in Agda. We start by declaring the module and importing the required
dependencies.
\begin{code}\input{terms/termsprelude.tex}\end{code}

Next, we define a datatype called \texttt{Term} which, not surprisingly, represents the type of terms. The type \ab ğ‘‹ : \ab ğ’° Ì‡ represents an arbitrary collection of ``variables.''
\begin{code}\input{terms/term.tex}\end{code}

\subsubsection{The term algebra ğ‘»(X)}\label{the-term-algebra-ux1d47bx}
The term algebra was described informally in terms. We denote this important algebra by ğ‘»(X) and we implement it in Agda as follows.
\begin{code}\input{terms/termalg.tex}\end{code}

\subsection{The universal property}\label{the-universal-property}
We prove
\begin{enumerate}
\item every map \texttt{h\ :\ ğ‘‹\ â†’\ âˆ£\ ğ‘¨\ âˆ£} lifts to a homomorphism from ğ‘»(X) to ğ‘¨, and
\item the induced homomorphism is unique.
\end{enumerate}
First, every map \texttt{X\ â†’\ âˆ£\ ğ‘¨\ âˆ£} lifts to a homomorphism.
\begin{code}\input{terms/freelift.tex}\end{code}
Next, the lift to (ğ‘» X â†’ ğ‘¨) is unique.
\begin{code}\input{terms/uniquelift.tex}\end{code}
Next we note the easy fact that the lift induced by \texttt{hâ‚€} agrees with \texttt{hâ‚€} on \texttt{X} and that the lift is surjective if the \texttt{hâ‚€} is.
\begin{code}\input{terms/liftagreement.tex}\end{code}

\subsection{Interpretation}\label{interpretation}
Let \texttt{t\ :\ Term} be a term and \texttt{ğ‘¨} an ğ‘†-algebra. We define the ğ‘›-ary operation \texttt{t\ Ì‡\ ğ‘¨} on \texttt{ğ‘¨} by structural recursion on \texttt{t}.
\begin{itemize}
\item if \texttt{t\ =\ x\ âˆˆ\ X} (a variable) and
  \texttt{a\ :\ X\ â†’\ âˆ£\ ğ‘¨\ âˆ£} is a tuple of elements of
  \texttt{âˆ£\ ğ‘¨\ âˆ£}, then \texttt{(t\ Ì‡\ ğ‘¨)\ a\ =\ a\ x}.
\item if \texttt{t\ =\ f\ args}, where \texttt{f\ âˆˆ\ âˆ£\ ğ‘†\ âˆ£} is an op
  symbol and \texttt{args\ :\ âˆ¥\ ğ‘†\ âˆ¥\ f\ â†’\ Term} is an
  (\texttt{âˆ¥\ ğ‘†\ âˆ¥\ f})-tuple of terms and \texttt{a\ :\ X\ â†’\ âˆ£\ ğ‘¨\ âˆ£}
  is a tuple from \texttt{ğ‘¨}, then
  \texttt{(t\ Ì‡\ ğ‘¨)\ a\ =\ ((f\ args)\ Ì‡\ ğ‘¨)\ a\ =\ (f\ Ì‚\ ğ‘¨)\ Î»\{\ i\ â†’\ ((args\ i)\ Ì‡\ ğ‘¨)\ a\ \}}
\end{itemize}
Here is the Agda implementation of this concept.
\begin{code}\input{terms/termalg.tex}\end{code}
Next we show that if \texttt{p\ :\ âˆ£\ ğ‘»(X)\ âˆ£} is a term, then there exists \texttt{ğ“…\ :\ âˆ£\ ğ‘»(X)\ âˆ£} and \texttt{ğ’•\ :\ X\ â†’\ âˆ£\ ğ‘»(X)\ âˆ£} such that \texttt{p\ â‰¡\ (ğ“…\ Ì‡\ ğ‘»(X))\ ğ’•}. We prove this fact in the following module:
\begin{code}\input{terms/termagreement.tex}\end{code}
Next we have some definitions that are sometimes useful when dealing
with the interpretations of terms in a product structure.
\begin{code}\input{terms/interpprod.tex}\end{code}

\subsection{Compatibility of terms}\label{compatibility-of-terms}
In this section we present the formal proof of the fact that homomorphisms commute with terms. More precisely, if ğ‘¨ and ğ‘© are ğ‘†-algebras, h : ğ‘¨ â†’ ğ‘© a homomorphism, and t a term in the language of ğ‘†, then for all a : X â†’ âˆ£ ğ‘¨ âˆ£ we have \(h (t^{ğ‘¨} a) = t^{ğ‘©} (h âˆ˜ a)\).

\subsubsection{Homomorphisms commute with terms}\label{homomorphisms-commute-with-terms}
\begin{code}\input{terms/commhom.tex}\end{code}

\subsubsection{Congruences commute with terms}\label{congruences-commute-with-terms}
Rounding out this chapter is an formal proof of the fact that terms respect congruences. More precisely, we show that for every term \texttt{t}, every \texttt{Î¸\ âˆˆ\ Con(ğ‘¨)}, and all tuples \texttt{a,\ b\ :\ ğ‘‹\ â†’\ A}, we have

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{Subalgebras in Agda}\label{subalgebras-in-agda}
This chapter describes the \subuniversesmodule of the \agdaualib. We define subuniverses and subalgebras and prove some basic facts about them.

\subsection{Preliminaries}\label{preliminaries}
The \subuniversesmodule starts, as usual, by fixing a signature ğ‘† and satisfying some dependencies.

\subsection{Types for subuniverses}\label{types-for-subuniverses}
\begin{code}\input{subuniverses/subprelude.tex}\end{code}

We begin the \subuniversesmodule with a straightforward definition of the collection of subuniverses of an algebra ğ‘¨. Since a subuniverse is a subset of the domain of ğ´, it is defined as a predicate on âˆ£~ğ‘¨~âˆ£. Thus, the collection
of subuniverses is a predicate on predicates on âˆ£~ğ‘¨~âˆ£.
\begin{code}\input{subuniverses/sub.tex}\end{code}
Before describing subuniverse generation, we will need to dispense with some more technicalities.
\begin{code}\input{subuniverses/technical.tex}\end{code}

\subsection{Subuniverse generation}\label{subuniverse-generation}
Next we formalize the important theorem about subuniverse generation that we presented above in Obs 7. Recall, if \(A = âŸ¨ğ´, â€¦âŸ©\) is an ğ‘†-algebra, if \(âˆ… â‰  ğ´â‚€ âŠ† ğ´\), and if we define by recursion the sets \(A_{n+1} = Aâ‚™ âˆª \{ f a : f âˆˆ F, a : Ï f â†’ Aâ‚™ \}\), then the subuniverse of A generated by ğ´â‚€ is \(\mathrm{Sg}^A(Aâ‚€) = â‹ƒâ‚™ Aâ‚™\).
\begin{code}\input{subuniverses/sg.tex}\end{code}

\subsection{Closure under intersection}\label{closure-under-intersection}
Recall from Obs 6 that the intersection â‹‚áµ¢ ğ´áµ¢ of a collection \{ğ´áµ¢ âˆ£ ğ´áµ¢ â‰¤ ğ‘¨\} of subuniverses of an algebra ğ‘¨ is
again a subuniverse of ğ‘¨. We formalize the statement and proof of this easy fact in Agda as follows.
\begin{code}\input{subuniverses/subintersection.tex}\end{code}

\subsubsection{Homomorphic images are subuniverses}\label{homomorphic-images-are-subuniverses}
In this subsection we show that the image of an (extensional)
homomorphism is a subuniverse. (A version for intensional homomorphisms
appears in the intensional-hom-image module, but the proof is
essentially the same.) Before implementing the result formally in Agda,
let us recall the steps of the informal proof.

Let ğ‘“ be an operation symbol, let \(b : Ï f â†’ âˆ£ B âˆ£\) be a (Ï ğ‘“)-tuple
of elements of âˆ£ ğ‘© âˆ£, and assume the image \texttt{Im\ ğ‘} of ğ‘ belongs
to the image \texttt{Image\ â„} of â„. We must show that
\(f^ğ‘© b âˆˆ Image h\). The assumption \texttt{Im\ ğ‘\ âŠ†\ Image\ â„} implies
that there is a (Ï ğ‘“)-tuple \(ğ‘ : Ï f â†’ âˆ£ ğ‘¨ âˆ£\) such that â„ âˆ˜ ğ‘ = ğ‘.
Since â„ is a homomorphism, we have
\(f^ğ‘© ğ‘  = f^ğ‘© (â„ âˆ˜ ğ‘) = â„ (f^ğ‘¨ ğ‘) âˆˆ\) Image â„.

Finally, recall the definition of \texttt{HomImage} from the \homomorphismsmodule.
%% \begin{Shaded}
%% \begin{Highlighting}[]
%% \NormalTok{HomImage }\OtherTok{:}\NormalTok{ âˆ£ B âˆ£ }\OtherTok{â†’}\NormalTok{ ğ“¤ Ì‡}
%% \NormalTok{HomImage }\OtherTok{=} \OtherTok{Î»}\NormalTok{ b }\OtherTok{â†’}\NormalTok{ Image âˆ£ h âˆ£ âˆ‹ b}
%% \end{Highlighting}
%% \end{Shaded}
\begin{verbatim}
  HomImage : âˆ£ B âˆ£ â†’ ğ“¤ Ì‡
  HomImage = Î» b â†’ Image âˆ£ h âˆ£ âˆ‹ b
\end{verbatim}
We are now ready to formalize the proof the proof that homomorphic images are subuniverses.
\begin{code}\input{subuniverses/homimagesub.tex}\end{code}

\subsection{Generation with terms}\label{generation-with-terms}
Recall Obs 12 presenting subuniverse generation using the images of terms: If ğ‘Œ is a subset of ğ´, then \(\mathrm{Sg}^ğ‘¨(Y) = \{t^ğ‘¨ a : t âˆˆ T(X), a : X â†’ Y\}\). To formalize this in Agda, we first prove that subuniverses are closed under the action of term operations.
\begin{code}\input{subuniverses/subtermclosed.tex}\end{code}
This proves \(\mathrm{Sg}^ğ‘¨(Y) âŠ‡ \{ t^ğ‘¨ a : t âˆˆ ğ‘‡(ğ‘‹), a : ğ‘‹ â†’ ğ‘Œ \}\).

Next we prove \(\mathrm{Sg}^ğ‘¨(Y) âŠ† \{ t^ğ‘¨ a : t âˆˆ ğ‘‡(ğ‘‹), a : ğ‘‹ â†’ ğ‘Œ \}\) by the following steps:
\begin{enumerate}
\item The image of ğ‘Œ under all terms, which we call TermImage ğ‘Œ, is a subuniverse of ğ‘¨; i.e., TermImage ğ‘Œ =
  \(\{ t^ğ‘¨ a : t âˆˆ ğ‘‡(ğ‘‹), a : ğ‘‹ â†’ ğ‘Œ \} â‰¤ ğ‘¨\).
\item ğ‘Œ âŠ† TermImage ğ‘Œ (obvious)
\item \(\mathrm{Sg}^ğ‘¨(Y)\) is the smallest subuniverse containing ğ‘Œ (see sgIsSmallest) so \(\mathrm{Sg}^ğ‘¨(Y)\) âŠ† TermImage ğ‘Œ.
\end{enumerate}
\noindent (The last item was already proved above; see \texttt{sgIsSmallest}.)
\begin{code}\input{subuniverses/termimagesub.tex}\end{code}
Finally, we can prove the desired inclusion.
\begin{code}
\\[\AgdaEmptyExtraSkip]%
\>[1]\AgdaFunction{SgYâŠ†TermImageY}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Pred}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ‘¨}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âˆ£}}\AgdaSpace{}%
\AgdaBound{ğ“¤}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{â†’}\AgdaSpace{}%
\AgdaDatatype{Sg}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{âŠ†}}\AgdaSpace{}%
\AgdaDatatype{TermImage}\AgdaSpace{}%
\AgdaBound{Y}\<%
\\
%
\>[1]\AgdaFunction{SgYâŠ†TermImageY}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sgIsSmallest}%
\>[775I]\AgdaSymbol{(}\AgdaFunction{TermImageIsSub}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[775I]%
\>[33]\AgdaSymbol{(}\AgdaFunction{YâŠ†TermImageY}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\<%
\end{code}
%% \textbf{Exercise}. Prove the following by generalizing the relation â‰ƒ to predicates:
%% \begin{Shaded}
%% \begin{Highlighting}[]
%% \NormalTok{SgYâ‰ƒTermImageY }\OtherTok{:} \OtherTok{(}\NormalTok{Y }\OtherTok{:}\NormalTok{ Pred âˆ£ ğ‘¨ âˆ£ k}\OtherTok{)} \OtherTok{â†’} \OtherTok{(}\NormalTok{TermImage Y}\OtherTok{)}\NormalTok{ â‰ƒ }\OtherTok{(}\NormalTok{Sg Y}\OtherTok{)}
%% \NormalTok{SgYâ‰ƒTermImageY }\OtherTok{\{}\NormalTok{x}\OtherTok{\}}\NormalTok{ Y }\OtherTok{=}\NormalTok{ ?}
%% \end{Highlighting}
%% \end{Shaded}

\subsection{Types for subalgebras}\label{types-for-subalgebras}
The next submodule is a generalization of MHE's implementation of subgroups. We consider the subalgebras of an single arbitrary(but fixed) algebra ğ‘¨ and we present a module that generalizes \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#subgroups-sip}{MHE's ambient module} . It does for subuniverses what MHE does for subgroups.
\begin{code}\input{subuniverses/mheprelude.tex}\end{code}

Note that we introduce a new definition of the \texttt{subuniverse} type here. In cotrast to our earlier definition of \texttt{Subuniverses}, which uses a predicate on \texttt{âˆ£\ ğ‘¨\ âˆ£} to represent the underlying set of the subuniverse, here we use the type \texttt{ğ“Ÿ\ âˆ£\ ğ‘¨\ âˆ£}, the powerset of the universe of \texttt{ğ‘¨}.
\begin{code}\input{subuniverses/mhepart1.tex}\end{code}

For a subuniverse B of ğ‘¨, we want to form a subalgebra ğ‘© = âŸ¨B, \ldots{}âŸ© of ğ‘¨ such that the operations of ğ‘© are those of ğ‘¨ restricted to B. Here are some useful lemmas extracted from MHE's proof of subgroup-equality. The first is called f in MHE's proof.
\begin{code}\input{subuniverses/mhepart2.tex}\end{code}

So, two subuniverses are equal if and only if they have the same elements (cf.~\href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html\#371022}{MHE's notes on subgroup-equality}):
\begin{code}\input{subuniverses/mhepart3.tex}\end{code}

The converse of membership-equiv-gives-carrier-equality is obvious.
\begin{code}\input{subuniverses/mhepart4.tex}\end{code}

\subsection{The type of Subalgebras in Agda}\label{the-type-of-subalgebras-in-agda}
Finally, we define, once and for all, the type of subalgebras of an algebra (resp., subalgebras of algebras in a class of algebras) that we will use in the sequel.
\begin{code}\input{subuniverses/newsub.tex}\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Equational Logic in Agda}\label{equational-logic-in-agda}
This chapter describes the \closuremodule of the \agdaualib.

\subsection{Preliminaries}\label{preliminaries}
As usual, the development begins by satisfying dependencies, although this time we postpone some imports until the start of the \closuremodule so that these later imports can share the same signature with the module.

%\\[\AgdaEmptyExtraSkip]%
\begin{code}
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--without-K}\AgdaSpace{}%
\AgdaPragma{--exact-split}\AgdaSpace{}%
\AgdaPragma{--safe}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{basic}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{prelude}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{global-dfunext}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{dfunext}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{im}\AgdaSymbol{)}\<%
\end{code}

\subsection{Closure operators}\label{closure-operators}
Fix a signature ğ‘†. Let ğ’¦ be a class of ğ‘†-algebras. Define
\begin{itemize}
\item H(ğ’¦) = homomorphic images of members of ğ’¦;
\item S(ğ’¦) = algebras isomorphic to a subalgebra of a member of ğ’¦;
\item P(ğ’¦) = algebras isomorphic to a direct product of members of ğ’¦.
\end{itemize}
As a straight-forward verification confirms, H, S, and P are closure operators. A class ğ’¦ of ğ‘†-algebras is said to be \emph{closed under the formation of homomorphic images} if H(ğ’¦) âŠ† ğ’¦. Similarly, ğ’¦ is \emph{closed under the formation of subalgebras} (resp., \emph{products}) provided S(ğ’¦) âŠ† ğ’¦ (resp., P(ğ’¦) âŠ† ğ’¦).

An algebra is a homomorphic image (resp., subalgebra; resp., product) of every algebra to which it is isomorphic. Thus, the class H(ğ’¦) (resp., S(ğ’¦); resp., P(ğ’¦)) is closed under isomorphism.

The operators H, S, and P can be composed with one another repeatedly, forming yet more closure operators. If Câ‚ and Câ‚‚ are closure operators on classes of structures, let us say that Câ‚ â‰¤ Câ‚‚ if for every class ğ’¦ we have Câ‚(ğ’¦) âŠ† Câ‚‚(ğ’¦).

\subsection{Equational classes}\label{equational-classes}
A class ğ’¦ of ğ‘†-algebras is called a \textbf{variety} if it is closed under each of the closure operators H, S, and P introduced above; the corresponding closure operator is often denoted ğ•. Thus, if ğ’¦ is a class of similar algebras, then the \textbf{variety generated by} ğ’¦ is denoted by ğ•(ğ’¦) and defined to be the smallest class that contains ğ’¦ and is closed under H, S, and P.

We would like to know how to construct ğ•(ğ’¦) directly from ğ’¦, but it's not immediately obvious how many times we would have to apply the operators H, S, P before the result stabilizes to form a variety---the \textbf{variety generated by} ğ’¦. Fortunately, Garrett Birkhoff proved that if we apply the operators in the correct order, then it suffices to apply each one only once.

\subsection{Types for identities}\label{types-for-identities}
In his treatment of Birhoff's HSP theorem, Cliff Bergman (at the start of Section 4.4 of his universal algebra textbook Bergman:2012) proclaims, ``Now, finally, we can formalize the idea we have been using since the first page of this text.'' He then proceeds to define \textbf{identities of terms} as follows (paraphrasing for notational consistency):

Let ğ‘† be a signature. An \textbf{identity} or \textbf{equation} in ğ‘† is an ordered pair of terms, written ğ‘ â‰ˆ ğ‘, from the term algebra ğ‘»(X). If A is an ğ‘†-algebra we say that A \textbf{satisfies} ğ‘ â‰ˆ ğ‘ if ğ‘ Ì‡ A â‰¡ ğ‘ Ì‡ A. In this situation, we write A âŠ§ ğ‘ â‰ˆ ğ‘.

If ğ’¦ is a class of ğ‘†-algebras, we write ğ’¦ âŠ§ ğ‘ â‰‹ ğ‘ if, for every A âˆˆ ğ’¦, A âŠ§ ğ‘ â‰ˆ ğ‘. Finally, if ğ“” is a set of equations, we write ğ’¦ âŠ§ ğ“” if every member of ğ’¦ satisfies every member of ğ“”.

We formalize these notions in Agda in the \closuremodule, which begins as follows. (Note the imports that were postponed until after the start of the closure module so that the imports share the same signature ğ‘† with the \closuremodule).

\begin{code}\input{closure/clo1.tex}\end{code}
Our first definition in the \closuremodule is notation that represents the satisfaction of equations. The standard notation is \texttt{ğ‘¨\ âŠ§\ p\ â‰ˆ\ q}, which means that the identity \texttt{p\ â‰ˆ\ q} is satisfied in ğ‘¨. In otherwords, for all assignments \texttt{a\ :\ X\ â†’\ âˆ£\ ğ‘¨\ âˆ£} of values to variables, we have \texttt{(p\ Ì‡\ ğ‘¨)\ a\ â‰¡\ (q\ Ì‡\ ğ‘¨)\ a}.

If ğ’¦ is a class of structures, it is standard to write \texttt{ğ’¦\ âŠ§\ p\ â‰ˆ\ q} just in case all structures in the class ğ’¦ model the identity p â‰ˆ q. However, because a class of structures has a different type than a single structure, we will need different notation, so we have settled on writing \texttt{ğ’¦\ âŠ§\ p\ â‰‹\ q} to denote this concept.

We will also formalize the notions of closure under the taking of products, subalgebras, and homomorphic images, and later prove that each of these closures preserves identities.
\begin{code}\input{closure/clomod.tex}\end{code}

\subsection{Compatibility of identities}\label{compatibility-of-identities}
Identities are compatible with the formation of subalgebras, homomorphic images and products. More precisely, for every class ğ’¦ of structures, each of the classes S(ğ’¦), H(ğ’¦), P(ğ’¦), ğ•(ğ’¦) satisfies the same set of identities as does ğ’¦. We prove that identities satisfied by all factors of a product are also satisfied by the product.
\begin{code}\input{closure/prodcomp.tex}\end{code}

\subsubsection{Closure under subalgebras}\label{closure-under-subalgebras}
Above we define a datatype SClo that represents a class of algebraic structures that is closed under the taking of subalgebras.

Let S(ğ’¦) denote the class of algebras isomorphic to a subalgebra of a member of ğ’¦. With our new formal definition of Subalgebra, we will show that every term equation, \texttt{p\ â‰ˆ\ q}, that is satisfied by all \texttt{ğ‘¨\ âˆˆ\ ğ’¦} is also satisfied by all \texttt{B\ âˆˆ\ S(ğ’¦)}. In other words, the collection of identities modeled by a given class of algebras is also modeled by all of the subalgebras of that class.
\begin{code}\input{closure/subcomp.tex}\end{code}

\subsubsection{Closure under hom images}\label{closure-under-hom-images}
Recall (Obs 14) that an identity is satisfied by all algebras in a class if and only if that identity is compatible with all homomorphisms from the term algebra ğ‘»(X) into algebras of the class. More precisely, if ğ“š is a class of ğ‘†-algebras and ğ‘, ğ‘ terms in the language of ğ‘†, then,
\[ğ’¦ âŠ§ p â‰ˆ q \; â‡” \; âˆ€ ğ‘¨ âˆˆ ğ’¦, âˆ€ h âˆˆ \mathrm{Hom}(ğ‘»(X), ğ‘¨), h âˆ˜ p^{ğ‘»(X)} = h âˆ˜ q^{ğ‘»(X)}.\]
We now formalize this result in Agda. Similarly, we define a datatype that represents classes of algebras that include all homomorphic images of algebras in the class, and we prove that identities satisfied by all algberas in a class are also satsified by all homomorphic images of algebras in the class.
\begin{code}\input{closure/homcomp.tex}\end{code}

Finally, we prove a useful result about the compatibility of identities with interpretation of terms.
\begin{code}\input{closure/homidcomp.tex}\end{code}

\subsection{Equational theories and classes}\label{equational-theories-and-classes}
Here we define the notation \texttt{Th} for the identities satisfied by all structures in a given class, and \texttt{Mod} for all structures that satisfy a given collection of identities.

%% \begin{verbatim}
%% Th : Pred (Algebra ğ“¤ ğ‘†)(ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº ) â†’   Pred (Term{X = X} Ã— Term) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº)
%% Th ğ’¦ = Î» (p , q) â†’ ğ’¦ âŠ§ p â‰‹ q
%% Mod : Pred (Term{X = X} Ã— Term) (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº) â†’    Pred (Algebra ğ“¤ ğ‘†)(ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº )
%% Mod â„° = Î» A â†’ âˆ€ p q â†’ (p , q) âˆˆ â„° â†’ A âŠ§ p â‰ˆ q
%% \end{verbatim}

\subsection{The free algebra in Agda}\label{the-free-algebra-in-agda}
Recall, we proved above that term algebra ğ‘»(ğ‘‹) is the absolutely free algebra in the class ğ“š(ğ‘†) of all ğ‘†-structures. In this section, we formalize, for a given class ğ’¦ of ğ‘†-algebras, the (relatively) free algebra in SP(ğ’¦) over ğ‘‹. Recall, this was defined above in free algebras as follows:
\[ğ”½(ğ’¦, ğ‘‹) := ğ‘»(ğ‘‹)/Î¨(ğ’¦, ğ‘»(ğ‘‹)).\]
Thus, we must first formalize the congruence Ïˆ(ğ’¦, ğ‘»(ğ‘‹)) which is defined by
\[Î¨(ğ’¦, ğ‘»(ğ‘‹)) := â‹€ Ïˆ(ğ’¦, ğ‘»(ğ‘‹)),\]
where Ïˆ(ğ’¦, ğ‘»(ğ‘‹)) := \{Î¸ âˆˆ Con ğ‘»(ğ‘‹) : ğ‘¨/Î¸ âˆˆ S(ğ’¦)\}.
%% Strictly speaking, ğ‘‹ is not a subset of ğ”½(ğ’¦, ğ‘‹) so it doesn't make sense to say that ``ğ‘‹ generates ğ”½(ğ’¦, ğ‘‹).'' But as long as ğ’¦ contains a nontrivial algebra, we will have Î¨(ğ’¦, ğ‘»(ğ‘‹)) âˆ© ğ‘‹Â² â‰  âˆ…, and we can identify ğ‘‹ with ğ‘‹/Î¨(ğ’¦, ğ‘»(ğ‘‹)) in ğ”½(ğ’¦, ğ‘‹). (See Obs \%s \textless{}obs 9.6\textgreater{}.)
\begin{code}\input{closure/free.tex}\end{code}

N.B. Î¨ is the kernel of ğ‘»(X) â†’ ğ”½(ğ’¦, ğ‘»(X)). Therefore, to prove ğ‘¨ is a homomorphic image of ğ”½(ğ’¦, ğ‘»(X)), it suffices to show that the kernel of the lift h : ğ‘»(X) â†’ ğ‘¨ contains Î¨.

\begin{verbatim}
   ğ‘»---- ğ‘” --->>ğ”½  (ker ğ‘” = Î¨)
    \         .
     \       .
      â„     âˆƒÏ•     (want: Î¨ âŠ† ker â„)
       \   .
        \ .
         V
         ğ‘¨
\end{verbatim}

\subsection{More tools for Birkhoff's theorem}\label{more-tools-for-birkhoffs-theorem}
Here are some of the key facts and identities we need to complete the proof of Birkhoff's HSP theorem.
\begin{code}\input{closure/birkhofftools.tex}\end{code}


\subsection{Closure under HSP}\label{closure-under-hsp}
Finally, we have a datatype that represents classes of algebras that are close under the taking of homomorphic images, subalgebras, and products of algebras in the class.
%% \begin{verbatim}
%% -- Variety Closure
%% data VClo (ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) (ğ“¤ âº)) :
%%  Pred (Algebra ğ“¤ ğ‘†)(ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âº âº ) where
%%   vbase : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ ğ’¦ â†’ ğ‘¨ âˆˆ VClo ğ’¦
%%   vprod : {I : ğ“¤ Ì‡ }{ğ’œ : I â†’ Algebra _ ğ‘†}
%%    â†’      (âˆ€ i â†’ ğ’œ i âˆˆ VClo ğ’¦) â†’ â¨… ğ’œ âˆˆ VClo ğ’¦
%%   vsub : {ğ‘¨ : Algebra ğ“¤ ğ‘†} â†’ ğ‘¨ âˆˆ VClo ğ’¦
%%    â†’     (sa : SubalgebrasOf ğ‘¨) â†’ âˆ£ sa âˆ£ âˆˆ VClo ğ’¦
%%   vhom : {ğ‘¨ : Algebra ğ“¤ ğ‘†}
%%    â†’     ğ‘¨ âˆˆ VClo ğ’¦ â†’ ((ğ‘© , _ , _) : HomImagesOf ğ‘¨)
%%    â†’     ğ‘© âˆˆ VClo ğ’¦
%% \end{verbatim}
\subsubsection{Identities for product closure}\label{identities-for-product-closure}
\begin{code}\input{closure/pclo-id.tex}\end{code}


\subsubsection{Identities for subalgebra closure}\label{identities-for-subalgebra-closure}
\begin{code}\input{closure/sclo-id.tex}\end{code}

\subsubsection{Identities for hom image closure}\label{identities-for-hom-image-closure}
\begin{code}\input{closure/hclo-id.tex}\end{code}

\subsubsection{Identities for HSP closure}\label{identities-for-hsp-closure}
\begin{code}\input{closure/vclo-id.tex}\end{code}


\subsection{Axiomatization of a class}\label{axiomatization-of-a-class}
We conclude the \closuremodule by proving that a class ğ’¦ of structures is axiomatized by \texttt{Th\ (VClo\ ğ’¦)}, which is the set of equations satisfied by all members of the varietal closure of ğ’¦.
\begin{code}\input{closure/vclo-th.tex}\end{code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%   Birkhoff's Theorem   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HSP Theorem in Agda}\label{hsp-theorem-in-agda}
Here we give a formal proof in Agda of Birkhoff's theorem, which says that a variety is an equational class. In other terms, if a class ğ’¦ of algebras is closed under the operators ğ‘¯, ğ‘º, ğ‘·, then ğ’¦ is an equational class (i.e., ğ’¦ is the class of algebras that model a particular set of identities).

\subsection{The birkhoff module}\label{the-birkhoff-module}
In addition to the usual importing of dependencies, We start the \birkhoffmodule with a fixed signature and a type \texttt{X}. As in the \termsmodule, \texttt{X} represents an arbitrary (infinite) collection of ``variables'' (which will serve as the generators of the term algebra ğ‘»(X)).
\begin{code}\input{birkhoff/birkprelude.tex}\end{code}

\subsection{Equalizers in Agda}\label{equalizers-in-agda}
The equalizer of two functions (resp., homomorphisms) \texttt{g\ h\ :\ A\ â†’\ B} is the subset of \texttt{A} on which the values of the functions \texttt{g} and \texttt{h} agree. We formalize this notion in Agda as follows.
\begin{code}\input{birkhoff/equalizers.tex}\end{code}
It turns out that the equalizer of two homomorphisms is closed under the operations of \texttt{A} and is therefore a subalgebra of the common domain, as we now prove.
\begin{code}\input{birkhoff/equalizersClosed.tex}\end{code}
Thus, \texttt{ğ‘¬ğ‘¯} is a subuniverse of \texttt{A}.

\subsection{Hom determination}\label{hom-determination}
The \homomorphismsmodule formalizes the notion of homomorphism and proves some basic facts about them. Here we show that homomorphisms are determined by their values on a generating set, as stated and proved informally in Obs 3. This is proved here, and not in the \homomorphismsmodule because we need \texttt{Sg} from the \texttt{subuniverses} module. % See Section XX
\begin{code}\input{birkhoff/homUnique.tex}\end{code}

\subsection{The Agda proof of Birkhoff's theorem}\label{the-agda-proof-of-birkhoffs-theorem}
\begin{code}\input{birkhoff/birkhoffsTheorem.tex}\end{code}

\section{Acknowledgments}\label{acknowledgments}
%% Besides the main authors and developers of \agdaualib, a number of other people have contributed to the project in one way or another.

%% Special thanks go to Clifford Bergman, Venanzio Capretta, Andrej Bauer, MiklÃ³s MarÃ³ti, and Ralph Freese, for many helpful discussions, as well as the invaluable instruction, advice, and encouragement that they continue to lend to this project, often without even knowing it.

%% The first author would also like to thank his postdoctoral advisors and their institutions for supporting work on this project. These include Peter Mayr and University of Colorado in Boulder (Aug 2017--May 2019), Ralph Freese and the University of Hawaii in Honolulu (Aug 2016--May 2017), and Cliff Bergman and Iowa State University in Ames (Aug 2014--May 2016).

%% \subsubsection{Attributions and citations}\label{attributions-and-citations}
%% Regarding the mathematical results that are implemented in the \agdaualib library, as well as the presentation and informal statements of these results in the documentation, The Authors makes no claims to originality.

%% Regarding the Agda source code in the \agdaualib library, this is mainly due to The Authors.

We have benefited enormously from the outstanding lecture notes on \href{https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes}{Univalent Foundations and Homotopy Type Theory} and the \href{https://github.com/martinescardo/TypeTopology}{Type Topology} Agda Library, both by \href{https://www.cs.bham.ac.uk/~mhe}{Martin HÃ¶tzel Escardo}.

Of course, the (current incarnation\footnote{previous versions were based on Coq and Lean}) \agdaualib library depends on the wonderful Agda programming language~\cite{Norell:2009}.

%% The first author is greatly indebted to Martin for teaching him about type theory in Agda at the \href{http://events.cs.bham.ac.uk/mgs2019/}{Midlands Graduate School in the Foundations of Computing Science} in Birmingham in 2019.

%% The development of the \agdaualib and its documentation is informed by and benefits from the references listed in the references section below.

%% \subsection{References}\label{references}
%% The following Agda documentation and tutorials are excellent. They have been quite helpful to The Author of \agdaualib, and have informed the development of the latter and its documentation.

%% \begin{itemize}
%% \tightlist
%% \item Altenkirk, \href{}{Computer Aided Formal Reasoning}
%% \item Bove and Dybjer, \href{}{Dependent Types at Work}
%% \item Escardo, \href{}{Introduction to Univalent Foundations of Mathematics with Agda}
%% \item Gunther, Gadea, Pagano, \href{}{Formalization of Universal Algebra in Agda}
%% \item JÃ¡nos, \href{}{Agda Tutorial}
%% \item Norell and Chapman, \href{}{Dependently Typed Programming in Agda}
%% \item Wadler, \href{}{Programming Language Foundations in Agda}
%% \end{itemize}

%% Finally, the official \href{}{Agda Wiki}, \href{}{Agda User's Manual}, \href{}{Agda Language Reference}, and the (open source) \href{}{Agda Standard Library} source code are also quite useful.

\bibliographystyle{ACM-Reference-Format}
\bibliography{ualib_refs}
\end{document}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555


