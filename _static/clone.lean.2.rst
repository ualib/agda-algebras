::

  import data.set
  universes u v w ğ•©
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    def Ï€ {Î² Î±} (i): op Î² Î± := Î» x, x i
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
    section algebra
      parameters (Î±: Type u) (Î³: Type w) (Ïƒ: signature)
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î± 
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
      def pr (i: Î³): op Î³ Î± := Î» (t: Î³ â†’ Î±), t i
    end algebra
    section clone
      parameter Î±: Type u    -- carrier type
      parameter Î³: Type w    -- arity type
      parameter â„±: Type v    -- operation symbol type
      parameter {Ïƒ: signature}
  
      variable {Ï„: signature}
  
      -- general composition
      def comp {Î³': Type w}
      (f: op Î³ Î±) (gs: Î³ â†’ op Î³' Î±): op Î³' Î± :=
      Î» x, f (Î» i, gs i x)
  
      local infix `â—¾`:50 := comp
  
      lemma comp_proj_id
      (ar:Î³) (gs: Î³ â†’ op Î³ Î±): comp (Ï€ ar) gs = gs ar := rfl
  
      structure clone (C: set (op Î³ Î±)) :=
      ( proj_closed: âˆ€ (ar: Î³), (Î» (x: Î³ â†’ Î±), x ar) âˆˆ C )
      ( comp_closed: âˆ€ (f: op Î³ Î±)  (gs: Î³ â†’ op Î³ Î±), 
            f âˆˆ C â†’ (âˆ€ i, gs i âˆˆ C) â†’ (f â—¾ gs) âˆˆ C )
  
      -- BEGIN
      -- The clone generated by ğ’ª 
      inductive clo {ğ’ª : set (op Î³ Î±)} : set (op Î³ Î±)
      | pr (ar): clo (Ï€ ar)
      | comp {f} {gs: Î³ â†’ op Î³ Î±}:
        f âˆˆ ğ’ª  â†’ (âˆ€ i, clo (gs i)) â†’ clo (f â—¾ gs)
      -- END
    end clone
  end ualib

