::

  import data.set
  universes u v w ğ•©
    namespace ualib
      definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
      definition Ï€ {Î² Î±} (i): op Î² Î± := Î» x, x i
      structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
      section algebra
        parameters (Î±: Type u) (Î³: Type w) (Ïƒ: signature)
        def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î± 
        def algebra := sigma algebra_on
        instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
        instance alg_operations : has_coe_to_fun algebra :=âŸ¨_, sigma.sndâŸ©
        def pr (i: Î³): op Î³ Î± := Î» (t: Î³ â†’ Î±), t i
      end algebra
    end ualib
  
  namespace ualib
    section clone
      parameter â„±: Type v    -- operation symbol type
      parameter {Ïƒ: signature}
      variable {Ï„: signature}
      def comp {Î±: Type u} {Î³ Î³': Type w}
      (f: op Î³ Î±) (gs: Î³ â†’ op Î³' Î±): op Î³' Î± :=
      Î» x, f (Î» i, gs i x)
  
      infix `â—¾`:50 := comp
  
      lemma comp_proj_id {Î±: Type u} {Î³: Type w}
      (ar:Î³) (gs: Î³ â†’ op Î³ Î±): comp (Ï€ ar) gs = gs ar := rfl
  
      structure clone {Î±: Type u} {Î³: Type w}
      (C: set (op Î³ Î±)) :=
      ( proj_closed: âˆ€ (ar: Î³), (Î» (x: Î³ â†’ Î±), x ar) âˆˆ C )
      ( comp_closed: âˆ€ (f: op Î³ Î±)  (gs: Î³ â†’ op Î³ Î±), 
            f âˆˆ C â†’ (âˆ€ i, gs i âˆˆ C) â†’ (f â—¾ gs) âˆˆ C )
  
      -- BEGIN
      -- The clone generated by ğ’ª 
      inductive clo {Î±: Type u} {Î³: Type w}
      {ğ’ª : set (op Î³ Î±)} : set (op Î³ Î±)
      | pr (ar): clo (Ï€ ar)
      | comp {f} {gs: Î³ â†’ op Î³ Î±}:
        f âˆˆ ğ’ª  â†’ (âˆ€ i, clo (gs i)) â†’ clo (f â—¾ gs)
    
      theorem clo_contains_gens {Î±: Type u} {Î³: Type w}
      (ğ’ª : set (op Î³ Î±)) : ğ’ª âŠ† (@clo Î± Î³ ğ’ª) :=
      assume f (h: f âˆˆ ğ’ª), show f âˆˆ (@clo Î± Î³ ğ’ª),
      from clo.comp h clo.pr
  
      -- (an alternative proof of the last result)
      theorem clo_contains_gens' {Î±: Type u} {Î³: Type w}
      (ğ’ª : set (op Î³ Î±)): ğ’ª âŠ† (@clo Î± Î³ ğ’ª) :=
      begin
        intros f h,
        apply clo.comp h,
        apply clo.pr
      end
      -- END
    end clone
  end ualib      
  