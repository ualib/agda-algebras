.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
    definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
    structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
    definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
    definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
    instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
    instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©
 
    namespace subuniverse
      section sub
        parameters {Ïƒ : signature} {Î± : Type*} {I : Type*}
        def F := Ïƒ.F
        def Ï := Ïƒ.Ï 
        def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
        def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
        def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
        theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
        assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
        theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
        assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
        lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:=                                   -- Fact 1.
        assume x (h: x âˆˆ X), 
          show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
            assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
            show x âˆˆ W, from 
              have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
            hâ‚‚.right h
        lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                                                     -- Fact 2.
        âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
        assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                               -- An alternative proof of Fact 2.
        âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
        assume R (hc : Sub R âˆ§ X âŠ† R),
        have hâ‚: Sub R, from hc.left,
        have hâ‚‚: X âŠ† R, from hc.right,
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                          -- Yet another derivation of Fact 2.
        âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
        show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
        lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):=               -- Sgá´¬ X is a subuniverse of A
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
        show ğ”¸ f a âˆˆ Sg X, from 
          assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
            have hâ‚: Sg X âŠ† W, from 
              sInter_mem' W h,
            have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
            (h.left f a h')
        inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
        | var (x : ğ”¸) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)

        -- Y X is a subuniverse
        lemma Y_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Y X):= 
        assume f a (h: âˆ€ i, Y X (a i)), show Y X (ğ”¸ f a), from 
        Y.app f a h 
    
        -- Y X is the subuniverse generated by X
        theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
        have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), 
          show x  âˆˆ Y X, from Y.var x h,
        have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), 
          show Y X (ğ”¸ f a), from Y.app f a h,
        have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
        have inc_r: Y X âŠ† Sg X, from assume a (h: a âˆˆ Y X), 
          show a âˆˆ Sg X, from
            have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from 
              Y.rec
              ( --base: a = x âˆˆ X
                assume x (hrâ‚: x âˆˆ X), 
                show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚ 
              )
              ( --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
                assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X),
                show ğ”¸ f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ 
              ),
            hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

    definition index_of_sub_above_X {ğ”¸: algebra Ïƒ} 
    (X: set ğ”¸) (C: I â†’ set ğ”¸): I â†’ Prop:= 
    Î» i, Sub (C i) âˆ§ X âŠ† (C i) 

    lemma sInter_mem_of_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸} (x: ğ”¸): 
    x âˆˆ Sg X â†” âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
    iff.intro
      (assume (h: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚: Sub R) (hâ‚‚: X âŠ† R), 
        show x âˆˆ R, from h R (and.intro hâ‚ hâ‚‚))
      (assume (h: âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R), 
        show x âˆˆ Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))

    -- Y is the smallest Sub containing X
    lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): 
    Sub U â†’ X âŠ† U â†’ Y X âŠ† U:=
    assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U),
    assume (y: ğ”¸)  (p: Y X y), show U y, from 
      have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec

        --base step: y = x âˆˆ X
        ( assume y (h: X y) (h': Y X y), hâ‚‚ h )

        --induction step: y = A f a for some a with âˆ€ i, a i âˆˆ Y
        ( assume f a,
          assume hâ‚ƒ: âˆ€ i, Y X (a i), 
          assume hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i),
          assume hâ‚…: Y X (ğ”¸ f a),
          have hâ‚†: âˆ€ i, a i âˆˆ U, from 
            assume i, hâ‚„ i (hâ‚ƒ i), show U (ğ”¸ f a), from hâ‚ f a hâ‚† ),
      q p p

      end sub
    end subuniverse

    section terms

      parameters {Ïƒ : signature} (X :Type*)
      local notation `F` := Ïƒ.F
      local notation `Ï` := Ïƒ.Ï 
    
      inductive term
      | var         : X â†’ term
      | app (f : F) : (Ï f â†’ term) â†’ term
    
      def Term : algebra Ïƒ := âŸ¨term, term.appâŸ©
    
    end terms

    section
    -- BEGIN
      open term
      parameters {Ïƒ : signature} (X :Type*) {f : Ïƒ.F} 
      definition F := Ïƒ.F
      definition Ï := Ïƒ.Ï
      definition ğ•‹ := @Term Ïƒ
      definition ğ• := @var Ïƒ X
    -- END
      
      -- To prove that the free algebra is absolutely free, we show that
      -- the lift of an arbitrary function h : X â†’ A is a homomorphism
      -- and that it is the unique homomorphism extending h.
    
      -- Definition of the lift of a function.
      -- Given an arbitrary map h : X â†’ A, define a function on terms as follows:
      -- ``term`` has two constructors:
      --            var : X â†’ term
      --            app (f : F) : (Ï f â†’ term) â†’ term
      -- We must say what ``lift_of h`` does in each case.
      -- if the given term is ``var x`` then ``h (var x) = h x``
      -- if the given term is ``app f ts``, then ``h (app f ts) = (A f) lift_of h``
      -- ts â†¦ 
      definition lift_of {ğ”¸: algebra Ïƒ} (h: X â†’ ğ”¸): ğ•‹(X) â†’ ğ”¸
      | (var x):= h x
      | (app f ts):= ğ”¸ f (Î» (i : Ï f), lift_of (ts i))
    
      open homomorphism
    
      -- The lift of a function is a homomorphism.
      lemma lift_is_hom {ğ”¸: algebra Ïƒ} (h : X â†’ ğ”¸): 
      homomorphic (lift_of h) :=
      Î» f as, show lift_of h (app f as) = ğ”¸ f (lift_of h âˆ˜ as), from rfl
    
      -- The lift of a function is unique among homomorphic lifts.
      lemma lift_is_unique {ğ”¸: algebra Ïƒ}: âˆ€ {g h : ğ•‹(X) â†’ ğ”¸},
      homomorphic g â†’ homomorphic h â†’ g âˆ˜ ğ• = h âˆ˜ ğ• â†’ g = h :=
      assume (g h: ğ•‹(X) â†’ ğ”¸) 
             (hâ‚ : homomorphic g)
             (hâ‚‚ : homomorphic h)
             (hâ‚ƒ : g âˆ˜ ğ• = h âˆ˜ ğ•),
    
        show g = h, from 
    
          have hâ‚€: âˆ€ t: ğ•‹(X), g t = h t, from 
    
            assume t: ğ•‹(X), 
            begin
              induction t with t f a ihâ‚ ,
              show g (ğ• t) = h (ğ• t),
              {apply congr_fun hâ‚ƒ t},
    
              show g (app f a) = h (app f a),
              { have ihâ‚‚  : g âˆ˜ a = h âˆ˜ a, from funext ihâ‚,
                calc g (app f a) = ğ”¸ f (g âˆ˜ a) : hâ‚ f a
                             ... = ğ”¸ f (h âˆ˜ a) : congr_arg (ğ”¸ f) ihâ‚‚ 
                             ... = h (app f a) : (hâ‚‚ f a).symm }
            end,
          funext hâ‚€ 
    end
