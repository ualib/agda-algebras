.. include:: _static/math_macros.rst

.. highlight:: lean

.. _inductively-defined-types:

==================================
Inductively Defined Types
==================================

.. todo:: add chapter intro

We briefly introduced inductively defined types in :numref:`inductive-types`.  Many more details can be found in the chapter on `Inductive Types`_ in :term:`TPIL`. 

The availability and utility of inductively defined types were among our primary original motivations for formalizing universal algebra in a language (like Lean) that supports such types. In the present chapter, we show how these types come into play in our formalization project.  

---------------------------------------------------

.. _the-recursor:

The Recursor
-------------

Each inductively defined type, say ``foo``, is accompanied by an elimination principle known as a **recursor** (denoted by ``foo.rec`` in Lean). This elimination principle is what makes the type "inductive"; it allows us to define a function on ``foo`` by assigning values for each of ``foo``'s constructors.

.. todo:: complete this section; include an example.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: subalgebra, subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean_reprise:

Subalgebras in Lean (reprise)
-----------------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of the lean-ualib_ repository. [1]_

In :numref:`Section %s <subalgebras-in-lean>`, we saw how subalgebras can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the statement and proof of the :ref:`subuniverse generation theorem <thm-1-14>` formally in Lean.

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

.. include:: _static/subuniverse.lean.2.rst

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^ğ”¸(X)`, which is another fact that we formalize and prove below.

.. include:: _static/subuniverse.lean.3.rst

Finally, we prove that ``Y`` is the smallest subuniverse containing ``X``.

.. include:: _static/subuniverse.lean.4.rst

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A âŠ† B â†’ B âŠ† A â†’ A = B`.

.. index:: recursor

We proved ``Y X âŠ† Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined. (We will see many more examples of inductive proofs below.)

The Lean keyword ``assume`` is syntactic sugar for ``Î»``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra
.. index:: universal for; Ïƒ-algebras
.. index:: absolutely free for; Ïƒ-algebras

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

We have defined some ``local notation``, so we can write, e.g., ``f: â„±`` instead of ``f: Ïƒ.â„±`` and ``Ï f`` instead of ``Ïƒ.Ï f``. This bit of syntactic sugar results in Lean syntax for operation symbols that matches the informal algebraic analogue almost exactly. [2]_ 

The collection of terms over :math:`X`, along with the operations :math:`F^{ğ•‹(X)} := \{\mathsf{app} f âˆ£ f : F\}` forms an algebra in the signature :math:`Ïƒ = (F, Ï)`, which we denote and define by :math:`ğ•‹(X) = âŸ¨T(X), F^{ğ•‹(X)}âŸ©` .

Now, suppose :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` is an algebra in the signature Ïƒ and :math:`h : X â†’ A` is an arbitrary function.  We will show that :math:`h : X â†’ A` has a unique *extension* (or *lift*) to a homomorphism from :math:`ğ•‹(X)` to ğ”¸.

Since ğ”¸ and :math:`h : X â†’ A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`ğ•‹(X)` is **universal for** Ïƒ-algebras. Some authors say, ":math:`ğ•‹(X)` is **absolutely free for** Ïƒ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X â†’ A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`ğ•‹(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for Ïƒ-algebras, we show that the lift of an arbitrary function :math:`h : X â†’ A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

In this section we see how the clone concept, described above in :numref:`clones`, can be implemented in Lean.  We then formalize the proof of :numref:`Obs %s <obs-five>` which asserts that we can define *clone* inductively and that the inductive definition is equivalent to our initial definition.

The Lean code described in this section is in the source file `clone.lean`_, which reside in the ``src`` directory of the lean-ualib_ repository.

In order to ensure that the code in this section works without importing other parts of the `lean-ualib`_, we begin with a block of code comprised of excerpts from other parts of the `lean-ualib`_.

.. include:: _static/clone.lean.preamble.rst

Apart from the little "preamble" above, the remaining code blocks in this section should be surrounded by the lines

.. code::

    namespace ualib
      section clo 
        ... 
      end clo
    end ualib

although sometimes we don't show these lines explicitly.

We are now ready to define the ``structure`` that specifies the properties that a clone must have.  Recall (:numref:`clones`), a collection of operations is called a **clone** if and only if it *includes all projections* and is *closed under general composition*.

.. include:: _static/clone.lean.1.rst

Next we define an inductive type that represents the clone generated by a given collection ``ğ’ª`` of operations. Of course, a collection generated by ``ğ’ª`` should, at the very least, contain the generators (i.e., inhabitants of ``ğ’ª``); we check this fact as well.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

-------------------------

Varieties in Lean
------------------

.. todo:: write this section

------------------------------

Birkhoff's HSP Theorem in Lean
--------------------------------

.. todo:: write this section

------------------------------


.. rubric:: Footnotes

.. [1]
   As of this writing (summer 2019), this documentation describes code residing on the william_ branch of the lean-ualib_ repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.

.. [2]
   The only exception is that in type theory we make *typing judgments*, denoted by ``:``, rather than set membership judgments, denoted by ``âˆˆ``.

.. include:: hyperlink_references.rst
