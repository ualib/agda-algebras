.. include:: _static/math_macros.rst

.. role:: code

.. highlight:: lean

.. _glossary:

Glossary
========

.. _acronyms:

Acronyms
--------

.. glossary::

    ATP
      | *n.* automated theorem prover
      | *v.* automated theorem proving

    CiC
      :term:`Calculus of Inductive Constructions`

    cod
      codomain

    dcpo
      :term:`directed-cocomplete poset`

    dom
      domain
    
    ETT
      :term:`extensional` :term:`intuitionistic type theory <TT>`.

    em
      :term:`law of the excluded middle`

    ER
      equality reflection

    ITP
      | *n.* interactive theorem prover (or proof assistant), e.g., :term:`Agda`, :term:`Coq`, :term:`Lean`, and :term:`NuPrl`
      | *v.* interactive theorem proving

    ITT
      :term:`intensional` :term:`intuitionistic type theory <TT>`.

    LSTL
      `Lean Standard Library`_
      
    Ï‰-cpo
      :term:`Ï‰-chain cocomplete poset`

    ran
      range

    TPIL
      the `Theorem Proving in Lean`_ tutorial

    TT
      (intuitionistic) :term:`type theory`

    UIP
      `Uniqueness of Identity Proofs <https://ncatlab.org/nlab/show/axiom+UIP>`_

----------------------------------------------------

.. _nomenclature:

Nomenclature
------------

.. glossary::

    abstract category
      An **abstract category** is one whose objects are not sets or whose morphisms are not functions defined on sets. Our next example is somewhere in between. The objects are sets, but the morphisms are not necessarily *total* functions; that is, they may be defined on only a part of the source object.

    Agda
      An :term:`intensional`, :term:`predicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on Martin Lof type theory; url: https://wiki.portal.chalmers.se/agda/pmwiki.php

    algebraic lattice
      a :term:`lattice` generated by its :term:`compact elements <compact element>`. 

    algebra
      See :term:`algebraic structure`.

    algebraic structure
      An **algebraic structure** in the signature :math:`Ïƒ = (F, Ï)` (or, :math:`Ïƒ`-**algebra**) is denoted by :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` and consists of 

      #. :math:`A` := a set, called the *carrier* (or *universe*) of the algebra,
      #. :math:`F^ğ”¸ = \{ f^ğ”¸ âˆ£ f âˆˆ F, \ f^ğ”¸ : (Ï f â†’ A) â†’ A \}` := a set of operations on :math:`A`, and
      #. a collection of identities satisfied by elements of :math:`A` and operations in :math:`F^ğ”¸`.

    antichain
      A subset :math:`A` of the preordered set :math:`X` is called an **antichain** if for all :math:`x, y âˆˆ A` we have :math:`x â‰¤ y` implies :math:`y â‰¤ x`.

    antisymmetric
      A binary relation :math:`R` on a set :math:`X` is called **antisymmetric** provided :math:`âˆ€  x, y âˆˆ X \ (x \mathrel{R} y âˆ§ y\mathrel{R} x \ â†’ \ x=y)`.

    arity
      Given a :term:`signature` :math:`Ïƒ = (F, Ï)`, each operation symbol :math:`f âˆˆ F` is assigned a value :math:`Ï f`, called the **arity** of :math:`f`. (Intuitively, the arity can be thought of as the "number of arguments" that :math:`f` takes as "input".)

    Boolean algebra
      .. todo:: fill in definition    

    Boolean algebra homomorphism
      a :term:`lattice homomorphism` that also preserves complementation (but every lattice homomorphism between Boolean lattices automatically preserves complementation, so we may characterize the morphisms of this category more simply as the lattice homomorphisms).

    byte-code
      .. todo:: fill in definition    

    Calculus of Inductive Constructions
      See https://en.wikipedia.org/wiki/Calculus_of_constructions.

    Cartesian product
      See :term:`product`.

    canonical normal form
      See the `ncatlab page on normal forms <https://ncatlab.org/nlab/show/normal+form>`_.

    category of categories
      has categories as objects and functors as morphisms.

    category of small categories
      See :term:`Cat`.

    Choice
      is short for the `Axiom of Choice <https://en.wikipedia.org/wiki/Axiom_of_choice>`_.

    chain
      Let :math:`âŸ¨ X, â‰¤ âŸ©` be a preordered set and :math:`C âŠ† X`. We call :math:`C` a **chain** of :math:`âŸ¨ X, â‰¤ âŸ©` if for all :math:`x, y âˆˆ C` either :math:`x â‰¤ y` or :math:`y â‰¤ x` holds.

    clone
      An **operational clone** (or just **clone**) on a nonempty set :math:`A` is a set of operations on :math:`A` that contains all :term:`projection operations <projection operation>` and is closed under :term:`general composition`.

    closed
      If :math:`ğ–¢` is a :term:`closure operator` on :math:`X`, then a subset :math:`A âŠ† X` is called **closed** with respect to :math:`ğ–¢` (or :math:`ğ–¢`-**closed**) provided :math:`ğ–¢(A) âŠ† A` (equivalently, :math:`ğ–¢(A) = A`).

      Here's an important example. Let :math:`Ïƒ = (F, Ï)` be a :term:`signature` and :math:`X` a set. Define for each :math:`A âŠ† X` the set :math:`ğ–¢(A) = \{f\, b âˆ£ f âˆˆ F, \, b: Ï f â†’ A\}`.  Then :math:`ğ–¢` is a closure operator on :math:`X` and a subset :math:`A âŠ† X` is said to be "closed under the operations in :math:`F`" provided :math:`A` is :math:`ğ–¢`-closed.

    closure operator
      Let :math:`X` be a set and let :math:`ğ’«(X)` denote the collection of all subsets of :math:`X`. A **closure operator** on :math:`X` is a set function :math:`ğ–¢: ğ’« (X) â†’ ğ’« (X)` satisfying the following conditions, for all :math:`A, B âˆˆ ğ’« (X)`, 

      #. :math:`A âŠ† ğ–¢(A)`,
      #. :math:`ğ–¢ âˆ˜ ğ–¢ = ğ–¢`,
      #. :math:`A âŠ† B âŸ¹ ğ–¢(A) âŠ† ğ–¢(B)`.

    cocomplete
      A poset in which all joins exist is called **cocomplete**.

    code extraction
      .. todo:: insert def

    codomain
      If :math:`f : A â†’ B` is a function or relation from :math:`A` to :math:`B`, then :math:`B` is called the **codomain** of :math:`f`, denoted by 
      :math:`\cod f`.

    commutative diagram
      A **commutative diagram** is a diagram with the following property: for all objects :math:`C` and :math:`D`, all paths from :math:`C` to :math:`D` yield the same morphism.

    compact element
      an element :math:`x` of a lattice :math:`L` is called **compact** provided for all :math:`Y âŠ† L`, if :math:`x â‰¤ â‹ Y`, then there exists a finite subset :math:`F âŠ† Y` such that :math:`x â‰¤ â‹ F`.

    complete
      A poset in which all meets exist is called **complete**.

    complete lattice
      a :term:`poset` whose universe is closed under *arbitrary* meets and joins.

    complete lattice homomorphism
      a function :math:`f: X â†’ Y` preserving complete meets and joins.

    component
      If :math:`Î± : F â‡’ G` is a natural transformation, then the **component** of Î± at :math:`A` is the morphism :math:`Î±_A : FA â†’ GA`.

    composition of operations
      If :math:`f: (n â†’ A) â†’ A` is an :math:`n`-ary operation on the set :math:`A`, and if :math:`g: âˆ_{(i:n)} ((k_i â†’ A) â†’ A)` is an :math:`n`-tuple of operations, then we define the **composition of** :math:`f` **with** :math:`g`, using the :term:`eval` and :term:`fork` operations, as follows:
   
      .. math:: f [g] := f\, (\mathbf{eval} \, \mathbf{fork}\, g): âˆ_{(i:n)}(k_i â†’ A) â†’ A.
   
      Indeed, 
      
      .. math:: \mathbf{eval} \, \mathbf{fork} \, g: âˆ_{(i:n)}(k_i â†’ A) â†’ (n â†’ A)
      
      is the function that maps each :math:`a: âˆ_{(i:n)}(k_i â†’ A)` to :math:`âˆ_{(i:n)}\mathbf{eval} \,(g \, i, a\, i) = g âˆ˜ a`, where for each :math:`(i:n)` :math:`(g âˆ˜ a)(i) = (g i)(a i): A`.
      
      Thus, if :math:`a: âˆ_{(i:n)}(k_i â†’ A)`, then :math:`(\mathbf{eval} \, \mathbf{fork} \, g) (a)` has type :math:`n â†’ A`, which is the domain type of :math:`f`.  Therefore, :math:`f \, (\mathbf{eval} \, \mathbf{fork}\, g)\, (a)` has type :math:`A`.

      For a slightly more general description of composition, see :numref:`greater-generality`.

    computable
      See https://pdfs.semanticscholar.org/1364/d8e8763891b84a9383b722d82294ae0a736b.pdf.

    concrete category
      A **concrete category** is one whose objects are sets and whose morphisms are functions defined on these sets (possibly satisfying some other special properties).

    consecutive functions
      If :math:`f : A â†’ B` and :math:`g : B â†’ C`, then :math:`\cod f = \dom g` and we say that :math:`f` and :math:`g` are **consecutive functions**.

    constructive
      See https://plato.stanford.edu/entries/mathematics-constructive/ and https://en.wikipedia.org/wiki/Constructivism_(philosophy_of_mathematics) and https://en.wikipedia.org/wiki/Constructive_proof.

    contravariant powerset functor
      The **contravariant powerset functor** is a functor :math:`P : \mathbf{Set} â†’ \mathbf{Set}` such that for each :math:`g : B â†’ A` the morphism :math:`g^â† : PA â†’ PB` is given by :math:`g^â† (S) = \{b âˆˆ B : g(b) âˆˆ S\}` for each :math:`S âŠ† A`.

    coproduct
      Given two objects :math:`A` and :math:`B` a **coproduct** (or **sum**) of :math:`A` and :math:`B` is denoted by :math:`A+B` and defined to be an object with morphisms :math:`Î¹_1 : A â†’ A + B` and :math:`Î¹_2 : B â†’ A + B` such that for every object :math:`X` and all morphisms :math:`u : A â†’ Y` and :math:`v : B â†’ Y` there exists a unique morphism :math:`[u,v] : A+B â†’ Y` such that :math:`[u,v] âˆ˜ Î¹_1 = u` and :math:`[u,v] âˆ˜ Î¹_2 = v`.

    Coq
      An :term:`intensional`, :term:`impredicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on :term:`CiC`; url: http://coq.inria.fr
      
    covariant powerset functor
      The **(covariant) powerset functor** is a functor :math:`P : \mathbf{Set} â†’ \mathbf{Set}` such that for each :math:`f : A â†’ B` the morphism :math:`Pf : PA â†’ PB` is given by :math:`Pf(S) = \{f(x) : x âˆˆ S\}` for each :math:`S \subseteq A`.

    Curry-Howard correspondence
      the correspondence between propositions and types, and proofs and programs; a proposition is identified with the type of its proofs, and a proof is a program of that type. See also https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence.

    currying
      See https://en.wikipedia.org/wiki/Currying.

    data-relevant
      .. todo:: insert definition

    dependent function type
      See :term:`Pi type`.

    dependent pair type
      See :term:`Sigma type`.

    dependent product type
      See :term:`Sigma type`.

    dependent type
      A **dependent type** is actually a family of types indexed by some parameter. That is, a dependent type provides a *type schema*, which is a collection of types indexed by a set of values. For example, the type ``Fin n`` of finite sets of size ``n`` is a type that *depends* on the value ``n``.  More examples are in :numref:`dependent-types`_.  See also the `Dependent Types`_ section in the `TPL`_ tutorial.

    directed set
      A subset :math:`D` of a :term:`preorder` is called **directed** if every finite subset of :math:`D` has an upper bound in :math:`D`. That is, if :math:`F âŠ† D` and :math:`F` is finite, then there exists :math:`d âˆˆ D` such that :math:`f â‰¤ d` for all :math:`f âˆˆ F`.

    directed-cocomplete preorder
      a :term:`preorder` for which the joins of all :term:`directed <directed set>` subsets exist. 
      
    directed-cocomplete poset
      an :term:`antisymmetric` :term:`directed-cocomplete preorder`.

    directed graph
      A **directed graph** is a :term:`relational structure` consisting of a vertex set :math:`V` (whose elements are called vertices) and an edge set :math:`E âŠ† V^2` (whose elements are called edges).

    domain
      If :math:`f : A â†’ B` is a function or relation from :math:`A` to :math:`B`, then :math:`A` is called the **domain** of :math:`f`, denoted by :math:`\dom f`.

    endofunctor
      A functor that maps a category to itself is called an **endofunctor**.

    endomorphism
      A morphism :math:`f : A â†’ A` (i.e., :math:`\src f = \tar f`) is called an **endomorphism**.

    epimorphism
      A morphism :math:`f: A â†’ B` is called an **epimorphism** if for every object :math:`Y` and pair :math:`y_1, y_2: B â†’ Y` of morphisms, :math:`y_1 âˆ˜ f = y_2 âˆ˜ f` implies :math:`y_1 = y_2`. When :math:`f: A â†’ B` is an **epimorphism** we often say ":math:`f` is epi" and write :math:`f: â†  B`.

    equivalence class
      If :math:`R` is an :term:`equivalence relation` on :math:`A`, then for each :math:`a âˆˆ A`, there is an **equivalence class** containing :math:`a`, which is denoted and defined by :math:`a/R = \{b âˆˆ A âˆ£ a \mathrel R b\}`.

    equivalence relation
      An **equivalence relation** is a :term:`symmetric` :term:`preorder`. The collection of all equivalence relations on :math:`X` is denoted by :math:`\mathrm{Eq}(X)`.

    equivalent categories
      Two categories :math:`\mathcal C` and :math:`\mathcal D` are called **equivalent categories** if there are functors :math:`F : \mathcal C â†’  \mathcal D` and :math:`G : \mathcal D â†’ \mathcal C` together with natural isomorphisms :math:`Îµ : FG â‰… \mathrm{id}_{\mathcal D}`, and :math:`Î· : \mathrm{id}_{\mathcal C} â‰… GF`. We say that :math:`F` is an equivalence with an inverse equivalence :math:`G` and denote the equivalence by :math:`F : \mathcal C â‰ƒ \mathcal D : G`.

    essentially surjective on objects
      A functor :math:`F : C â†’ D` is called **essentially surjective on objects** if for every object :math:`D âˆˆ \mathcal D`, there is some :math:`A âˆˆ \mathcal C` such that :math:`F A` is isomorphic to :math:`D`.

    existential image functor
      the functor :math:`âˆƒ f : P(A) â†’ P(B)` defined by :math:`âˆƒ f(X) = \{f(x) : x âˆˆ  X\},` for :math:`X âˆˆ P(A)`.

    eval
      If :math:`A` and :math:`B` are types, then the **eval** (or **function application**) function on :math:`A` and :math:`B` is denoted by :math:`\mathbf{eval}: ((A â†’ B) Ã— A) â†’ B` and defined by :math:`\mathbf{eval} (f, a) = f\, a`, for all :math:`f: A â†’ B` and :math:`a: A`.

    evaluation functor
      The **evaluation functor** is the functor :math:`Ev : \mathcal C Ã— \mathbf{Set}^{\mathcal C} â†’ \mathbf{Set}`, which takes each pair :math:`(A, F) âˆˆ \mathcal C_{\mathrm{obj}} Ã— \mathbf{Set}^{{\mathcal C}_{\mathrm{obj}}}` of objects to the set :math:`Ev(A, F) = FA`, and takes each pair :math:`(g, Î¼) âˆˆ \mathcal C_{\mathrm{obj}} Ã— \mathbf{Set}^{\mathcal C_{\mathrm{mor}}}` of morphisms to a function on sets, namely, :math:`Ev(g, Î¼) = Î¼_{A'} âˆ˜ F g = F' g âˆ˜ Î¼_A`, where :math:`g âˆˆ \mathcal C(A, A')` and :math:`Î¼ : F â‡’ F'`.

    evaluation natural transformation
      The **evaluation natural transformation** is denoted by :math:`eval^A : F_A â†’  \mathrm{id}_{\mathbf{Set}}` and defined by... (**Todo** complete definition)

    extensional
      An *extensional* definition of a term lists everything that qualifies as something to which that term refers. See also :term:`function extensionality`.

    faithful functor
      A functor :math:`F : \mathcal C â†’ \mathcal D` is called **faithful** if for all objects :math:`A`, :math:`B` in :math:`\mathcal C_{\mathrm{obj}}`, the map :math:`\mathcal C(A, B) â†’ \mathcal D(F A, F B)` is injective.
      
      (Note: A faithful functor need not be injective on morphisms.)

    finite ordinals
      The category :math:`\mathrm{Ord}_{\mathrm{fin}}` of **finite ordinals** (also called the **simplex category** :math:`\Delta`) has :math:`\underline n = \{0, 1, \dots, n-1\}` for objects (for each :math:`n âˆˆ â„•`) and :math:`f : \underline n â†’ \underline m` :term:`monotone functions <monotone function>` for morphisms.

    fork
      Let :math:`A` and :math:`D` be types and for each :math:`a: A`, let :math:`C_a` be a type. Then the (dependent) **fork function**, denoted
   
      .. math:: \mathbf{fork}: âˆ_{a:A}(C_a â†’ D) â†’ âˆ_{a:A} C_a â†’ âˆ_{a:A} (C_a â†’ D) Ã— C_a,
      
      is defined as follows: for all :math:`h: âˆ_{a:A}(C_a â†’ D)` and :math:`k: âˆ_{a:A} C_a`,
      
      .. math:: \mathbf{fork}\, (h)(k): âˆ_{a:A}((C_a â†’ D) Ã— C_a),

      and for each :math:`a:A`,

      .. math:: \mathbf{fork}\, (h)(k)(a) = (h\,a, k\,a): (C_a â†’ D) Ã— C_a.

      Thus, :math:`\mathbf{eval} \, \mathbf{fork}\, (h)(k)(a) = (h\, a)(k\, a)` is of type :math:`D`. See also :numref:`general-composition`.

    free algebra
      Let :math:`\mathcal V` be a variety of algebras of a certain :term:`signature`. Let :math:`X` be a set.  The **free algebra generated by** :math:`X` is denoted by :math:`\mathbb F(X)` and is defined as follows: for every algebra :math:`\mathbf A = âŸ¨A, \dotsâŸ© âˆˆ \mathcal V` and every function :math:`f : X â†’ A`, there exists a unique homomorphism :math:`h:\mathbb F(X) â†’ \mathbf A` such that :math:`\forall x âˆˆ X, h(x) = f(x)`.  We say that :math:`\mathbb F (X)` is *universal for* :math:`\mathcal V`.

    free monoid
      .. todo:: fill in definition

    full embedding
      a :term:`fully faithful functor` that is injective on objects.

    full functor
      A functor :math:`F : \mathcal C â†’ \mathcal D` is called **full** if for all objects :math:`A`, :math:`B` in :math:`\mathcal C`, the map :math:`\mathcal C(A, B) â†’ \mathcal D(F A, F B)` is surjective.
      
      (N.B. A full functor need not be surjective on morphisms.)

    full subcategory
      If there exists a :term:`full embedding` :math:`F : \mathcal C â†’ \mathcal D`, then :math:`\mathcal C` is called a **full subcategory** of :math:`\mathcal D`.

    fully faithful functor
      a functor that is both :term:`full <full functor>` and :term:`faithfull <faithful functor>`.

    function extensionality
      the principle that takes two functions :math:`f : X â†’ Y` and :math:`g : X â†’ Y` to be equal just in case :math:`f(x) = g(x)` holds for all :math:`x : X`; such functions are sometimes called :term:`Leibniz equal`.

      In Lean, one defines function extensionality for functions of (dependent) type :math:`Î (x:Î±), Î² x` as follows:

      .. code-block:: lean

         def equiv (fâ‚ fâ‚‚: Î  x:Î±, Î² x): Prop := âˆ€ x, fâ‚ x = fâ‚‚ x

    function application
      See :term:`eval`.

    functional programming
      See https://en.wikipedia.org/wiki/Functional_programming.

    functor
      A **functor** :math:`F : \mathcal C â†’ \mathcal D` consists of a function :math:`F_0` that maps objects of :math:`\mathcal C` to objects of :math:`\mathcal D` and a function :math:`F_1` that maps morphisms of :math:`\mathcal C` to morphisms of :math:`\mathcal D` such that :math:`F` preserves (co)domains of morphisms, identities, and compositions.

    functor category
      The **functor category** from :math:`\mathcal C` to :math:`\mathcal D` has functors :math:`F : \mathcal C â†’ \mathcal D` as objects and natural transformations :math:`Î± : F â‡’ G` as morphisms.

    Galois connection
      See https://en.wikipedia.org/wiki/Galois_connection.

    Galois pair
      See https://en.wikipedia.org/wiki/Galois_connection.

    generalized element
      A morphism :math:`h: X â†’ A` is sometimes called a **generalized element** of :math:`A`. A morphism :math:`f` is mono when it is injective on the generalized elements of its domain.

    general composition
      See :term:`composition of operations`.

    global element
      See :term:`point`.

    graph morphism
      Let :math:`ğ†_1 =(V_1, E_1)` and :math:`ğ†_2 = (V_2, E_2)` be graphs. We say that a pair of functions :math:`f=(f_v,f_e)` is a **graph morphism** from :math:`ğ†_1` to :math:`ğ†_2` provided :math:`f_v : V_1 â†’ V_2`, :math:`f_e : E_1 â†’ E_2`, and for any edge :math:`e = (v_1,v_2) âˆˆ E_1` we have that we have :math:`f_e(e) = (f_v(v_1), f_v(v_2))`.

    group
      A **group** :math:`ğ† = (G, e, \ ^{-1}, â‹†)` consists of a set :math:`G` together with a nullary (constant) operation :math:`e`, a unary (inverse) operation :math:`\ ^{-1}: G â†’ G`, and a binary operation :math:`â‹† : G^2 â†’ G`, such that :math:`(G, e, â‹†)` is a monoid and :math:`x â‹† x^{-1} = e` for all :math:`x âˆˆ G`.

    height
      If :math:`w` is a term, then the **height** of :math:`w` is denoted by :math:`|w|` and defined to be the least :math:`n` such that :math:`w âˆˆ T_n`. See :numref:`terms` for the definition of :math:`T_n`.

      If :math:`Î±` is a type, then we sometimes refer to the **height** of :math:`Î±`, by which we mean the *universe level* of :math:`Î±` See :numref:`leans-type-hierarchy`.
       
    Heyting algebra
      A **Heyting algebra** :math:`âŸ¨L, âˆ§, âˆ¨, âŠ¥, âŠ¤, â†’âŸ©` is a bounded :term:`lattice` with least and greatest elements âŠ¥ and âŠ¤, and a binary "implication" â†’ that satisfies :math:`âˆ€ a, b, c âˆˆ L, \ (c âˆ§ a â‰¤ b \ âŸº \ c â‰¤ a â†’ b)`.  Logically, this says a â†’ b is the weakest proposition for which the modus ponens rule, :math:`\{a â†’ b, a\} âŠ¢ b`, is sound. The class of Heyting algebras forms a variety that is finitely axiomatizable.
   
    Heyting algebra homomorphism
      a :term:`lattice homomorphism` that also preserves Heyting implications; that is, if :math:`x, x' âˆˆ X`, then :math:`f(x â†’ x') = f(x) â†’ f(x')`.

    hom set
      Some authors require that :math:`\mathcal C(A,B)` always be a set and call :math:`\mathcal C(A,B)` the **hom set** from :math:`A` to :math:`B`.

    idempotent
      An operation :math:`f: A^n â†’ A` is called **idempotent** provided :math:`f(a, a, \dots, a) = a` for all :math:`a âˆˆ A`. That is, :math:`f` maps constant tuples to their constant image value.
      
      In other terms :math:`f: (Ï f â†’ A) â†’ A` is idempotent iff for each constant tuple :math:`a: Ï f â†’ A`, say, :math:`âˆ€ i<Ï f, \; a\, i = c`, we have :math:`f\, a = f(c, c, \dots, c) = c`.

    implication elimination
      See the `section on implication <https://leanprover.github.io/logic_and_proof/propositional_logic.html#implication>`_ in the `Logic and Proof`_ book.

    implicit arguments
      See sections `Implicit arguments`_ and `More on implicit arguments`_ of `TPL`_.

    impredicative
      A self-referencing definition is called **impredicative**. A definition is said to be impredicative if it invokes (mentions or quantifies over) the set being defined, or (more commonly) another set which contains the thing being defined.

    inductive set
      A subset :math:`I` of a :term:`preorder` :math:`X` is called **inductive** if :math:`â‹_X D âˆˆ I` for every directed subset :math:`D âŠ† X` contained in :math:`I`. That is, if :math:`D âŠ† I`, and if every finite subset of :math:`D` has an upper bound in :math:`D`, then :math:`D` as a least upper bound in :math:`I`.

    inductive type
      A type is called **inductive** or **inductively defined** if...
      
      See also: :numref:`inductively-defined-types` and the :term:`definition of the recursor <recursor>`.
      
    initial object
      An object :math:`\mathbf{0}` in a category is called an **initial**  (or a **free**) **object** if for every object :math:`A` in the same category there exists a unique morphism :math:`!_A:\mathbf{0}\to A`.
     
    intensional
      An **intensional** definition of a term specifies necessary and sufficient conditions that the term satisfies. In the case of nouns, this is equivalent to specifying all the properties that an object must have in order to be something to which the term refers.

    isomorphism
      A morphism :math:`f: A â†’ B` is called an **isomorphism** if there exists a morphism :math:`g: A â†’ B` such that :math:`g âˆ˜ f= \mathrm{id}_A` and :math:`f âˆ˜ g = \mathrm{id}_B`. We write :math:`f^{-1}` to denote :math:`g` when it exists.

    kernel
      By the kernel of a function :math:`f: A â†’ B` we mean the binary relation on :math:`A` denoted and defined by :math:`\mathrm{ker} f := \{(aâ‚, aâ‚‚) : f aâ‚  = f aâ‚‚\}`.   

    Kleene closure
      See :term:`free monoid`.

    lambda calculus
      See https://en.wikipedia.org/wiki/Lambda_calculus.

    lattice
      a :term:`poset` whose universe is closed under all *finite* meets and joins is called a lattice.
     
    lattice homomorphism
      a function :math:`f: X â†’ Y` preserving finite meets and joins.

    law of the excluded middle
      This is an axiom of classical logic asserting that for all propositions P either Â¬ P or P holds. See also the `LEM Section <https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html?highlight=reduction%20rule#the-law-of-the-excluded-middle>`_ of the :term:`TPIL`.

    lift (n)
      See :term:`lifts (v)`

    lifts (v)
      For :math:`Ï âŠ† Î± Ã— Î±`, and :math:`f: Î± â†’ Î²`, we say that :math:`f` **lifts** to a function on the quotient :math:`Î±/Ï` provided the following implication holds for all :math:`x y: Î±`: if :math:`Ï x y` then :math:`f x = f y`.  The function to which :math:`f` lifts is called the **lift** of :math:`f`.

    Lean
      An :term:`extensional`, :term:`impredicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on :term:`CiC`; url: https://leanprover.github.io/.

    Leibniz equal
      See :term:`function extensionality`.

    locally small category
      A category :math:`\mathcal C` is **locally small** if for every pair :math:`A`, :math:`B` of objects in :math:`\mathcal C` the collection of morphisms from :math:`A` to :math:`B` is a set.

    logically equivalent
      Propositions :math:`P` and :math:`Q` are **logically equivalent** provided :math:`P` implies :math:`Q` and :math:`Q` implies :math:`P`.

    metaprogram
      a program whose purpose is to modify the behavior of other programs; :term:`proof tactics <proof tactic>` form an important class of metaprograms.

    modus ponens
      See :term:`implication elimination`.

    monoid
      A **monoid** :math:`ğŒ = (M, e, â‹†)` consists of a set :math:`M` with a a **unit** element :math:`e âˆˆ M` and a binary operation :math:`â‹† : M^2 â†’ M` such that for all :math:`x,y,z âˆˆ M`, :math:`x â‹† e = x = e â‹† x` and :math:`(x â‹† y) â‹† z = x â‹† (y â‹† z)`.

    monoid homomorphism
      Given monoids :math:`ğŒ_1 = (M_1, e_1, â‹†)` and :math:`ğŒ_2 = (M_2, e_2, âˆ—)` we say that a function :math:`f : M_1 â†’ M_2` is a **monoid homomorphism** from :math:`ğŒ_1` to :math:`ğŒ_2` provided :math:`f` preserves the nullary (identity) and binary operations; that is, :math:`f(e_1) = e_2` and :math:`f (x â‹† y) = f(x) âˆ— f(y)` for all :math:`x, y âˆˆ M_1`.

    monomorphism
      A morphism :math:`f: A â†’ B` is called a **monomorphism** if for every object :math:`X` and every pair :math:`h, h' : X â†’ A` of morphisms, :math:`f âˆ˜ h = f âˆ˜ h'` implies :math:`h = h'`. When :math:`f` is a monomorphism we often say :math:`f` is "mono" and write :math:`f: A â†£ B`.

    monotone function
      Given posets :math:`âŸ¨A, â‰¤á´¬âŸ©` and :math:`(B, â‰¤á´®)` we say that a function :math:`f: A â†’ B` is **monotone** from :math:`âŸ¨A, â‰¤á´¬âŸ©` to :math:`âŸ¨B, â‰¤á´® âŸ©` when for any :math:`x, y âˆˆ A` we have that :math:`x â‰¤á´¬ y` implies that :math:`f(x) â‰¤á´® f(y)`.

    natural isomorphism
      An isomorphism in a functor category is referred to as a **natural isomorphism**.
      
    natural transformation
      Given functors :math:`F, G : \mathcal C â†’ \mathcal D`, a **natural transformation** :math:`Î± : F â‡’ G` is a family :math:`\{Î±_A : A âˆˆ \mathcal C_{\mathrm{obj}}\}` of morphisms in :math:`\mathcal D` indexed by the objects of :math:`\mathcal C` such that, for each :math:`A âˆˆ \mathcal C_{\mathrm{obj}}`, the map :math:`\alpha_A` is a morphism from :math:`FA` to :math:`GA` satisfying the *naturality condition*, :math:`Gf âˆ˜ Î±_A = Î±_B âˆ˜ Ff`, for each :math:`f : A â†’ B` in :math:`\mathcal C_{\mathrm{mor}}`. We shall write :math:`Î± : F â‡’ G : \mathcal C â†’ \mathcal D` to indicate that Î± is a natural transformation from :math:`F` to :math:`G`, where :math:`F, G : \mathcal C â†’ \mathcal D`.

    naturally isomorphic
      If there is a natural isomorphism between the functors :math:`F` and :math:`G`, then we call :math:`F` and :math:`G` **naturally isomorphic**.

    NuPRL
      An :term:`extensional`, :term:`predicative` :term:`ITP` supporting :term:`dependent types <dependent type>` and based on Martin Lof type theory; url: http://www.nuprl.org/

    Ï‰-chain
      Let :math:`âŸ¨ X, â‰¤ âŸ©` be a preordered set. An Ï‰-**chain** is an enumerable :term:`chain`.  That is, a chain the elements of which can be indexed by the natural numbers.

    Ï‰-chain cocomplete
      A :term:`preorder` in which joins of all Ï‰-chains exist is called Ï‰-**chain cocomplete**.

    Ï‰-chain cocomplete poset
      an :term:`antisymmetric` :term:`Ï‰-chain cocomplete` :term:`preorder`.

    opposite category
      Given a category :math:`\mathcal C` the **opposite** (or **dual**) **category** :math:`\mathcal C^{\mathrm{op}}` has the same objects as :math:`\mathcal C` and whenever :math:`f: A â†’ B` is a morphism in :math:`\mathcal C` we define :math:`f : B â†’ A` to be a morphism in :math:`\mathcal C^{\mathrm{op}}`.

    parallel morphisms
      Morphisms :math:`f,g : A â†’ B` are called **parallel morphisms** just in case :math:`\mathrm{src} f = \mathrm{src} g` and :math:`\mathrm{tar} f = \mathrm{tar} g`.
 
    partial function
      A **partial function** from :math:`A` to :math:`B` is a total function on some (potentially proper) subset :math:`\dom_f` of :math:`A`.

    partial order
      See :term:`partial order`.

    partial ordering
      A **partial ordering** (or "partial order") is an :term:`antisymmetric` :term:`preorder`.
      
    partially ordered set
      A **partially ordered set** (or "poset") :math:`âŸ¨X, RâŸ©` is a set :math:`X` along with a :term:`partial ordering` :math:`R` defined on :math:`X`.

    Pi type
      The **Pi type** :math:`Î (x:A),B x`, also known as a **dependent function type**, is a dependent type that generalizes the type :math:`A â†’ B`; it is a :term:`dependent type` because the codomain :math:`B x` depends on the value :math:`x`. See also the `Dependent Types`_ section of the `TPL`_ tutorial.

    point
      Given a category with an initial object :math:`\mathbf{1}` and another object :math:`A`, the morphisms with domain :math:`\mathbf{1}` and codomain :math:`A` are called the **points** or **global elements** of :math:`A`.

    polymorphic function
      a function that operates in the "same way" independently of the object parameter.

    polymorphic type
      (to do: fill in definition)

    poset
      A **poset** :math:`âŸ¨X, âŠ‘âŸ©` consists of a set :math:`X` and an :term:`antisymmetric` :term:`preorder` :math:`âŠ‘` on :math:`X`.

    power set operator
      The **powerset operator** :math:`ğ’«` maps a class :math:`X` to the class :math:`ğ’« (X)` of all subsets of :math:`X`.
 
    predicative
      The opposite of :term:`impredicative`, *predicative* refers to building stratified (or ramified) theories where quantification over lower levels results in variables of some new type, distinguished from the lower types that the variable ranges over.

    preorder
      A **preorder** on a set :math:`X` is a :term:`reflexive` and :term:`transitive` subset of :math:`X Ã— X`.

    preserves
      See :term:`respects`.

    product
      Given two objects :math:`A` and :math:`B` a **product** of :math:`A` and :math:`B` is defined to be an object, :math:`A Ã— B`, along with morphisms :math:`p_1: A Ã— B â†’ A` and :math:`p_2: A Ã— B â†’ B` such that for every object :math:`X` and all morphisms :math:`x_1: X â†’ A` and :math:`x_2: X â†’ B` there exists a unique morphism :math:`h: X â†’ A Ã— B` such that :math:`p_1 âˆ˜ h = x_1` and :math:`p_2 âˆ˜ h = x_2`.  We usually use :math:`Ï€_1: A Ã— B â†’ A` and :math:`Ï€_2: A Ã— B â†’ B` to denote the projections and :math:`âŸ¨x_1, x_2âŸ©` for the unique map :math:`h: X â†’ A Ã— B`.

    projection operation
      The :math:`i`**-th** :math:`k`**-ary projection operation on** :math:`A` is denoted by :math:`Ï€^k_i: (k â†’ A) â†’ A` and defined for each :math:`k`-tuple :math:`a: k â†’ A` by :math:`Ï€^k_i \, a  = a\, i`.  

    projection operator
      If :math:`Ïƒ: k â†’ n` is a :math:`k`-tuple of numbers in the set :math:`n = \{0, 1, \dots, n-1\}`, then we can compose an :math:`n`-tuple :math:`a âˆˆ âˆ_{0â‰¤i<n} A_i` with :math:`Ïƒ` yielding :math:`a âˆ˜ Ïƒ âˆˆ âˆ_{0â‰¤i<k} A_{Ïƒ\, i}`.

      The result is a :math:`k`-tuple whose :math:`i`-th component is :math:`(a âˆ˜ Ïƒ)(i) = a(Ïƒ(i))`.

      If :math:`Ïƒ` happens to be one-to-one, then we call the following a **projection operator**:

      .. math:: \Proj\, Ïƒ: âˆ_{0â‰¤i< n} A_i â†’ âˆ_{0â‰¤i<k} A_{Ïƒ\, i};  \ \ a â†¦ a âˆ˜ Ïƒ.

      That is, for :math:`a âˆˆ âˆ_{0â‰¤i<n} A_i` we define :math:`\Proj\,Ïƒ\, a = a âˆ˜ Ïƒ`.

    proof assistant
      See :term:`ITP`.

    proof-irrelevant
      .. todo:: insert definition

    proofs-as-programs
      In :term:`type theory`, constructing a proof of a proposition ``P`` is equivalent to constructing an inhabitant of the type to which ``P`` corresponds (under the :term:`propositions-as-types` correspondence). The construction of such a proof ``p: P`` is viewed as a program that computes ``p`` as output.  See also https://ncatlab.org/nlab/show/proofs+as+programs and :term:`Curry-Howard correspondence` and :term:`propositions-as-types`.

    proof tactic    
      an automated procedure for constructing and manipulating proof terms.

    propositions-as-types
      In :term:`type theory`, the propositions-as-types correspondence says that propositions and types are essentially the same. A proposition, when viewed as a type, is identified with the collection (or type) of all its proofs, and a type is identified with the proposition that there exists something of that type.  See also https://ncatlab.org/nlab/show/propositions+as+types and :term:`Curry-Howard correspondence` and :term:`proofs-as-programs`.

    proposition extensionality
      This axiom asserts that when two propositions imply one another, they are actually equal. This is consistent with set-theoretic interpretations in which any element ``a:Prop`` is either empty or the singleton set ``{*}``, for some distinguished element ``*``. The axiom has the effect that equivalent propositions can be substituted for one another in any context. See also the `Proposition Extensionality <https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#propositional-extensionality>`_ section of the :term:`TPIL`.

    quotient
      If :math:`R` is an :term:`equivalence relation` on :math:`A`, then the **quotient** of :math:`A` modulo :math:`R` is denoted by :math:`A/R` and is defined to be the collection :math:`\{ a/R âˆ£ a âˆˆ A \}` of :term:`equivalence classes <equivalence class>` of :math:`R`.

    recursor
      Each :term:`inductively defined type <inductive type>` ``T`` is accompanied by an elimination principle known as a **recursor** (denoted by ``T.rec`` in Lean). It is what makes the type "inductive" by allowing us to define a function on ``T`` by assigning values for each of ``T``'s constructors. See also :numref:`inductively-defined-types`.

    reflexive
      A binary relation :math:`R` on a set :math:`X` is called **reflexive** provided :math:`âˆ€ x âˆˆ X, \ x \mathrel{R} x`.

    relation
      Given sets :math:`A` and :math:`B`, a **relation** from :math:`A` to :math:`B` is a subset of :math:`A Ã— B`.

    relational product
      Given relations :math:`R : A â†’ B` and :math:`S : B â†’ C` we denote and define the **relational product** (or **composition**) of :math:`S` and :math:`R` to be :math:`S âˆ˜ R = \{(a,c) : (âˆƒ b âˆˆ B) a \mathrel{R} b âˆ§ b \mathrel{S} c \}`.

    relational structure
      A relational structure :math:`ğ”¸ = âŸ¨A, â„›âŸ©` is a set :math:`A` together with a collection :math:`â„›` of relations on :math:`A`.

    respects
      Given a function :math:`f: Î± â†’ Î±`, we say that :math:`f` **respects** (or **preserves**) the binary relation :math:`R âŠ† Î± Ã— Î±`, and we write :math:`f âŠ§ R`, just in case :math:`âˆ€ x, y :Î± \ (x \mathrel R y \ â†’ \ f x \mathrel R f y)`.
        
      (The symbol âŠ§ is produced by typing ``\models``.)

      If :math:`f: (Î² â†’ Î±) â†’ Î±` is a :math:`Î²`-ary operation on :math:`Î±`, we can extend the definition of ":math:`f` respects :math:`R`" in the obvious way.
      
      First, for every pair :math:`u : Î² â†’ Î±` and :math:`v : Î² â†’ Î±` (:math:`Î²`-tuples of :math:`Î±`), we say that :math:`(u, v)` "belongs to" :math:`R âŠ† Î± Ã— Î±` provided
      
      .. math:: âˆ€ i: Î² \ ui \mathrel R vi
      
      Then we say :math:`f:  (Î² â†’ Î±) â†’ Î±` **respects** (or **preserves**) the binary relation :math:`R âŠ† Î± Ã— Î±`, and we write :math:`f âŠ§ R`, just in case :math:`âˆ€ u, v, \ [(âˆ€ i: Î², \ u i \mathrel R v i) \ â†’ \ f u \mathrel R f v]`.
        
    self-dual
      A category :math:`\mathcal C` is called **self-dual** if :math:`\mathcal C^{\mathrm{op}} = \mathcal C`.

    Ïƒ-algebra
      See :term:`algebraic structure`.

    Sigma type
      The **Sigma type** :math:`Î£(x:A),B x`, also known as the **dependent pair type**, generalizes the Cartesian product :math:`A Ã— B` by allowing the type :math:`B x` of the second argument of the ordered pair to depend on the value :math:`x` of the first.  See also the `Dependent Types`_ section of the `TPL`_ tutorial.

    signature
      a pair :math:`Ïƒ = (F, Ï)` consisting of a collection :math:`F` of operation symbols and an :term:`arity` function :math:`Ï : F â†’ Î²` that maps each operation symbol to its :term:`arity`; here, :math:`Î²` denotes the arity type.

    simplex category
      See :term:`finite ordinals`.

    small category
      A category is called **small** if both its objects and morphisms form sets.

    source vertex
      Given a directed graph :math:`\mathbf G = (V,E)` and an edge :math:`e=(v_1,v_2) âˆˆ E`, we refer to :math:`v_1` as the **source vertex** of :math:`e`.

    subalgebra
      Suppose :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` is an algebra. If :math:`B â‰  âˆ…` is a :term:`subuniverse` of ğ”¸, and if we let :math:`F^ğ”¹ = \{ f â†¾ B : f âˆˆ F^ğ”¸ \}`, then :math:`ğ”¹ = âŸ¨ B, F^ğ”¹ âŸ©` is an algebra, called a **subalgebra** of ğ”¸.

    subdcpo
      If :math:`X` is a :term:`dcpo` then the subset :math:`A âŠ† X` is a **subdcpo** of :math:`X` if every directed subset :math:`D âŠ† A` satisfies :math:`â‹_X D âˆˆ A`.

    subuniverse
      Suppose :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` is an algebra. If a subset :math:`B âŠ† A` is closed under :math:`F^ğ”¸`, then we call :math:`B` a **subuniverse** of :math:`ğ”¸`.

    symmetric
      A binary relation :math:`R` on a set :math:`X` is called **symmetric** provided :math:`âˆ€ x, y âˆˆ X \ (x \mathrel{R} y \ â†’ \ y \mathrel{R} x)`;

    target vertex
      Given a directed graph :math:`\mathbf G = (V,E)` and an edge :math:`e=(v_1,v_2)\in E`, we refer to :math:`v_2` as the **target vertex** of :math:`e`.

    terminal object
      An object :math:`\mathbf{1}` is called a **terminal** (or **bound**) **object** if for every object :math:`A` in the same category there exists a unique morphism :math:`âŸ¨\ âŸ©_A: A â†’ \mathbf{1}`.

    total function
      Given sets :math:`A` and :math:`B`, a **total function** :math:`f` from :math:`A` to :math:`B` is what we typically mean by a â€œfunctionâ€ from :math:`A` to :math:`B`.

    total order
      A **total order** relation :math:`R` on a set :math:`X` is a partial order on :math:`X` satisfying :math:`âˆ€ x, y âˆˆ X \ (x â‰¤ y \ â‹ \ y â‰¤ x)`.

    transitive
      A binary relation :math:`R` on a set :math:`X` is called **transitive** provided :math:`âˆ€ x, y, z âˆˆ X \ (x \mathrel{R} y âˆ§ y \mathrel{R} z\ â†’ \ x \mathrel{R} z)`.

    type theory
      Intuitionistic **type theory** extends the :term:`Curry-Howard correspondence` to predicate logic by introducing :term:`dependent types <dependent type>`. :term:`TT` internalizes the interpretation of intuitionistic logic proposed by Brouwer, Heyting, and Kolmogorov---the so-called BHK interpretation. The types in :term:`TT` play a similar role to that of sets in set theory but *functions definable in TT are always computable*. See also `ncatlab.org/type+theory <https://ncatlab.org/nlab/show/type+theory>`_.

    underlying set functor
      The **underlying set functor** of :math:`ğŒ` is denoted by :math:`U(ğŒ)`, or by :math:`|ğŒ|`; it returns the *universe* of the structure :math:`ğŒ`, and for each morphism :math:`f`, :math:`Uf` (or :math:`|f|`) is :math:`f` viewed simply as a function on sets.

    universal image functor
      the functor :math:`âˆ€ f : P(A) â†’ P(B)` defined by :math:`âˆ€ f (X) = \{y âˆˆ B : f^{-1}(\{y\}) \subseteq  X\}`, for :math:`X âˆˆ P(A)`.

    universal mapping property
      Let :math:`Î·_A : A â†’ |ğ”¸^*|` be the function that maps :math:`a âˆˆ A` to the "one-letter word" :math:`a âˆˆ A^*`. The functors :math:`K (= \ ^âˆ—)` and :math:`U (= |\ |)` are related by the **universal mapping property** of monoids, which says that for every monoid :math:`ğŒ` and every function :math:`f : A â†’ U ğŒ` there exists a unique morphism :math:`fÌ‚ : KA â†’ ğŒ` such that :math:`f = fÌ‚ âˆ˜ Î·`.

    universal property
      The unique morphism property of :term:`initial object` is what we refer to as a **universal property,** and we say that the free object in a category :math:`\mathcal C` is *universal for* all other objects in :math:`\mathcal C`.

    universe
      In :term:`type theory`, everything has a type---even a type has a type.  If ``Î±`` is a type, then ``Î±``'s type is ``Type u`` for some **universe** ``u``.  More accurately, the ``u`` here is actually a variable and whatever (natural number) value it takes on will be the universe *level* of the type ``Î±``.

      In universal algebra, the universe of an algebra is the set over which the algebra is defined.  For example, the universe of the algebra :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` is :math:`A`.  (**N.B.** we sometimes use the word **carrier** to mean universe in this sense, which can be helpful when we wish to avoid confusion with the universe levels of Lean's type hierarchy.)

    universe polymorphism
      We use an example to demonstrate this concept. Given a type ``Î±``, no matter to which type universe ``Î±`` belongs, we can form the type ``list Î±`` of lists of elements of type ``Î±``, and this type will have the same type universe as ``Î±``. In other terms, 
      
        ``Î±: Type u`` if and only if ``list Î±: Type u``.
        
      The Lean code for this example follows.

      :: 

        universes u v
        variables (Î±: Type u) (Î²: Type v)
        #check list      -- Type u_1 â†’ Type u_1
        #check list Î±    -- Type u
        #check list Î²    -- Type v

      The variable ``u_1`` ranges over type levels.  As the output of the ``#check`` shows, ``list Î±`` has ``Type u`` because ``Î±`` has ``Type u``. Similarly for ``list Î²``. 

--------------------------------

Categories
----------

.. glossary::

    1
      The only object is :math:`0`; the only morphism is the identity :math:`\id_0: 0 â†¦ 0`.

    2
      There are two objects, :math:`0` and :math:`1`; there is one nonidentity morphism :math:`f: 0 â†¦ 1`.

    3
      There are three objects, :math:`0`, :math:`1`, and :math:`2`; there are three nonidentity morphisms: :math:`f: 0 â†¦ 1`, :math:`g: 1 â†¦ 2`, and :math:`h: 0 â†¦ 2`.

    Cat 
      the (large) category of small categories; it has small categories as objects and functors :math:`F : \mathcal C â†’ \mathcal D` as morphisms.

    Set
      the category whose objects are the sets and whose morphisms are the functions on sets.

    Grph
      the category whose objects are the (directed) graphs; the morphisms are the :term:`graph morphisms <graph morphism>`.

    Mon
      the category whose objects are the :term:`monoids <monoid>` and whose morphisms are the :term:`monoid homomorphisms <monoid homomorphism>`.

    Par
      the category whose objects are sets and whose morphisms are the :term:`partial functions <partial function>`.

    Rel
      the category whose objects are sets and whose morphisms are the :term:`relations <relation>` on sets.

    Fin
      a category whose objects are the finite sets; the morphisms are the functions on finite sets.

    Pos
      a category whose objects are the :term:`posets <poset>`; the morphisms are the :term:`monotone functions <monotone function>`.

    Lat
      a category whose objects are the :term:`lattices <lattice>`; the morphisms are the :term:`lattice homomorphisms <lattice homomorphism>`.

    CLat
      a category whose objects are the :term:`complete lattices <complete lattice>`; the morphisms are the :term:`complete lattice homomorphisms <complete lattice homomorphism>`.

    BLat
      a category whose objects are the :term:`Boolean lattices <Boolean algebra>`; the morphisms are the :term:`Boolean lattice homomorphisms <Boolean algebra homomorphism>`.

    HLat
      a category whose objects are the :term:`Heyting lattices <Heyting algebra>`; the morphisms are the :term:`Heyting lattice homomorphisms <Heyting algebra homomorphism>`

    ACLat
      a category whose objects are :term:`algebraic <algebraic lattice>`, :term:`complete lattices <complete lattice>`; the morphisms are the :term:`complete lattice homomorphisms <complete lattice homomorphism>`.

    Arrow
      Given a category :math:`\mathcal C`, the **arrow category** :math:`\mathcal C^â†’` has as objects the triples :math:`(A, B, f)` satisfying :math:`A, B âˆˆ  \mathcal C_{\mathrm{obj}}` and :math:`f âˆˆ \mathcal C(A,B)`, and as morphisms the pairs :math:`(h_1, h_2) : (A, B, f) â†’ (C, D, g)` such that :math:`h_1 âˆˆ \mathcal C(A,C)`, :math:`h_2 âˆˆ \mathcal C(B, D)` and :math:`g \circ h_1 = h_2 \circ f`.

    Slice
      Given a category :math:`\mathcal C` and an object :math:`C âˆˆ \mathcal C_{\mathrm{obj}} `, the **slice category** :math:`\mathcal C/C` has objects the pairs :math:`(A, f)` such that :math:`f âˆˆ \mathcal C(A, C)`, and morphisms :math:`h : (A, f) â†’ (B, g)` such that :math:`h âˆˆ \mathcal C(A, B)` and :math:`g âˆ˜ h = f`.

    Comma
      Given categories :math:`\mathcal C` and :math:`\mathcal D` and functors :math:`F : \mathcal C â†’ \mathcal D` and :math:`G : \mathcal C' â†’ \mathcal D` (with a common :term:`codomain`), the **comma category** is denoted by :math:`(F â†“ G)` and has objects the triples :math:`(A, f, A')`, where :math:`A âˆˆ \mathcal C_{\mathrm{obj}}`, :math:`A' âˆˆ \mathcal C'_{\mathrm{obj}}`, and :math:`f âˆˆ \mathcal D(FA, GA')`, and morphisms the pairs :math:`(Ï†, Ïˆ) : (A, f, A') â†’ (B, g, B')`, where :math:`Ï† âˆˆ \mathcal C(A, B)`, :math:`Ïˆ âˆˆ \mathcal C'(A',B')` and :math:`G Ïˆ âˆ˜ f = g âˆ˜ F Ï†`.

--------------------------------

.. _symbol-commands:

Symbols
-------

The list below shows what to type (e.g., in the vscode IDE with lean extension) to produce some of the special characters used in the `lean-ualib`_.

.. glossary::

    { }
      Surrounds implicit argument(s) and directs parser to use *agressive* type inference; see :numref:`implicit-arguments`.

    â¦ƒ â¦„
      (Type with ``\{{``.) Surrounds implicit argument(s) and directs parser to use *conservative* type inference; see :numref:`implicit-arguments`.

    ğ”¸
      ``\A`` (or ``\BbbA``)

    ğ”¹ 
      ``\BbbB``

    â„‚
      ``\C`` (or ``\BbbC``)

    â„•
      ``\N`` (or ``\nat`` or ``\BbbN``)
      
    ğ•‹ 
      ``\BbbT``
      
    â„¤
      ``\Z`` (or ``\Int`` or ``\BbbZ``)

    â„’
      ``\mscrL``

    hâ‚
      ``h\1`` (or ``h\_1``)
      
    hâ‚‚
      ``h\2``, etc.

    fâ‚—
      ``f\_l``
  
    fÌƒ
      ``f\tilde``

    RÌƒ
      ``R\tilde``

    fÌ‚
      ``f\hat``                          

    Ã¥
      ``\aa``
  
    Ä›
      ``\ve``
    
    Ã¶
      ``\"o``
      
    Ã§
      ``\cc``

    Î±
      ``\a`` (or ``\alpha``)
      
    Î²
      ``\b``
      
    Î³
      ``\g``

    Î“ 
      ``\G``

    Î´
      ``\de`` (or ``\delta``)

    Î” 
      ``\D`` (or ``\Delta``)

    Îµ
      ``\e`` (or ``\epsilon``)

    Î¹
      ``\iota``

    Î»
      ``\lamda`` (or ``\Gl`` or ``\la`` or ``\fun``)
      
    Î›
      ``\L`` (or ``\GL`` or ``\Lambda``)

    Ï
      ``\rho``

    Ïƒ
      ``\s`` (or ``\sigma``)
      
    Î£
      ``\S`` (or ``\Sigma``)
      
    âˆ‘
      ``\sum``

    âˆ
      ``\prod``

    Î 
      ``\p`` (or ``\Pi``)

    Ï€
      ``\pi``
       
    Ï•
      ``\phi``

    Î¦
      ``\Phi``

    Ã¦
      ``\ae``

    Ã†
      ``\AE``

    Å“
      ``\oe``
    
    Å’
      ``\OE``

    âˆ©
      ``\i``  (or ``\cap`` or ``\intersection``)
  
    â‹‚
      ``\I`` (or ``\bigcap`` or ``\Intersection``)
  
    âˆª
      ``\un`` (or ``cup`` or ``\union``)
  
    â‹ƒ
      ``\Un`` (or ``\bigcup`` or ``\Union``)

    âˆ§
      ``\an`` (or ``\and`` or ``\wedge``)

    â‹€
      ``\And`` (or ``\bigwedge``)

    âˆ¨
      ``\vee`` (or ``\or``)

    â‹
      ``\Or`` (or ``\bigvee``)

    Â¬
      ``\n`` (or ``\neg``)

    âˆ˜
      ``\o`` (or ``\circ``)

    âŠš
      ``\oo``

    Ã—
      ``\x`` (or ``\times``)

    âˆƒ
      ``\ex`` (or ``\exists``)

    âˆ€
      ``\al`` (or ``\all`` or ``\forall``)

    âˆˆ
      ``\in``

    âˆ‹
      ``\ni``

    âˆ‰
      ``\inn``, ``\nin`` (or ``\notin``, ``\nni``)

    â‰¤
      ``\leq``

    â‰¥
      ``\geq``                               

    âŠ†
      ``\ss`` (or ``\subseteq``)

    âŠ‡
      ``\supseteq``        

    âŠ‚
      ``\subset``

    âŠƒ
      ``\supset``                         

    â‰ª
      ``\ll``

    â‰«
      ``\gg``                                 

    â‹†
      ``\star``

    âˆ—
      ``\ast``                              

    â‰ˆ
      ``\~~`` (or ``\approx``)

    âˆ¼
      ``\sim``               

    â‰¡
      ``\equiv``

    â‰…
      ``\cong``                            

    âŸ¨
      ``\<`` (or ``\langle``)


    âŸ©
      ``\>`` (or ``\rangle``)     

    â€¹
      ``\f<`` (or ``\f``)

    â€º
      ``\f>`` (or ``\fr``)            

    â—€
      ``\T``

    â–¸
      ``\t``                                   

    â†
      ``\l`` (or ``->``)

    â†’
      ``\to`` (or ``\r``)            

    âŸ¶
      ``\hom`` (or ``-->``)                            

    â†‘
      ``\u``

    â†“
      ``\d``                                   

    âŸ¹
      ``==>`` (or ``\nattrans``)                       

    âŸº
      ``\iff``                                         

    â†¦
      ``\mapsto`` (or ``\r-``)                        |

    â† 
      ``\rr`` or ``\twoheadrightarrow``                

    â†£
      ``\pr`` or ``\r->``                              

    âˆ…
      ``\emp`` (or ``\empty`` or ``\emptyset``)        

    âŠ¢
      ``\vdash``

    âŠ¨
      ``\vDash``

    â«¢
      ``\vDdash``

    âŠ§
      ``\models``              

    â‹ˆ
      ``\j`` (or ``\bowtie``)

      
.. .. rubric:: Footnotes

.. .. [1]

.. include:: hyperlink_references.rst

.. computationally pure
..   An expression is called **computationally pure** if
..   .. todo:: complete definition

.. pure
..   see :term:`computationally pure`

.. universe
..   .. todo:: insert definition
.. universes
..   see :term:`universe`
