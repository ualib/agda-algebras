---
layout: default
title : Structures.Graphs0
date : 2021-06-22
author: [agda-algebras development team][]
---

N.B. This module differs from Graphs.lagda in that here we assume some universes are level zero (i.e., â„“â‚€). This simplifies some things; e.g., we avoid having to use lift and lower (cf. Graphs.lagda)

Definition [Graph of a structure]. Let ğ‘¨ be an (ğ‘…,ğ¹)-structure (relations from ğ‘… and operations from ğ¹).
The *graph* of ğ‘¨ is the structure Gr ğ‘¨ with the same domain as ğ‘¨ with relations from ğ‘… and together with a (k+1)-ary relation symbol G ğ‘“ for each ğ‘“ âˆˆ ğ¹ of arity k, which is interpreted in Gr ğ‘¨ as all tuples (t , y) âˆˆ AáµâºÂ¹ such that ğ‘“ t â‰¡ y. (See also Definition 2 of https://arxiv.org/pdf/2010.04958v2.pdf)


\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

module Structures.Graphs0 where

open import Agda.Primitive          using    ( _âŠ”_ ; Level )
                                    renaming ( Set to Type ; lzero to â„“â‚€ )
open import Agda.Builtin.Equality   using    ( _â‰¡_ ; refl )
open import Data.Product            using    ( _,_ ; _Ã—_ ; Î£-syntax )
open import Data.Sum.Base           using    ( _âŠ_ )
                                    renaming ( injâ‚ to inl ; injâ‚‚ to inr )
open import Data.Fin.Base                         using ( Fin )
open import Data.Nat                              using ( â„• )
open import Function.Base           using    ( _âˆ˜_ )
open import Relation.Unary          using    ( Pred ; _âˆˆ_ ) -- âˆ…; Pred ; _âŠ†_ ; â‹‚ ; ï½›_ï½ ; _âˆª_ )
import Relation.Binary.PropositionalEquality as PE

-- -- Imports from agda-algebras --------------------------------------------------------------
open import Overture.Preliminaries using ( ğŸ™ ; âˆ£_âˆ£ ; âˆ¥_âˆ¥ )
open import Relations.Continuous   using ( Rel )
open import Structures.Basic       using ( signature ; structure )
open import Structures.ExamplesOfSignatures
                                   using ( Sâˆ… )
open import Structures.Homs        using ( hom ; is-hom-rel ; is-hom-op )
open import Structures.Terms.Basic       using ( Term )
open import Structures.EquationalLogic   using ( fMod )


open signature
open structure
open _âŠ_

Gr-sig : signature â„“â‚€ â„“â‚€ â†’ signature â„“â‚€ â„“â‚€ â†’ signature â„“â‚€ â„“â‚€

Gr-sig ğ¹ ğ‘… = record { symbol = symbol ğ‘… âŠ symbol ğ¹
                    ; arity  = ar }
 where
 ar : symbol ğ‘… âŠ symbol ğ¹ â†’ Type â„“â‚€
 ar (inl ğ‘Ÿ) = (arity ğ‘…) ğ‘Ÿ
 ar (inr ğ‘“) = (arity ğ¹) ğ‘“ âŠ ğŸ™


private variable
 ğ¹ ğ‘… : signature â„“â‚€ â„“â‚€

Gr : structure ğ¹ ğ‘… {â„“â‚€} {â„“â‚€} â†’ structure Sâˆ… (Gr-sig ğ¹ ğ‘…) {â„“â‚€} {â„“â‚€}
Gr {ğ¹}{ğ‘…} ğ‘¨ = record { carrier = carrier ğ‘¨ ; op = Î» () ; rel = split }
  where
  split : (s : symbol ğ‘… âŠ symbol ğ¹) â†’ Rel (carrier ğ‘¨) (arity (Gr-sig ğ¹ ğ‘…) s) {â„“â‚€}
  split (inl ğ‘Ÿ) arg = rel ğ‘¨ ğ‘Ÿ arg
  split (inr ğ‘“) args = op ğ‘¨ ğ‘“ (args âˆ˜ inl) â‰¡ args (inr ğŸ™.ğŸ)


open PE.â‰¡-Reasoning

module _ {ğ‘¨ ğ‘© : structure ğ¹ ğ‘… {â„“â‚€}{â„“â‚€}} where

 homâ†’Grhom : hom ğ‘¨ ğ‘© â†’ hom (Gr ğ‘¨) (Gr ğ‘©)
 homâ†’Grhom (h , hhom) = h , (i , ii)
  where
  i : is-hom-rel (Gr ğ‘¨) (Gr ğ‘©) h
  i (inl ğ‘Ÿ) a x = âˆ£ hhom âˆ£ ğ‘Ÿ a x
  i (inr ğ‘“) a x = goal
   where
   homop : h (op ğ‘¨ ğ‘“ (a âˆ˜ inl)) â‰¡ op ğ‘© ğ‘“ (h âˆ˜ (a âˆ˜ inl))
   homop = âˆ¥ hhom âˆ¥ ğ‘“ (a âˆ˜ inl)

   goal : op ğ‘© ğ‘“ (h âˆ˜ (a âˆ˜ inl)) â‰¡ h (a (inr ğŸ™.ğŸ))
   goal = op ğ‘© ğ‘“ (h âˆ˜ (a âˆ˜ inl)) â‰¡âŸ¨ PE.sym homop âŸ©
          h (op ğ‘¨ ğ‘“ (a âˆ˜ inl))   â‰¡âŸ¨ PE.cong h x âŸ©
          h (a (inr ğŸ™.ğŸ))         âˆ

  ii : is-hom-op (Gr ğ‘¨) (Gr ğ‘©) h
  ii = Î» ()


 Grhomâ†’hom : hom (Gr ğ‘¨) (Gr ğ‘©) â†’ hom ğ‘¨ ğ‘©
 Grhomâ†’hom (h , hhom) = h , (i , ii)
  where
  i : is-hom-rel ğ‘¨ ğ‘© h
  i R a x = âˆ£ hhom âˆ£ (inl R) a x
  ii : is-hom-op ğ‘¨ ğ‘© h
  ii f a = goal
   where
   split : arity ğ¹ f âŠ ğŸ™ â†’ carrier ğ‘¨
   split (inl x) = a x
   split (inr y) = op ğ‘¨ f a
   goal : h (op ğ‘¨ f a) â‰¡ op ğ‘© f (Î» x â†’ h (a x))
   goal = PE.sym (âˆ£ hhom âˆ£ (inr f) split refl)

\end{code}

{- Lemma III.1. Let S be a signature and A be an S-structure.
Let Î£ be a finite set of identities such that A âŠ§ Î£. For every
instance X of CSP(A), one can compute in polynomial time an
instance Y of CSP(A) such that Y âŠ§ Î£ and | Hom(X , A)| = |Hom(Y , A)|.

Proof. âˆ€ s â‰ˆ t in â„° and each tuple b such that ğ‘© âŸ¦ s âŸ§ b â‰¢ ğ‘© âŸ¦ t âŸ§ b, one can compute
the congruence Î¸ = Cg (ğ‘© âŸ¦ s âŸ§ b , ğ‘© âŸ¦ t âŸ§ b) generated by ğ‘© âŸ¦ s âŸ§ b and ğ‘© âŸ¦ t âŸ§ b.
Let ğ‘©â‚ := ğ‘© / Î¸ , and note that | ğ‘©â‚ | < | ğ‘© |.

We show âˆƒ a bijection from hom ğ‘© ğ‘¨ to hom ğ‘©â‚ ğ‘¨.
Fix an h : hom ğ‘© ğ‘¨.
âˆ€ s â‰ˆ t in â„°, we have h (ğ‘© âŸ¦ s âŸ§ b) = ğ‘¨ âŸ¦ s âŸ§ (h b) = ğ‘¨ âŸ¦ t âŸ§ (h b) = h (ğ‘© âŸ¦ t âŸ§ b).

Therefore, Î¸ âŠ† ker h, so h factors uniquely as h = h' âˆ˜ Ï€ : ğ‘© â†’ (ğ‘© / Î¸) â†’ ğ‘¨,
where Ï€ is the canonical projection onto ğ‘© / Î¸.
Thus the mapping Ï† : hom ğ‘© ğ‘¨ â†’ hom ğ‘©â‚ ğ‘¨ that takes each h to h' such that h = h' âˆ˜ Ï€
is injective.  It is also surjective since each g' : ğ‘© / Î¸ â†’ ğ‘¨ is mapped back to
a g : ğ‘© â†’ ğ‘¨ such that g = g' âˆ˜ Ï€. Iterating over all identities in â„°, possibly
several times, at the final step we obtain a structure ğ‘©â‚™ that satisfies â„°
and is such that âˆ£ hom ğ‘© ğ‘¨ âˆ£ = âˆ£ hom ğ‘©â‚™ ğ‘¨ âˆ£. Moreover, since the number of elements
in the intermediate structures decreases at each step, | ğ‘©áµ¢â‚Šâ‚ | < | ğ‘©áµ¢ |, the process
finishes in time that is bounded by a polynomial in the size of ğ‘©.
-}


\begin{code}

record _â‡›_â‡š_ (ğ‘© ğ‘¨ ğ‘ª : structure ğ¹ ğ‘…) : Type â„“â‚€ where
 field
  to   : hom ğ‘© ğ‘¨ â†’ hom ğ‘ª ğ‘¨
  from : hom ğ‘ª ğ‘¨ â†’ hom ğ‘© ğ‘¨
  toâˆ¼from : âˆ€ h â†’ (to âˆ˜ from) h â‰¡ h
  fromâˆ¼to : âˆ€ h â†’ (from âˆ˜ to) h â‰¡ h


module _ {Ï‡ : Level}{X : Type Ï‡}
         {ğ‘¨ : structure ğ¹ ğ‘… {â„“â‚€} {â„“â‚€}} where

 -- TODO: formalize Lemma III.1

 -- LEMMAIII1 : {n : â„•}(â„° : Fin n â†’ (Term X Ã— Term X))(ğ‘¨ âˆˆ fMod â„°)
 --  â†’          âˆ€(ğ‘© : structure ğ¹ ğ‘…) â†’ Î£[ ğ‘ª âˆˆ structure ğ¹ ğ‘… ] (ğ‘ª âˆˆ fMod â„° Ã— (ğ‘© â‡› ğ‘¨ â‡š ğ‘ª))
 -- LEMMAIII1 â„° ğ‘¨âŠ§â„° ğ‘© = {!!} , {!!}

\end{code}


------------------------------

[agda-algebras development team]: https://github.com/ualib/agda-algebras#the-agda-algebras-development-team



















 -- LEMMAIII1 : (â„° : Pred (Term X Ã— Term X) (â„“â‚€ âŠ” Ï‡))
 --  â†’          (ğ‘¨ âˆˆ Mod â„°)
 --  â†’          âˆ€(ğ‘© : structure ğ¹ ğ‘…)
 --  â†’          Î£[ ğ‘ª âˆˆ structure ğ¹ ğ‘… ] (ğ‘ª âˆˆ Mod â„° Ã— (ğ‘© â‡› ğ‘¨ â‡š ğ‘ª))
 -- LEMMAIII1 â„° ğ‘¨âŠ§â„° ğ‘© = {!!} , {!!}



