---
layout: default
title : Subalgebras.Subuniverses module (The Agda Universal Algebra Library)
date : 2021-01-14
author: William DeMeo
---

### <a id="subuniverses">Subuniverses</a>

This section presents the [Subalgebras.Subuniverses][] module of the [Agda Universal Algebra Library][].

We start by defining a type that represents the important concept of **subuniverse**. Suppose ğ‘¨ is an algebra.  A subset B âŠ† âˆ£ ğ‘¨ âˆ£ is said to be **closed under the operations of** ğ‘¨ if for each ğ‘“ âˆˆ âˆ£ ğ‘† âˆ£ and all tuples ğ’ƒ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ ğµ the element (ğ‘“ Ì‚ ğ‘¨) ğ’ƒ belongs to B. If a subset B âŠ† ğ´ is closed under the operations of ğ‘¨, then we call B a **subuniverse** of ğ‘¨.

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

-- Imports from Agda (builtin/primitive) and the Agda Standard Library
open import Agda.Builtin.Equality using (_â‰¡_; refl)
open import Axiom.Extensionality.Propositional renaming (Extensionality to funext)
open import Data.Product using (_,_; Î£; _Ã—_)
open import Function.Base  using (_âˆ˜_)
open import Level renaming (suc to lsuc; zero to lzero)
open import Relation.Binary.PropositionalEquality.Core using (cong)
open import Relation.Unary using (â‹‚; _âˆˆ_; Pred; _âŠ†_)

-- Imports from the Agda Universal Algebra Library
open import Algebras.Basic
open import Relations.Discrete using (Im_âŠ†_)
open import Overture.Preliminaries
 using (Type; ğ“; ğ“¤; ğ“¥; ğ“¦; ğ“§; Î ; -Î ; -Î£; _â‰¡âŸ¨_âŸ©_; _âˆ; _âˆ™_;_â»Â¹; âˆ£_âˆ£; âˆ¥_âˆ¥)



module Subalgebras.Subuniverses  {ğ‘† : Signature ğ“ ğ“¥} where

open import Algebras.Products{ğ‘† = ğ‘†} using (ov)
open import Homomorphisms.Basic {ğ‘† = ğ‘†} using (hom)
open import Terms.Basic {ğ‘† = ğ‘†} using (Term; â„Š; node)
open import Terms.Operations {ğ‘† = ğ‘†} using (_âŸ¦_âŸ§)


\end{code}

We first show how to represent in [Agda][] the collection of subuniverses of an algebra `ğ‘¨`.  Since a subuniverse is viewed as a subset of the domain of `ğ‘¨`, we define it as a predicate on `âˆ£ ğ‘¨ âˆ£`.  Thus, the collection of subuniverses is a predicate on predicates on `âˆ£ ğ‘¨ âˆ£`.

\begin{code}

Subuniverses : (ğ‘¨ : Algebra ğ“¤ ğ‘†) â†’ Pred (Pred âˆ£ ğ‘¨ âˆ£ ğ“¦)(ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âŠ” ğ“¦)
Subuniverses ğ‘¨ B = (ğ‘“ : âˆ£ ğ‘† âˆ£)(ğ‘ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£) â†’ Im ğ‘ âŠ† B â†’ (ğ‘“ Ì‚ ğ‘¨) ğ‘ âˆˆ B

\end{code}



#### <a id="subuniverses-as-records">Subuniverses as records</a>

Next we define a type to represent a single subuniverse of an algebra. If `ğ‘¨` is the algebra in question, then a subuniverse of `ğ‘¨` is a subset of (i.e., predicate over) the domain `âˆ£ ğ‘¨ âˆ£` that belongs to `Subuniverses ğ‘¨`.

\begin{code}

record Subuniverse {ğ‘¨ : Algebra ğ“¤ ğ‘†} : Type(ov (ğ“¤ âŠ” ğ“¦)) where
 constructor mksub
 field       sset : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦
             isSub : sset âˆˆ Subuniverses ğ‘¨

\end{code}


#### <a id="subuniverse-generation">Subuniverse Generation</a>

If `ğ‘¨` is an algebra and `X âŠ† âˆ£ ğ‘¨ âˆ£` a subset of the domain of `ğ‘¨`, then the **subuniverse of** `ğ‘¨` **generated by** `X` is typically denoted by `Sg`<sup>`ğ‘¨`</sup>`(X)` and defined to be the smallest subuniverse of `ğ‘¨` containing `X`.  Equivalently,

`Sg`<sup>`ğ‘¨`</sup>`(X)`  =  `â‹‚` { `U` : `U` is a subuniverse of `ğ‘¨` and  `B âŠ† U` }.

We define an inductive type, denoted by `Sg`, that represents the subuniverse generated by a given subset of the domain of a given algebra, as follows.

\begin{code}

data Sg (ğ‘¨ : Algebra ğ“¤ ğ‘†)(X : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦) : Pred âˆ£ ğ‘¨ âˆ£ (ğ“ âŠ” ğ“¥ âŠ” ğ“¦ âŠ” ğ“¤) where
 var : âˆ€ {v} â†’ v âˆˆ X â†’ v âˆˆ Sg ğ‘¨ X
 app : (ğ‘“ : âˆ£ ğ‘† âˆ£)(ğ‘ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£) â†’ Im ğ‘ âŠ† Sg ğ‘¨ X â†’ (ğ‘“ Ì‚ ğ‘¨) ğ‘ âˆˆ Sg ğ‘¨ X

\end{code}

Given an arbitrary subset `X` of the domain `âˆ£ ğ‘¨ âˆ£` of an `ğ‘†`-algebra `ğ‘¨`, the type `Sg X` does indeed represent a subuniverse of `ğ‘¨`. Proving this using the inductive type `Sg` is trivial, as we see here.

\begin{code}

sgIsSub : {ğ‘¨ : Algebra ğ“¤ ğ‘†}{X : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦} â†’ Sg ğ‘¨ X âˆˆ Subuniverses ğ‘¨
sgIsSub = app

\end{code}

Next we prove by structural induction that `Sg X` is the smallest subuniverse of `ğ‘¨` containing `X`.

\begin{code}

sgIsSmallest : {ğ“¡ : Level}(ğ‘¨ : Algebra ğ“¤ ğ‘†){X : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦}(Y : Pred âˆ£ ğ‘¨ âˆ£ ğ“¡)
 â†’             Y âˆˆ Subuniverses ğ‘¨  â†’  X âŠ† Y  â†’  Sg ğ‘¨ X âŠ† Y

sgIsSmallest _ _ _ XinY (var Xv) = XinY Xv
sgIsSmallest ğ‘¨ Y YsubA XinY (app ğ‘“ ğ‘ SgXa) = Yfa
 where
 IH : Im ğ‘ âŠ† Y
 IH i = sgIsSmallest ğ‘¨ Y YsubA XinY (SgXa i)

 Yfa : (ğ‘“ Ì‚ ğ‘¨) ğ‘ âˆˆ Y
 Yfa = YsubA ğ‘“ ğ‘ IH

\end{code}

When the element of `Sg X` is constructed as `app ğ‘“ ğ‘ SgXa`, we may assume (the induction hypothesis) that the arguments in the tuple `ğ‘` belong to `Y`. Then the result of applying `ğ‘“` to `ğ‘` also belongs to `Y` since `Y` is a subuniverse.



#### <a id="subuniverse-lemmas">Subuniverse Lemmas</a>

Here we formalize a few basic properties of subuniverses. First, the intersection of subuniverses is again a subuniverse.

\begin{code}

sub-intersection : {ğ“˜ : Level}{ğ‘¨ : Algebra ğ“¤ ğ‘†}{I : Type ğ“˜}{ğ’œ : I â†’ Pred âˆ£ ğ‘¨ âˆ£ ğ“¦}
 â†’                 Î [ i ê‰ I ] ğ’œ i âˆˆ Subuniverses ğ‘¨
                   ----------------------------------
 â†’                 â‹‚ I ğ’œ âˆˆ Subuniverses ğ‘¨

sub-intersection Î± ğ‘“ ğ‘ Î² = Î» i â†’ Î± i ğ‘“ ğ‘ (Î» x â†’ Î² x i)

\end{code}

In the proof above, we assume the following typing judgments:

```
 Î± : âˆ€ i â†’ ğ’œ i âˆˆ Subuniverses ğ‘¨
 ğ‘“ : âˆ£ ğ‘† âˆ£
 ğ‘ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£
 Î² : Im ğ‘ âŠ† â‹‚ I ğ’œ
```
and we must prove `(ğ‘“ Ì‚ ğ‘¨) ğ‘ âˆˆ â‹‚ I ğ’œ`. In this case, Agda will fill in the proof term `Î» i â†’ Î± i ğ‘“ ğ‘ (Î» x â†’ Î² x i)` automatically with the command `C-c C-a`.

Next, subuniverses are closed under the action of term operations.

\begin{code}

sub-term-closed : {ğ“§ : Level}{X : Type ğ“§}(ğ‘¨ : Algebra ğ“¤ ğ‘†){B : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦}
 â†’                (B âˆˆ Subuniverses ğ‘¨) â†’ (t : Term X)(b : X â†’ âˆ£ ğ‘¨ âˆ£)
 â†’                Î [ x ê‰ X ] (b x âˆˆ B)  â†’  (ğ‘¨ âŸ¦ t âŸ§)b âˆˆ B

sub-term-closed ğ‘¨ AB (â„Š x) b Bb = Bb x
sub-term-closed ğ‘¨{B}Î±(node ğ‘“ ğ‘¡)b Î² = Î± ğ‘“(Î» z â†’ (ğ‘¨ âŸ¦ ğ‘¡ z âŸ§)b) Î» x â†’ sub-term-closed ğ‘¨{B}Î±(ğ‘¡ x)b Î²

\end{code}

In the induction step of the foregoing proof, the typing judgments of the premise are the following:

```
ğ‘¨   : Algebra ğ“¤ ğ‘†
B   : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦
Î±   : B âˆˆ Subuniverses ğ‘¨
ğ‘“   : âˆ£ ğ‘† âˆ£
ğ‘¡   : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ Term X
b   : X â†’ âˆ£ ğ‘¨ âˆ£
Î²   : âˆ€ x â†’ b x âˆˆ B
```
and the given proof term establishes the goal `ğ‘¨ âŸ¦ node ğ‘“ ğ‘¡ âŸ§ b âˆˆ B`.

Alternatively, we could express the preceeding fact using an inductive type representing images of terms.

\begin{code}

data TermImage (ğ‘¨ : Algebra ğ“¤ ğ‘†)(Y : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦) : Pred âˆ£ ğ‘¨ âˆ£ (ğ“ âŠ” ğ“¥ âŠ” ğ“¤ âŠ” ğ“¦)
 where
 var : âˆ€ {y : âˆ£ ğ‘¨ âˆ£} â†’ y âˆˆ Y â†’ y âˆˆ TermImage ğ‘¨ Y
 app : âˆ€ ğ‘“ ğ‘¡ â†’  Î [ x ê‰ âˆ¥ ğ‘† âˆ¥ ğ‘“ ] ğ‘¡ x âˆˆ TermImage ğ‘¨ Y  â†’ (ğ‘“ Ì‚ ğ‘¨) ğ‘¡ âˆˆ TermImage ğ‘¨ Y

\end{code}

By what we proved above, it should come as no surprise that `TermImage ğ‘¨ Y` is a subuniverse of ğ‘¨ that contains Y.

\begin{code}

TermImageIsSub : {ğ‘¨ : Algebra ğ“¤ ğ‘†}{Y : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦} â†’ TermImage ğ‘¨ Y âˆˆ Subuniverses ğ‘¨
TermImageIsSub = app

Y-onlyif-TermImageY : {ğ‘¨ : Algebra ğ“¤ ğ‘†}{Y : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦} â†’ Y âŠ† TermImage ğ‘¨ Y
Y-onlyif-TermImageY {a} Ya = var Ya

\end{code}

Since `Sg ğ‘¨ Y` is the smallest subuniverse containing Y, we obtain the following inclusion.

\begin{code}

SgY-onlyif-TermImageY : (ğ‘¨ : Algebra ğ“¤ ğ‘†)(Y : Pred âˆ£ ğ‘¨ âˆ£ ğ“¦) â†’ Sg ğ‘¨ Y âŠ† TermImage ğ‘¨ Y
SgY-onlyif-TermImageY ğ‘¨ Y = sgIsSmallest ğ‘¨ (TermImage ğ‘¨ Y) TermImageIsSub Y-onlyif-TermImageY

\end{code}



Next we prove the important fact that homomorphisms are uniquely determined by their values on a generating set.

\begin{code}

hom-unique : funext ğ“¥ ğ“¦ â†’ {ğ‘¨ : Algebra ğ“¤ ğ‘†}{ğ‘© : Algebra ğ“¦ ğ‘†}
             (X : Pred âˆ£ ğ‘¨ âˆ£ ğ“¤)  (g h : hom ğ‘¨ ğ‘©)
 â†’           Î [ x ê‰ âˆ£ ğ‘¨ âˆ£ ] (x âˆˆ X â†’ âˆ£ g âˆ£ x â‰¡ âˆ£ h âˆ£ x)
             -------------------------------------------------
 â†’           Î [ a ê‰ âˆ£ ğ‘¨ âˆ£ ] (a âˆˆ Sg ğ‘¨ X â†’ âˆ£ g âˆ£ a â‰¡ âˆ£ h âˆ£ a)

hom-unique _ _ _ _ Î± a (var x) = Î± a x

hom-unique fe {ğ‘¨}{ğ‘©} X g h Î± fa (app ğ‘“ ğ’‚ Î²) = âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) ğ’‚)   â‰¡âŸ¨ âˆ¥ g âˆ¥ ğ‘“ ğ’‚ âŸ©
                                              (ğ‘“ Ì‚ ğ‘©)(âˆ£ g âˆ£ âˆ˜ ğ’‚ ) â‰¡âŸ¨ cong (ğ‘“ Ì‚ ğ‘©)(fe IH) âŸ©
                                              (ğ‘“ Ì‚ ğ‘©)(âˆ£ h âˆ£ âˆ˜ ğ’‚)  â‰¡âŸ¨ ( âˆ¥ h âˆ¥ ğ‘“ ğ’‚ )â»Â¹ âŸ©
                                              âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) ğ’‚ )  âˆ
 where IH = Î» x â†’ hom-unique fe {ğ‘¨}{ğ‘©} X g h Î± (ğ’‚ x) (Î² x)

\end{code}

In the induction step, we have the following typing judgments in the premise:

```
fe  : funext ğ“¥ ğ“¦
ğ‘¨   : Algebra ğ“¤ ğ‘†
ğ‘©   : Algebra ğ“¦ ğ‘†
X   : Pred âˆ£ ğ‘¨ âˆ£ ğ“¤
g h  : hom ğ‘¨ ğ‘©
Î±   : Î  x ê‰ âˆ£ ğ‘¨ âˆ£ , (x âˆˆ X â†’ âˆ£ g âˆ£ x â‰¡ âˆ£ h âˆ£ x)
fa  : âˆ£ ğ‘¨ âˆ£
fa  = (ğ‘“ Ì‚ ğ‘¨) ğ’‚
ğ‘“   : âˆ£ ğ‘† âˆ£
ğ’‚   : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘¨ âˆ£
Î²   : Im ğ’‚ âŠ† Sg ğ‘¨ X
```

and, under these assumptions, we proved `âˆ£ g âˆ£ ((ğ‘“ Ì‚ ğ‘¨) ğ’‚) â‰¡ âˆ£ h âˆ£ ((ğ‘“ Ì‚ ğ‘¨) ğ’‚)`.

---------------------------------

[â†‘ Subalgebras](Subalgebras.html)
<span style="float:right;">[Subalgebras.Subalgebras â†’](Subalgebras.Subalgebras.html)</span>


{% include UALib.Links.md %}

