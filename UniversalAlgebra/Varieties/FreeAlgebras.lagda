---
layout: default
title : Varieties.FreeAlgebras module (Agda Universal Algebra Library)
date : 2021-03-01
author: William DeMeo
---

## <a id="free-algebras-and-birkhoffs-theorem">Free Algebras and Birkhoff's Theorem</a>

This section presents the [Varieties.FreeAlgebras][] module of the [Agda Universal Algebra Library][].

First we will define the relatively free algebra in a variety, which is the "freest" algebra among (universal for) those algebras that model all identities holding in the variety. Then we give a formal proof of Birkhoff's theorem which says that a variety is an equational class. In other terms, a class `ğ’¦` of algebras is closed under the operators `H`, `S`, and `P` if and only if ğ’¦ is the class of algebras that satisfy some set of identities.

#### <a id="the-free-algebra-in-theory">The free algebra in theory</a>

Recall, we proved in [the universal property](Terms.Basic.html#the-universal-property) section of the [Terms.Basic][] module that the term algebra `ğ‘» X` is the absolutely free algebra in the class of all `ğ‘†`-structures. In this section, we formalize, for a given class `ğ’¦` of `ğ‘†`-algebras, the (relatively) free algebra in `S(P ğ’¦)` over `X`.

We use the next definition to take a free algebra *for* a class `ğ’¦` and produce the free algebra *in* `ğ’¦`.

`Î˜(ğ’¦, ğ‘¨) := {Î¸ âˆˆ Con ğ‘¨ : ğ‘¨ / Î¸ âˆˆ (S ğ’¦)}` &nbsp; &nbsp; and &nbsp; &nbsp; `Ïˆ(ğ’¦, ğ‘¨) := â‹‚ Î˜(ğ’¦, ğ‘¨)`.

Notice that `Î˜(ğ’¦, ğ‘¨)` may be empty, in which case `Ïˆ(ğ’¦, ğ‘¨) = 1` and then `ğ‘¨ / Ïˆ(ğ’¦, ğ‘¨)` is trivial.

The free algebra is constructed by applying the above definitions to the special case in which `ğ‘¨` is the term algebra `ğ‘» X` of `ğ‘†`-terms over `X`.

Since `ğ‘» X` is free for (and in) the class of all `ğ‘†`-algebras, it follows that `ğ‘» X` is free for every class `ğ’¦` of `ğ‘†`-algebras. Of course, `ğ‘» X` is not necessarily a member of `ğ’¦`, but if we form the quotient of `ğ‘» X` modulo the congruence `Ïˆ(ğ’¦, ğ‘» X)`, which we denote by `ğ”‰ := (ğ‘» X) / Ïˆ(ğ’¦, ğ‘» X)`, then it's not hard to see that `ğ”‰` is a subdirect product of the algebras in `{(ğ‘» ğ‘‹) / Î¸}`, where `Î¸` ranges over `Î˜(ğ’¦, ğ‘» X)`, so `ğ”‰` belongs to `S(P ğ’¦)`, and it follows that `ğ”‰` satisfies all the identities satisfied by all members of `ğ’¦`.  Indeed, for each pair `p q : ğ‘» X`, if `ğ’¦ âŠ§ p â‰ˆ q`, then `p` and `q` must belong to the same `Ïˆ(ğ’¦, ğ‘» X)`-class, so `p` and `q` are identified in the quotient `ğ”‰`.

The `ğ”‰` that we have just defined is called the **free algebra over** `ğ’¦` **generated by** `X` and (because of what we just observed) we may say that `ğ”‰` is free *in* `S(P ğ’¦)`.<sup>[1](Varieties.FreeAlgebras.html#fn1)</sup>

\begin{code}

{-# OPTIONS --without-K --exact-split --safe #-}

-- Imports from Agda (builtin/primitive) and the Agda Standard Library
open import Agda.Builtin.Equality using (_â‰¡_; refl)
open import Axiom.Extensionality.Propositional renaming (Extensionality to funext)
open import Data.Product using (_,_; Î£; _Ã—_)
open import Data.Sum.Base using (_âŠ_)
open import Function.Base  using (_âˆ˜_)
open import Level renaming (suc to lsuc; zero to lzero)
open import Relation.Binary using (Rel; IsEquivalence)
open import Relation.Binary.PropositionalEquality.Core using (cong; cong-app)
open import Relation.Unary using (Pred; _âˆˆ_; _âŠ†_)

-- Imports from the Agda Universal Algebra Library
open import Algebras.Basic
open import Overture.Preliminaries
 using (Type; ğ“; ğ“¤; ğ“¥; ğ“¦; ğ“§; Î ; -Î ; -Î£; _â‰¡âŸ¨_âŸ©_; _âˆ; _âˆ™_;_â»Â¹; âˆ£_âˆ£; âˆ¥_âˆ¥; snd; fst; _â‰ˆ_; id)
open import Overture.Inverses using (Inv; InvIsInv; IsSurjective; Image_âˆ‹_; SurjInv; SurjInvIsRightInvâ‰ˆ; IsInjective; InjInv)
open import Relations.Quotients using (âŸª_âŸ«)
open import Relations.Extensionality using (DFunExt; SwellDef; pred-ext; swelldef)
open import Relations.Discrete using (kernel; ker)
open import Relations.Truncation using (is-set; blk-uip; hfunext)


module Varieties.FreeAlgebras {ğ‘† : Signature ğ“ ğ“¥}{ğ“¤ : Level} where


open import Algebras.Congruences{ğ‘† = ğ‘†} using (Con; IsCongruence; mkcon)
open import Algebras.Products{ğ‘† = ğ‘†} as PRODUCTS using (ov; â¨…)
open import Subalgebras.Subalgebras{ğ‘† = ğ‘†} using (_â‰¤_; FirstHomCorollary|Set)
open import Homomorphisms.Basic{ğ‘† = ğ‘†} using (hom; âˆ˜-hom; â¨…-hom-co; ker[_â‡’_]_â†¾_; epi; Ï€ker; epi-to-hom; ker-in-con; kercon)
open import Homomorphisms.Noether using (HomFactorâ‰ˆ; HomFactorEpiâ‰ˆ)
open import Homomorphisms.Isomorphisms {ğ‘† = ğ‘†} using (_â‰…_; â‰…-refl; â‰…-sym; Lift-â‰…)
open import Homomorphisms.HomomorphicImages {ğ‘† = ğ‘†} using (epi-to-IsHomImage; IsHomImage)
open import Terms.Basic {ğ‘† = ğ‘†} using (Term; ğ‘»; lift-hom; free-lift; free-unique; lift-of-epi-is-epi)
open import Terms.Operations {ğ‘† = ğ‘†} using (_âŸ¦_âŸ§; comm-hom-term; free-lift-interp)
open import Varieties.EquationalLogic{ğ‘† = ğ‘†} using (_âŠ§_â‰‹_; _âŠ§_â‰ˆ_; Th; Mod)
open import Varieties.Preservation {ğ‘† = ğ‘†}
open import Varieties.Varieties {ğ‘† = ğ‘†}

open Term


-- NOTATION FOR COMMON UNIVERSE LEVELS --
-- ğ“• ğ“•âº : Level
-- ğ“• = ov ğ“¤
-- ğ“•âº = lsuc (ov ğ“¤)    -- (this will be the level of the relatively free algebra)


\end{code}





We begin by constructing `â„­`, using the techniques described in the section on <a href="https://ualib.gitlab.io/Varieties.Varieties.html#products-of-classes">products of classes</a>.

\begin{code}

module _ (fe : DFunExt)(wd : SwellDef)  -- extensionality assumptions (can we remove fe?)
         {ğ’¦ : Pred (Algebra ğ“¤ ğ‘†) (ğ“ âŠ” ğ“¥ âŠ” lsuc ğ“¤)}
         where

 open PRODUCTS.class-product{ğ’¦ = S{ğ“¤}{ğ“¤} ğ’¦}
 open Vlift ğ’¦

  -- â„­ is the product of all subalgebras of algebras in ğ’¦.
 â„­ : Algebra ğ“• ğ‘†
 â„­ = â¨… ğ”„ -- {ğ“¤ = ğ“¤}{ğ’¦ = ğ’¦})

 X : Type (ov ğ“¤)  -- variable symbols
 X = âˆ£ â„­ âˆ£

 proj : (i : â„‘) â†’ X â†’ fst âˆ£ i âˆ£
 proj i x = x i

 project : (X â†’ âˆ£ â„­ âˆ£) â†’ ((ğ‘¨ , _) : â„‘) â†’ X â†’ âˆ£ ğ‘¨ âˆ£
 project h i x = h x i

 proj-id : ((ğ‘¨ , _) : â„‘) â†’ X â†’ âˆ£ ğ‘¨ âˆ£
 proj-id = project id

 ğ•‹ : Algebra ğ“•âº ğ‘†
 ğ•‹ = ğ‘» X
 open class-product-inclusion ğ’¦


\end{code}

Observe that the inhabitants of `â„­` are maps from `â„‘` to `{ğ”„ i : i âˆˆ â„‘}`.  A homomorphism from `ğ‘» X` to `â„­` is obtained as follows.

\begin{code}

 -- homâ„­ : (X â†’ âˆ£ â„­ âˆ£) â†’ hom ğ•‹ â„­
 -- homâ„­ h = â¨…-hom-co ğ”„ (fe (ov ğ“¤) ğ“¤){ğ“•âº} ğ•‹ Î» i â†’ lift-hom (ğ”„ i) (Î» x â†’ (h x) i)
 homâ„­ : hom ğ•‹ â„­
 homâ„­ = â¨…-hom-co ğ”„ (fe (ov ğ“¤) ğ“¤){ğ“•âº} ğ•‹ Î» i â†’ lift-hom (ğ”„ i) (Î» x â†’ x i)
 -- â¨…-hom-co : funext ğ“˜ ğ“¦ â†’ {ğ“¤ : Level}(ğ‘¨ : Algebra ğ“¤ ğ‘†) â†’ (âˆ€(i : I) â†’ hom ğ‘¨ (â„¬ i)) â†’ hom ğ‘¨ (â¨… â„¬)
 -- â¨…-hom-co fe ğ‘¨ ğ’½ = ((Î» a i â†’ âˆ£ ğ’½ i âˆ£ a)) , (Î» ğ‘“ ğ’¶ â†’ fe Î» i â†’ âˆ¥ ğ’½ i âˆ¥ ğ‘“ ğ’¶)
 -- free-lift : (ğ‘¨ : Algebra ğ“¤ ğ‘†)(h : X â†’ âˆ£ ğ‘¨ âˆ£) â†’ âˆ£ ğ‘» X âˆ£ â†’ âˆ£ ğ‘¨ âˆ£
 -- free-lift _ h (â„Š x) = h x
 -- free-lift ğ‘¨ h (node f ğ‘¡) = (f Ì‚ ğ‘¨) (Î» i â†’ free-lift ğ‘¨ h (ğ‘¡ i))

 homâ„­-id : (x : X) â†’ âˆ£ homâ„­ âˆ£ (â„Š x) â‰¡ x
 homâ„­-id x = refl

 -- homâ„­map : (X â†’ âˆ£ â„­ âˆ£) â†’ âˆ£ ğ•‹ âˆ£ â†’ X
 -- homâ„­map h = free-lift â„­ h
 homâ„­map : âˆ£ ğ•‹ âˆ£ â†’ X
 homâ„­map (â„Š x) = x
 homâ„­map (node f t) = (f Ì‚ â„­) (homâ„­map âˆ˜ t)

 homâ„­mapterm : âˆ£ ğ•‹ âˆ£ â†’ âˆ£ ğ•‹ âˆ£
 homâ„­mapterm (â„Š x) = â„Š x
 homâ„­mapterm (node f t) = â„Š ((f Ì‚ â„­) (homâ„­map âˆ˜ t))


 -- homâ„­ : hom ğ•‹ â„­
 -- homâ„­ = â¨…-hom-co ğ”„ (fe ğ“• ğ“¤){ğ“•âº} ğ•‹ Î» i â†’ lift-hom (ğ”„ i) (proj i)

\end{code}

#### The universal property of the identity environment

Fix an algebra `ğ‘¨ âˆˆ S ğ’¦`, let `ğ”¥â‚€ : X â†’ âˆ£ ğ‘¨ âˆ£` be defined by `ğ”¥â‚€ = proj (ğ‘¨ , skA) = Î» x â†’ x (ğ‘¨ , skA)`, and let `h : X â†’ âˆ£ ğ‘¨ âˆ£` be any map. We want to show that:

(free-lift ğ‘¨ ğ”¥â‚€) p â‰¡ (free-lift ğ‘¨ ğ”¥â‚€) q  implies  (free-lift ğ‘¨ h) p  â‰¡ (free-lift ğ‘¨ h) q

We need to prove that projection `ğ”¥ : X â†’ âˆ£ ğ‘¨ âˆ£` of `X` onto component `ğ‘¨` is "below" every map `h : X â†’ âˆ£ ğ‘¨ âˆ£` in the sense that `kernel ğ”¥ âŠ† kernel h`.
  {- if h p â‰¢ h q  then  ğ”¥â‚€ p â‰¢ ğ”¥â‚€ q -}
Every `h : X â†’ âˆ£ ğ‘¨ âˆ£` can be decomposed as `h = g âˆ˜ ğ”¥`, where `g : âˆ£ ğ‘¨ âˆ£ â†’ âˆ£ ğ‘¨ âˆ£`.  Specifically, since `ğ”¥` is surjective, it has a right inverse ğ”¥â»Â¹, so `h âˆ˜ ğ”¥â»Â¹ = g`.  Therefore, `h = (h âˆ˜ ğ”¥â»Â¹) âˆ˜ ğ”¥`.

\begin{code}

 endolemma : {ğ“§ : Level}(X : Type ğ“§)(f : âˆ£ ğ‘† âˆ£)(t : âˆ¥ ğ‘† âˆ¥ f â†’ âˆ£ ğ‘» X âˆ£) â†’ (free-lift (ğ‘» X) (Î» x â†’ â„Š x)) ((f Ì‚ (ğ‘» X)) t) â‰¡ ((f Ì‚ (ğ‘» X)) ((free-lift (ğ‘» X) (Î» x â†’ â„Š x)) âˆ˜ t))
 endolemma X f t = refl

 module _ {ğ‘¨ : Algebra ğ“¤ ğ‘†}{skA : ğ‘¨ âˆˆ S{ğ“¤}{ğ“¤} ğ’¦} where

  hlem : (h : X â†’ âˆ£ ğ‘¨ âˆ£)(x : X) â†’ h x â‰¡ h (âˆ£ homâ„­ âˆ£ (â„Š x))
  hlem h x = h x â‰¡âŸ¨ cong h (homâ„­-id x)â»Â¹ âŸ© h (âˆ£ homâ„­ âˆ£ (â„Š x)) âˆ

  homâ„­lem : âˆ€ f t â†’ âˆ£ homâ„­ âˆ£ ((f Ì‚ ğ•‹) t) â‰¡ (f Ì‚ â„­) (âˆ£ homâ„­ âˆ£ âˆ˜ t)
  homâ„­lem f t = refl

  hlem' : (h : X â†’ âˆ£ ğ‘¨ âˆ£)(p : âˆ£ ğ•‹ âˆ£) â†’ (free-lift ğ‘¨ h) p â‰¡ h  (âˆ£ homâ„­ âˆ£ p)
  hlem' h p  = Î¾ p
   where
   Î³ : âˆ€ f ğ’™ â†’ (f Ì‚ ğ•‹) (â„Š âˆ˜ ğ’™) â‰¡ â„Š ((f Ì‚ â„­) ğ’™)
   Î³ f ğ’™ = (f Ì‚ ğ•‹) (Î» j â†’ â„Š (ğ’™ j)) â‰¡âŸ¨ {!!} âŸ©
           â„Š (Î» i â†’ (f Ì‚ ğ”„ i) Î» j â†’ ğ’™ j i) â‰¡âŸ¨ refl âŸ©
           â„Š ((f Ì‚ â„­) ğ’™) âˆ

   Î¶ : âˆ€ f t â†’ (f Ì‚ ğ•‹) (Î» x â†’ â„Š (âˆ£ homâ„­ âˆ£ (t x))) â‰¡ â„Š ((f Ì‚ â„­) (Î» x â†’ âˆ£ homâ„­ âˆ£ (t x)))
   Î¶ f t = (f Ì‚ ğ•‹) (â„Š âˆ˜ (âˆ£ homâ„­ âˆ£ âˆ˜ t)) â‰¡âŸ¨ Î³ f (âˆ£ homâ„­ âˆ£ âˆ˜ t) âŸ©
           â„Š ((f Ì‚ â„­) (âˆ£ homâ„­ âˆ£ âˆ˜ t)) âˆ

   Î¾ : âˆ€ p â†’ (free-lift ğ‘¨ (h âˆ˜ (Î» x â†’ x))) p â‰¡ (h âˆ˜ âˆ£ homâ„­ âˆ£ ) p
   Î¾ (â„Š x) = refl
   Î¾ (node f t) = free-lift ğ‘¨ (h âˆ˜ (Î» x â†’ x)) (node f t) â‰¡âŸ¨ refl âŸ©
          (f Ì‚ ğ‘¨) ((free-lift ğ‘¨ (h âˆ˜ (Î» x â†’ x))) âˆ˜ t) â‰¡âŸ¨ wd ğ“¥ ğ“¤ (f Ì‚ ğ‘¨) ((free-lift ğ‘¨ (h âˆ˜ (Î» x â†’ x))) âˆ˜ t) ((h âˆ˜ âˆ£ homâ„­ âˆ£) âˆ˜ t) (Î» i â†’ Î¾ (t i)) âŸ©
          (f Ì‚ ğ‘¨) ((h âˆ˜ âˆ£ homâ„­ âˆ£) âˆ˜ t) â‰¡âŸ¨ refl âŸ©
          (f Ì‚ ğ‘¨) ((free-lift ğ‘¨ h) âˆ˜ (â„Š âˆ˜ (âˆ£ homâ„­ âˆ£ âˆ˜ t))) â‰¡âŸ¨ refl âŸ©
          (free-lift ğ‘¨ h) ((f Ì‚ ğ•‹) (â„Š âˆ˜ (âˆ£ homâ„­ âˆ£ âˆ˜ t))) â‰¡âŸ¨ cong (free-lift ğ‘¨ h){(f Ì‚ ğ•‹) (â„Š âˆ˜ (âˆ£ homâ„­ âˆ£ âˆ˜ t))}{â„Š ((f Ì‚ â„­) (âˆ£ homâ„­ âˆ£ âˆ˜ t))} (Î¶ f t) âŸ©
                  (free-lift ğ‘¨ h) (â„Š ((f Ì‚ â„­) (âˆ£ homâ„­ âˆ£ âˆ˜ t))) â‰¡âŸ¨ refl âŸ©
                  (h âˆ˜ âˆ£ homâ„­ âˆ£) ((f Ì‚ ğ•‹) t) â‰¡âŸ¨ refl âŸ©
                  (h âˆ˜ âˆ£ homâ„­ âˆ£) (node f t) âˆ


  hlem'' : (h : X â†’ âˆ£ ğ‘¨ âˆ£)(p q : âˆ£ ğ•‹ âˆ£)
   â†’       âˆ£ homâ„­ âˆ£ p â‰¡ âˆ£ homâ„­ âˆ£ q â†’ (free-lift ğ‘¨ h) p â‰¡ (free-lift ğ‘¨ h) q
  hlem'' h p q hker = (free-lift ğ‘¨ h) p â‰¡âŸ¨ hlem' h p âŸ©
                      h (âˆ£ homâ„­ âˆ£ p) â‰¡âŸ¨ cong h hker âŸ©
                      h (âˆ£ homâ„­ âˆ£ q) â‰¡âŸ¨ (hlem' h q)â»Â¹ âŸ©
                      (free-lift ğ‘¨ h) q âˆ
\end{code}



#### <a id="the-free-algebra">The free algebra</a>

 As mentioned above, the initial version of the [Agda UniversalAlgebra][] used the free algebra `ğ”‰` developed above.  However, our new, more direct proof uses the algebra `ğ”½`, which we now define, along with the natural epimorphism `epiğ”½ : epi (ğ‘» X) ğ”½` from `ğ‘» X` to `ğ”½`.

 We now define the algebra `ğ”½`, which plays the role of the free algebra, along with the natural epimorphism `epiğ”½ : epi (ğ‘» X) ğ”½` from `ğ‘» X` to `ğ”½`.

\begin{code}

 ğ”½ : Algebra ğ“•âº ğ‘†
 ğ”½ = ker[ ğ•‹ â‡’ â„­ ] homâ„­ â†¾ (wd ğ“¥ ğ“•)

 epiğ”½ : epi ğ•‹ ğ”½
 epiğ”½ = Ï€ker (wd ğ“¥ ğ“•) {â„­} homâ„­

 homğ”½ : hom ğ•‹ ğ”½
 homğ”½ = epi-to-hom ğ”½ epiğ”½

 homğ”½-is-epic : IsSurjective âˆ£ homğ”½ âˆ£
 homğ”½-is-epic = snd âˆ¥ epiğ”½ âˆ¥


\end{code}




#### <a id="the-free-algebra-in-agda">The free algebra in Agda</a>

Before we attempt to represent the free algebra in Agda we construct the congruence `Ïˆ(ğ’¦, ğ‘» ğ‘‹)` described above.
First, we represent the congruence relation `ÏˆCon`, modulo which `ğ‘» X` yields the relatively free algebra, `ğ”‰ ğ’¦ X := ğ‘» X â•± ÏˆCon`.  We let `Ïˆ` be the collection of identities `(p, q)` satisfied by all subalgebras of algebras in `ğ’¦`.

\begin{code}

 -- Ïˆ : Pred (âˆ£ ğ•‹ âˆ£ Ã— âˆ£ ğ•‹ âˆ£) ğ“•
 -- Ïˆ (p , q) = âˆ€(ğ‘¨ : Algebra ğ“¤ ğ‘†)(sA : ğ‘¨ âˆˆ S{ğ“¤}{ğ“¤} ğ’¦) â†’  ğ‘¨ âŸ¦ p âŸ§ â‰ˆ ğ‘¨ âŸ¦ q âŸ§
 Ïˆ : Pred (âˆ£ ğ‘» X âˆ£ Ã— âˆ£ ğ‘» X âˆ£) ğ“•
 Ïˆ (p , q) = âˆ€(ğ‘¨ : Algebra ğ“¤ ğ‘†)(sA : ğ‘¨ âˆˆ S{ğ“¤}{ğ“¤} ğ’¦)(h : X â†’ âˆ£ ğ‘¨ âˆ£ )
                 â†’  (free-lift ğ‘¨ h) p â‰¡ (free-lift ğ‘¨ h) q

\end{code}

We convert the predicate Ïˆ into a relation by [currying](https://en.wikipedia.org/wiki/Currying).

\begin{code}

 ÏˆRel : Rel âˆ£ ğ•‹ âˆ£ ğ“•
 ÏˆRel p q = Ïˆ (p , q)

\end{code}

To express `ÏˆRel` as a congruence of the term algebra `ğ‘» X`, we must prove that

1. `ÏˆRel` is compatible with the operations of `ğ‘» X` (which are jsut the terms themselves) and
2. `ÏˆRel` it is an equivalence relation.

\begin{code}

 Ïˆcompatible : compatible ğ•‹ ÏˆRel
 Ïˆcompatible ğ‘“ {p} {q} Ïˆpq ğ‘¨ sA h = Î³
  where
  Ï† : hom ğ•‹ ğ‘¨
  Ï† = lift-hom ğ‘¨ h

  Î³ : âˆ£ Ï† âˆ£ ((ğ‘“ Ì‚ ğ‘» X) p) â‰¡ âˆ£ Ï† âˆ£ ((ğ‘“ Ì‚ ğ‘» X) q)

  Î³ = âˆ£ Ï† âˆ£ ((ğ‘“ Ì‚ ğ‘» X) p)  â‰¡âŸ¨ âˆ¥ Ï† âˆ¥ ğ‘“ p âŸ©
      (ğ‘“ Ì‚ ğ‘¨) (âˆ£ Ï† âˆ£ âˆ˜ p)  â‰¡âŸ¨ wd ğ“¥ ğ“¤ (ğ‘“ Ì‚ ğ‘¨) (âˆ£ Ï† âˆ£ âˆ˜ p) (âˆ£ Ï† âˆ£ âˆ˜ q) (Î» x â†’ (Ïˆpq x) ğ‘¨ sA h) âŸ©
      (ğ‘“ Ì‚ ğ‘¨) (âˆ£ Ï† âˆ£ âˆ˜ q)  â‰¡âŸ¨ (âˆ¥ Ï† âˆ¥ ğ‘“ q)â»Â¹ âŸ©
      âˆ£ Ï† âˆ£ ((ğ‘“ Ì‚ ğ‘» X) q)  âˆ

 ÏˆIsEquivalence : IsEquivalence ÏˆRel
 ÏˆIsEquivalence = record { refl = Î» ğ‘¨ sA h â†’ refl
                         ; sym = Î» x ğ‘¨ sA h â†’ (x ğ‘¨ sA h)â»Â¹
                         ; trans = Î» pÏˆq qÏˆr ğ‘¨ sA h â†’ (pÏˆq ğ‘¨ sA h) âˆ™ (qÏˆr ğ‘¨ sA h) }
\end{code}

We have collected all the pieces necessary to express the collection of identities satisfied by all subalgebras of algebras in the class as a congruence relation of the term algebra. We call this congruence `ÏˆCon` and define it using the Congruence constructor `mkcon`.

\begin{code}

 ÏˆCon : Con ğ•‹
 ÏˆCon = ÏˆRel , mkcon ÏˆIsEquivalence Ïˆcompatible

\end{code}





#### <a id="hsp-theorem">HSP Theorem</a>

This section presents a formal proof of the Birkhoff HSP theorem.

To complete the proof of Birkhoff's HSP theorem, it remains to show that `Mod X (Th (V ğ’¦))` is contained in `V ğ’¦`; that is, every algebra that models the equations in `Th (V ğ’¦)` belongs to `V ğ’¦`.  This will prove that `V ğ’¦` is an equational class.  (The converse, that every equational class is a variety was already proved; see the remarks at the end of this module.)

We accomplish this goal by constructing an algebra `ğ”½` with the following properties:

1. `ğ”½ âˆˆ V ğ’¦` and

2. Every `ğ‘¨ âˆˆ Mod X (Th (V ğ’¦))` is a homomorphic image of `ğ”½`.

We denote by `â„­` the product of all subalgebras of algebras in `ğ’¦`, and by `homâ„­` the homomorphism from `ğ‘» X` to `â„­` defined as follows: `homâ„­ := â¨…-hom-co (ğ‘» X) ğ”„s homğ”„`.

Here, `â¨…-hom-co` (defined in [Homomorphisms.Basic](Homomorphisms.Basic.html#product-homomorphisms)) takes the term algebra `ğ‘» X`, a family `{ğ”„s : I â†’ Algebra ğ“¤ ğ‘†}` of `ğ‘†`-algebras, and a family `homğ”„ : âˆ€ i â†’ hom (ğ‘» X) (ğ”„s i)` of homomorphisms and constructs the natural homomorphism `homâ„­` from `ğ‘» X` to the product `â„­ := â¨… ğ”„`.  The homomorphism `homâ„­ : hom (ğ‘» X) (â¨… â„­)` is natural in the sense that the `i`-th component of the image of `ğ‘¡ : Term X` under `homâ„­` is the image `âˆ£ homğ”„ i âˆ£ ğ‘¡` of ğ‘¡ under the i-th homomorphism `homğ”„ i`.





#### <a id="F-in-classproduct">ğ”½ â‰¤  â¨… S(ğ’¦)</a>
Now we come to a step in the Agda formalization of Birkhoff's theorem that is highly nontrivial. We must prove that the free algebra embeds in the product â„­ of all subalgebras of algebras in the class `ğ’¦`.  This is really the only stage in the proof of Birkhoff's theorem that requires the truncation assumption that `â„­` be a *set* (that is, `â„­` has the [UIP][] property).  We will also need to assume several local function extensionality postulates and, as a result, the next submodule will take as given the parameter `fe : DFunExt`.  This allows us to postulate local function extensionality when and where we need it in the proof. For example, if we want to assume function extensionality at universe levels ğ“¥ and ğ“¤, we simply apply `fe` to those universes: `fe ğ“¥ ğ“¤`. (Earlier versions of the library used just a single *global* function extensionality postulate at the start of most modules, but we have since decided to exchange that elegant but crude option for greater precision and transparency.)

We will need the following facts relating `homâ„­`, `homğ”½`, `and Ïˆ`.

\begin{code}
 Ïˆlemma0 : âˆ€ p q â†’ âˆ£ homâ„­ âˆ£ p â‰¡ âˆ£ homâ„­ âˆ£ q â†’ (p , q) âˆˆ Ïˆ
 Ïˆlemma0 p q phomâ„­q ğ‘¨ sA h = Î³ -- cong-app phomâ„­q (ğ‘¨ , sA)
  where
  Î³ : (free-lift ğ‘¨ h) p â‰¡ (free-lift ğ‘¨ h) q
  Î³ = (free-lift ğ‘¨ h) p  â‰¡âŸ¨ hlem''{ğ‘¨ = ğ‘¨}{skA = sA} h p q phomâ„­q âŸ©
      (free-lift ğ‘¨ h) q âˆ

 Ïˆlemma0-ap : {ğ‘¨ : Algebra ğ“¤ ğ‘†}{h : X â†’ âˆ£ ğ‘¨ âˆ£}(skA : ğ‘¨ âˆˆ S{ğ“¤}{ğ“¤} ğ’¦)
  â†’           kernel âˆ£ homğ”½ âˆ£ âŠ† kernel (free-lift ğ‘¨ h)

 Ïˆlemma0-ap {ğ‘¨}{h} skA {p , q} x = Î³ where

  Î½ : âˆ£ homâ„­ âˆ£ p â‰¡ âˆ£ homâ„­ âˆ£ q
  Î½ = ker-in-con {ğ‘¨ = ğ•‹}{wd ğ“¥ ğ“•âº}(kercon (wd ğ“¥ ğ“•) {â„­} homâ„­) {p}{q} x

  Î³ : (free-lift ğ‘¨ h) p â‰¡ (free-lift ğ‘¨ h) q
  Î³ = ((Ïˆlemma0 p q) Î½) ğ‘¨ skA h


\end{code}

We now use `Ïˆlemma0-ap` to prove that every map `h : X â†’ âˆ£ ğ‘¨ âˆ£`, from `X` to a subalgebra `ğ‘¨ âˆˆ S ğ’¦` of `ğ’¦`, lifts to a homomorphism from `ğ”½` to `ğ‘¨`.

\begin{code}

 ğ”½-lift-hom : (ğ‘¨ : Algebra ğ“¤ ğ‘†) â†’ ğ‘¨ âˆˆ S{ğ“¤}{ğ“¤} ğ’¦ â†’ (h : X â†’ âˆ£ ğ‘¨ âˆ£) â†’ hom ğ”½ ğ‘¨
 ğ”½-lift-hom ğ‘¨ skA h = fst(HomFactorâ‰ˆ (wd ğ“¥ ğ“•âº) ğ‘¨ (lift-hom ğ‘¨ h) homğ”½ (Ïˆlemma0-ap skA) homğ”½-is-epic)

\end{code}


#### <a id="k-models-psi">ğ’¦ models Ïˆ</a>

The goal of this subsection is to prove that `ğ’¦` models `Ïˆ ğ’¦`. In other terms, for all pairs `(p , q) âˆˆ Term X Ã— Term X` of terms, if `(p , q) âˆˆ Ïˆ ğ’¦`, then `ğ’¦ âŠ§ p â‰‹ q`.

Next we define the lift of the natural embedding from `X` into ğ”½. We denote this homomorphism by `ğ”‘ : hom (ğ‘» X) ğ”½` and define it as follows.

\begin{code}

 open IsCongruence

 Xâ†ªğ”½ : X â†’ âˆ£ ğ”½ âˆ£
 Xâ†ªğ”½ x = âŸª â„Š x âŸ«

 ğ”‘ : hom ğ•‹ ğ”½
 ğ”‘ = lift-hom ğ”½ Xâ†ªğ”½

\end{code}

It turns out that the homomorphism so defined is equivalent to `homğ”½`.

\begin{code}

 homğ”½-is-lift-hom : âˆ€ p â†’ âˆ£ ğ”‘ âˆ£ p â‰¡ âˆ£ homğ”½ âˆ£ p
 homğ”½-is-lift-hom  (â„Š x) = refl
 homğ”½-is-lift-hom  (node ğ‘“ t) =
  âˆ£ ğ”‘ âˆ£ (node ğ‘“ t)                  â‰¡âŸ¨ âˆ¥ ğ”‘ âˆ¥ ğ‘“ t âŸ©
  (ğ‘“ Ì‚ ğ”½)(Î» i â†’ âˆ£ ğ”‘ âˆ£(t i))     â‰¡âŸ¨ wd ğ“¥ ğ“•âº (ğ‘“ Ì‚ ğ”½)(Î» i â†’ âˆ£ ğ”‘ âˆ£(t i))(Î» i â†’ âˆ£ homğ”½ âˆ£(t i)) Î¾ âŸ©
  (ğ‘“ Ì‚ ğ”½)(Î» i â†’ âˆ£ homğ”½ âˆ£ (t i)) â‰¡âŸ¨ (âˆ¥ homğ”½ âˆ¥ ğ‘“ t)â»Â¹ âŸ©
  âˆ£ homğ”½ âˆ£ (node ğ‘“ t)           âˆ
  where
  Î¾ : âˆ£ ğ”‘ âˆ£ âˆ˜ t â‰ˆ âˆ£ homğ”½ âˆ£ âˆ˜ t
  Î¾ = Î» i â†’ homğ”½-is-lift-hom (t i)

\end{code}

We need a three more lemmas before we are ready to tackle our main goal.

\begin{code}

 Ïˆlemma1 : kernel âˆ£ ğ”‘ âˆ£ âŠ† Ïˆ
 Ïˆlemma1 {p , q} ğ”‘pq ğ‘¨ sA h = Î³'
  where
  f : hom ğ”½ ğ‘¨
  f = ğ”½-lift-hom ğ‘¨ sA h

  h' Ï† : hom ğ•‹ ğ‘¨
  h' = âˆ˜-hom ğ•‹ ğ‘¨ ğ”‘ f
  Ï† = lift-hom ğ‘¨ h

  hâ‰¡Ï† : âˆ€ t â†’ (âˆ£ f âˆ£ âˆ˜ âˆ£ ğ”‘ âˆ£) t â‰¡ âˆ£ Ï† âˆ£ t
  hâ‰¡Ï† t = free-unique (fe ğ“¥ ğ“¤) ğ‘¨ h' Ï† (Î» x â†’ refl) t

  Î³' : âˆ£ Ï† âˆ£ p â‰¡ âˆ£ Ï† âˆ£ q
  Î³' = âˆ£ Ï† âˆ£ p             â‰¡âŸ¨ (hâ‰¡Ï† p)â»Â¹ âŸ©
       âˆ£ f âˆ£ ( âˆ£ ğ”‘ âˆ£ p )   â‰¡âŸ¨ cong âˆ£ f âˆ£ ğ”‘pq âŸ©
       âˆ£ f âˆ£ ( âˆ£ ğ”‘ âˆ£ q )   â‰¡âŸ¨ hâ‰¡Ï† q âŸ©
       âˆ£ Ï† âˆ£ q             âˆ


  Î³ : (ğ‘¨ âŸ¦ p âŸ§) h â‰¡ (ğ‘¨ âŸ¦ q âŸ§) h
  Î³ = (ğ‘¨ âŸ¦ p âŸ§) h â‰¡âŸ¨ free-lift-interp (wd ğ“¥ ğ“¤) ğ‘¨ h p âŸ©
      (free-lift ğ‘¨ h) p  â‰¡âŸ¨ Î³' âŸ©
      (free-lift ğ‘¨ h) q â‰¡âŸ¨ (free-lift-interp (wd ğ“¥ ğ“¤) ğ‘¨ h q)â»Â¹ âŸ©
      (ğ‘¨ âŸ¦ q âŸ§) h        âˆ

 Ïˆlemma2 : kernel âˆ£ homğ”½ âˆ£ âŠ† Ïˆ
 Ïˆlemma2 {p , q} hyp = Ïˆlemma1 {p , q} Î³
   where
    Î³ : (free-lift ğ”½ Xâ†ªğ”½) p â‰¡ (free-lift ğ”½ Xâ†ªğ”½) q
    Î³ = (homğ”½-is-lift-hom p) âˆ™ hyp âˆ™ (homğ”½-is-lift-hom q)â»Â¹


 Ïˆlemma3 : âˆ€ p q â†’ (p , q) âˆˆ Ïˆ â†’ ğ’¦ âŠ§ p â‰‹ q
 Ïˆlemma3 p q pÏˆq {ğ‘¨} kA h =  Î³
  where
  Î³ : (ğ‘¨ âŸ¦ p âŸ§) h â‰¡ (ğ‘¨ âŸ¦ q âŸ§) h
  Î³ = (ğ‘¨ âŸ¦ p âŸ§) h    â‰¡âŸ¨ free-lift-interp (wd ğ“¥ ğ“¤) ğ‘¨ h p âŸ©
      (free-lift ğ‘¨ h) p â‰¡âŸ¨ pÏˆq ğ‘¨ (siso (sbase kA) (â‰…-sym Lift-â‰…)) h âŸ©
      (free-lift ğ‘¨ h) q â‰¡âŸ¨ (free-lift-interp (wd ğ“¥ ğ“¤) ğ‘¨ h q)â»Â¹ âŸ©
      (ğ‘¨ âŸ¦ q âŸ§) h       âˆ




\end{code}

With these results in hand, it is now trivial to prove the main theorem of this subsection.

\begin{code}

 class-models-kernel :  âˆ€ p q â†’ (p , q) âˆˆ kernel âˆ£ homğ”½ âˆ£ â†’ ğ’¦ âŠ§ p â‰‹ q
 class-models-kernel p q hyp = Ïˆlemma3 p q (Ïˆlemma2 hyp)

 ğ•ğ’¦ : Pred (Algebra ğ“•âº ğ‘†) (lsuc ğ“•âº)
 ğ•ğ’¦ = V{ğ“¤}{ğ“•âº} ğ’¦

 kernel-in-theory : kernel âˆ£ homğ”½ âˆ£ âŠ† Th (V ğ’¦)
 kernel-in-theory {p , q} pKq {ğ‘¨} = Î¾
  where
  Kpq : ğ’¦ âŠ§ p â‰‹ q
  Kpq kAâ‚ hâ‚ = class-models-kernel p q pKq kAâ‚ hâ‚

  Î¾ : (p , q) âˆˆ Th ğ•ğ’¦
  Î¾ = class-ids fe wd p q Kpq

 Xâ†  : Algebra ğ“•âº ğ‘† â†’ Type ğ“•âº
 Xâ†  ğ‘¨ = Î£[ h ê‰ (X â†’ âˆ£ ğ‘¨ âˆ£) ] IsSurjective h

 ğ”½-ModTh-epi : (ğ‘¨ : Algebra ğ“•âº ğ‘†) â†’ (Xâ†  ğ‘¨) â†’ ğ‘¨ âˆˆ Mod{ğ“¤ = ğ“•âº}{X = X} (Th ğ•ğ’¦) â†’ epi ğ”½ ğ‘¨
 ğ”½-ModTh-epi ğ‘¨ (Î· , Î·E) AinMTV = Î³
  where
  Ï† : hom ğ•‹ ğ‘¨
  Ï† = lift-hom ğ‘¨ Î·

  Ï†E : IsSurjective âˆ£ Ï† âˆ£
  Ï†E = lift-of-epi-is-epi ğ‘¨ Î·E

  pqlem1 : âˆ€ p q â†’ (p , q) âˆˆ kernel âˆ£ homğ”½ âˆ£ â†’ (p , q) âˆˆ Th ğ•ğ’¦
  pqlem1 p q hyp = kernel-in-theory hyp
  pqlem2 : âˆ€ p q â†’ (p , q) âˆˆ Th ğ•ğ’¦ â†’ ğ‘¨ âŠ§ p â‰ˆ q
  pqlem2 p q hyp x = AinMTV p q hyp x

  kerincl : kernel âˆ£ homğ”½ âˆ£ âŠ† kernel âˆ£ Ï† âˆ£
  kerincl {p , q} x = âˆ£ Ï† âˆ£ p      â‰¡âŸ¨ (free-lift-interp (wd ğ“¥ ğ“•âº) ğ‘¨ Î· p)â»Â¹ âŸ©
                      (ğ‘¨ âŸ¦ p âŸ§) Î·  â‰¡âŸ¨ pqlem2 p q (pqlem1 p q x) Î· âŸ©
                      (ğ‘¨ âŸ¦ q âŸ§) Î·  â‰¡âŸ¨ free-lift-interp (wd ğ“¥ ğ“•âº) ğ‘¨ Î· q âŸ©
                      âˆ£ Ï† âˆ£ q      âˆ

  Î³ : epi ğ”½ ğ‘¨
  Î³ = fst (HomFactorEpiâ‰ˆ (wd ğ“¥ ğ“•âº) ğ‘¨ Ï† homğ”½ kerincl homğ”½-is-epic Ï†E)

\end{code}





#### <a id="the-homomorphic-images-of-F">The homomorphic images of ğ”½</a>

Finally we come to one of the main theorems of this module; it asserts that every algebra in `Mod X (Th ğ•ğ’¦)` is a homomorphic image of ğ”½.  We prove this below as the function (or proof object) `ğ”½-ModTh-epi`.  Before that, we prove two auxiliary lemmas.

\begin{code}

 module _ (pe : pred-ext ğ“•âº ğ“•)(wd : SwellDef)                      -- extensionality assumptions
          (Cset : is-set âˆ£ â„­ âˆ£)(kuip : blk-uip(Term X)âˆ£ kercon (wd ğ“¥ ğ“•){â„­} homâ„­ âˆ£) -- truncation assumptions
  where

  ğ”½â‰¤â„­ : (ker[ ğ‘» X â‡’ â„­ ] homâ„­ â†¾ (wd ğ“¥ ğ“•)) â‰¤ â„­
  ğ”½â‰¤â„­ = FirstHomCorollary|Set ğ•‹ â„­ homâ„­ pe (wd ğ“¥ ğ“•) Cset kuip

\end{code}

The last piece we need to prove that every model of `Th ğ•ğ’¦` is a homomorphic image of `ğ”½` is a crucial assumption that is taken for granted throughout informal universal algebra---namely, that our collection `X` of variable symbols is arbitrarily large and that we have an *environment* which interprets the variable symbols in every algebra under consideration. In other terms, an environment provides, for every algebra `ğ‘¨`, a surjective mapping `Î· : X â†’ âˆ£ ğ‘¨ âˆ£` from `X` onto the domain of `ğ‘¨`.

We do *not* assert that for an arbitrary type `X` such surjective maps exist.  Indeed, our `X` must is quite special to have this property.  Later, we will construct such an `X`, but for now we simply postulate its existence. Note that this assumption that an environment exists is only required in the proof of the theorem `ğ”½-ModTh-epi`.

\begin{code}


\end{code}

#### <a id="F-in-VK">ğ”½ âˆˆ V(ğ’¦)</a>

With this result in hand, along with what we proved earlier---namely, `PS(ğ’¦) âŠ† SP(ğ’¦) âŠ† HSP(ğ’¦) â‰¡ V ğ’¦`---it is not hard to show that `ğ”½` belongs to `V ğ’¦`.

\begin{code}

--   open Vlift ğ’¦

  ğ”½âˆˆSP : DFunExt â†’ ğ”½ âˆˆ (S{ğ“•}{ğ“•âº} (P{ğ“¤}{ğ“•} ğ’¦))
  ğ”½âˆˆSP fe = ssub (class-prod-s-âˆˆ-sp fe) ğ”½â‰¤â„­

  ğ”½âˆˆğ• : DFunExt â†’ ğ”½ âˆˆ V ğ’¦
  ğ”½âˆˆğ• fe = SPâŠ†V' fe (ğ”½âˆˆSP fe)

\end{code}

#### <a id="the-hsp-theorem"> The HSP Theorem</a>

Now that we have all of the necessary ingredients, it is all but trivial to combine them to prove Birkhoff's HSP theorem. (Note that since the proof enlists the help of the `ğ”½-ModTh-epi` theorem, we must assume an environment exists, which is manifested in the premise `âˆ€ ğ‘¨ â†’ X â†  ğ‘¨`.

\begin{code}

  Birkhoff : DFunExt â†’ (âˆ€ ğ‘¨ â†’ Xâ†  ğ‘¨) â†’ Mod (Th (V ğ’¦)) âŠ†  V ğ’¦

  Birkhoff fe ğ• {ğ‘¨} Î± = Î³
   where
    Î¶ : IsHomImage ğ‘¨
    Î¶ = epi-to-IsHomImage ğ‘¨ (ğ”½-ModTh-epi ğ‘¨ (ğ• ğ‘¨) Î±)

    Î³ : ğ‘¨ âˆˆ V ğ’¦
    Î³ = vhimg{ğ‘© = ğ‘¨} (ğ”½âˆˆğ• fe) (ğ‘¨ , Î¶)

\end{code}

data V {ğ“¤ ğ“¦ : Level}(ğ’¦ : Pred(Algebra ğ“¤ ğ‘†)(ov ğ“¤)) : Pred(Algebra(ğ“¤ âŠ” ğ“¦)ğ‘†)(ov(ğ“¤ âŠ” ğ“¦))

The converse inclusion, `V ğ’¦ âŠ† Mod X (Th (V ğ’¦))`, is a simple consequence of the fact that `Mod Th` is a closure operator. Nonetheless, completeness demands that we formalize this inclusion as well, however trivial the proof.

\begin{code}

  Birkhoff-converse : V{ğ“¤}{ğ“•} ğ’¦ âŠ† Mod{ğ“§ = (ov ğ“¤)}{X = X} (Th (V ğ’¦))
  Birkhoff-converse Î± p q pThq = pThq Î±

\end{code}

We have thus proved that every variety is an equational class.  Readers familiar with the classical formulation of the Birkhoff HSP theorem, as an "if and only if" result, might worry that we haven't completed the proof.  But recall that in the [Varieties.Preservation][] module we proved the following identity preservation lemmas:

* `ğ’¦ âŠ§ p â‰‹ q â†’ H ğ’¦ âŠ§ p â‰‹ q`
* `ğ’¦ âŠ§ p â‰‹ q â†’ S ğ’¦ âŠ§ p â‰‹ q`
* `ğ’¦ âŠ§ p â‰‹ q â†’ P ğ’¦ âŠ§ p â‰‹ q`

From these it follows that every equational class is a variety. Thus, our formal proof of Birkhoff's theorem is complete.

----------------------------


<sup>1</sup><span class="footnote" id="fn1"> Since `X` is not a subset of `ğ”‰`, technically it doesn't make sense to say "`X` generates `ğ”‰`." But as long as ğ’¦ contains a nontrivial algebra, we will have `Ïˆ(ğ’¦, ğ‘» ğ‘‹) âˆ© XÂ² â‰  âˆ…`, and we can identify `X` with `X / Ïˆ(ğ’¦, ğ‘» X)` which does belong to ğ”‰.</span>

<br>
<br>


[â† Varieties.Preservation](Varieties.Preservation.html)
<span style="float:right;">[Varieties â†‘](Varieties.html)</span>

{% include UALib.Links.md %}






