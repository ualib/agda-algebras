.. include:: _static/math_macros.rst

.. _inductively-defined-types:

=========================
Inductively Defined Types
=========================

A primary motivation for this project was our observation that, on the one hand, many important constructs in universal algebra can be defined inductively, and on the other hand, type theory in general, and Lean in particular, offers excellent support for defining inductive types and powerful tactics for proving their properties.

These two facts suggest that there should be much to gain from implementing universal algebra in an expressive type system that offers powerful tools for proving theorems about inductively defined types.  Examples demonstrating how this vision manifests in Lean code are provided in :numref:`Sections %s <subuniverse-generation>`, :numref:`%s <clones-in-lean>` and :numref:`%s <terms-in-lean>`.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: ! subalgebra, ! subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean2:
.. _subuniverse-generation:

Subuniverse generation in Lean
-------------------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of (the ``dev_wjd`` branch of) the lean-ualib_ repository.

In :numref:`Section %s <subalgebras-in-lean1>`, we saw how :ref:`subalgebras <subalgebras>` can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the :ref:`subuniverse generation theorem <thm-1-14>`. 

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
    definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
    structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
    definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
    definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
    instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
    instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©
 
    namespace subuniverse
      section sub
        parameters {Ïƒ : signature} {Î± : Type*} {I : Type*}
        def F := Ïƒ.F
        def Ï := Ïƒ.Ï 
        def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
        def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
        def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
        theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
        assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
        theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
        assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
        -- Fact 1. X is a subset of Sgá´¬(X) ----------------------------------------
        lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= 
        assume x (h: x âˆˆ X), 
          show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
            assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
            show x âˆˆ W, from 
              have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
            hâ‚‚.right h
        -- Fact 2. A subuniverse that contains X also contains Sgá´¬ X --
        lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
        assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- An alternative proof of Fact 2. ---------
        lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
        assume R (hc : Sub R âˆ§ X âŠ† R),
        have hâ‚: Sub R, from hc.left,
        have hâ‚‚: X âŠ† R, from hc.right,
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- Yet another derivation of Fact 2. ---------
        lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
        show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
        -- Sgá´¬ X is a subuniverse of A --------------------------
        lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= 
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
        show ğ”¸ f a âˆˆ Sg X, from 
          assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
            have hâ‚: Sg X âŠ† W, from 
              sInter_mem' W h,
            have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
            (h.left f a h')
    -- BEGIN
    inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
    | var (x : ğ”¸) : x âˆˆ X â†’ Y x
    | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)
    -- END  
      end sub
    end subuniverse

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^ğ”¸(X)`, which is another fact that we formalize and prove below.

.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
    definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
    structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
    definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
    definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
    instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
    instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©
 
    namespace subuniverse
      section sub
        parameters {Ïƒ : signature} {Î± : Type*} {I : Type*}
        def F := Ïƒ.F
        def Ï := Ïƒ.Ï 
        def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
        def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
        def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
        theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
        assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
        theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
        assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
        lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:=                                   -- Fact 1.
        assume x (h: x âˆˆ X), 
          show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
            assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
            show x âˆˆ W, from 
              have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
            hâ‚‚.right h
        lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                                                     -- Fact 2.
        âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
        assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                               -- An alternative proof of Fact 2.
        âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
        assume R (hc : Sub R âˆ§ X âŠ† R),
        have hâ‚: Sub R, from hc.left,
        have hâ‚‚: X âŠ† R, from hc.right,
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                          -- Yet another derivation of Fact 2.
        âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
        show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
        lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):=               -- Sgá´¬ X is a subuniverse of A
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
        show ğ”¸ f a âˆˆ Sg X, from 
          assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
            have hâ‚: Sg X âŠ† W, from 
              sInter_mem' W h,
            have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
            (h.left f a h')
        inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
        | var (x : ğ”¸) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)

    -- BEGIN
    -- Y X is a subuniverse
    lemma Y_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Y X):= 
    assume f a (h: âˆ€ i, Y X (a i)), show Y X (ğ”¸ f a), from 
    Y.app f a h 

    -- Y A X is the subuniverse generated by X
    theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
    have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), 
      show x  âˆˆ Y X, from Y.var x h,
    have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), 
      show Y X (ğ”¸ f a), from Y.app f a h,
    have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
    have inc_r: Y X âŠ† Sg X, from assume a (h: a âˆˆ Y X), 
      show a âˆˆ Sg X, from
        have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from 
          Y.rec
          ( --base: a = x âˆˆ X
            assume x (hrâ‚: x âˆˆ X), 
            show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚ 
          )
          ( --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
            assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X),
            show ğ”¸ f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ 
          ),
        hâ‚‚ h,
    set.subset.antisymm inc_l inc_r
    -- END  
      end sub
    end subuniverse

Finally, we prove that ``Y`` is the smallest subalgebra containing ``X``.

.. code-block:: lean

    import data.set  -- the set.lean file from mathlib
    definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
    definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
    structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
    definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
    definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
    instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
    instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©
 
    namespace subuniverse
      section sub
        parameters {Ïƒ : signature} {Î± : Type*} {I : Type*}
        def F := Ïƒ.F
        def Ï := Ïƒ.Ï 
        def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
        def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
        def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
        theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
        assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
        theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
        assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
        lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:=                                   -- Fact 1.
        assume x (h: x âˆˆ X), 
          show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
            assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
            show x âˆˆ W, from 
              have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
            hâ‚‚.right h
        lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                                                     -- Fact 2.
        âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
        assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                               -- An alternative proof of Fact 2.
        âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
        assume R (hc : Sub R âˆ§ X âŠ† R),
        have hâ‚: Sub R, from hc.left,
        have hâ‚‚: X âŠ† R, from hc.right,
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                          -- Yet another derivation of Fact 2.
        âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
        show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
        lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):=               -- Sgá´¬ X is a subuniverse of A
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
        show ğ”¸ f a âˆˆ Sg X, from 
          assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
            have hâ‚: Sg X âŠ† W, from 
              sInter_mem' W h,
            have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
            (h.left f a h')
        inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
        | var (x : ğ”¸) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)

        -- Y X is a subuniverse
        lemma Y_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Y X):= 
        assume f a (h: âˆ€ i, Y X (a i)), show Y X (ğ”¸ f a), from 
        Y.app f a h 
    
        -- Y A X is the subuniverse generated by X
        theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
        have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), 
          show x  âˆˆ Y X, from Y.var x h,
        have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), 
          show Y X (ğ”¸ f a), from Y.app f a h,
        have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
        have inc_r: Y X âŠ† Sg X, from assume a (h: a âˆˆ Y X), 
          show a âˆˆ Sg X, from
            have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from 
              Y.rec
              ( --base: a = x âˆˆ X
                assume x (hrâ‚: x âˆˆ X), 
                show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚ 
              )
              ( --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
                assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X),
                show ğ”¸ f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ 
              ),
            hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

    -- BEGIN
    definition index_of_sub_above_X {ğ”¸: algebra Ïƒ} 
    (X: set ğ”¸) (C: I â†’ set ğ”¸): I â†’ Prop:= 
    Î» i, Sub (C i) âˆ§ X âŠ† (C i) 

    lemma sInter_mem_of_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸} (x: ğ”¸): 
    x âˆˆ Sg X â†” âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
    iff.intro
      (assume (h: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚: Sub R) (hâ‚‚: X âŠ† R), 
        show x âˆˆ R, from h R (and.intro hâ‚ hâ‚‚))
      (assume (h: âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R), 
        show x âˆˆ Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))

    -- Y is the smallest Sub containing X
    lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): 
    Sub U â†’ X âŠ† U â†’ Y X âŠ† U:=
    assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U),
    assume (y: ğ”¸)  (p: Y X y), show U y, from 
      have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec

        --base step: y = x âˆˆ X
        ( assume y (h: X y) (h': Y X y), hâ‚‚ h )

        --induction step: y = A f a for some a with âˆ€ i, a i âˆˆ Y
        ( assume f a,
          assume hâ‚ƒ: âˆ€ i, Y X (a i), 
          assume hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i),
          assume hâ‚…: Y X (ğ”¸ f a),
          have hâ‚†: âˆ€ i, a i âˆˆ U, from 
            assume i, hâ‚„ i (hâ‚ƒ i), show U (ğ”¸ f a), from hâ‚ f a hâ‚† ),
      q p p

    -- END  
      end sub
    end subuniverse

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A âŠ† B â†’ B âŠ† A â†’ A = B`.

.. index:: recursor

We proved ``Y X âŠ† Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined.

The Lean keyword ``assume`` is syntactic sugar for ``Î»``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra, absolutely free, universal (for Ïƒ-algebras) 

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

The collection of terms over :math:`X`, along with the operations :math:`F^{ğ•‹(X)} := \{\mathsf{app} f âˆ£ f : F\}` forms an algebra in the signature :math:`Ïƒ = (F, Ï)`, which we denote and define by :math:`ğ•‹(X) = âŸ¨T(X), F^{ğ•‹(X)}âŸ©` .

Now, suppose :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` is an algebra in the signature Ïƒ and :math:`h : X â†’ A` is an arbitrary function.  We will show that :math:`h : X â†’ A` has a unique *extension* (or *lift*) to a homomorphism from :math:`ğ•‹(X)` to ğ”¸.

Since ğ”¸ and :math:`h : X â†’ A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`ğ•‹(X)` is **universal** for Ïƒ-algebras. Some authors say, ":math:`ğ•‹(X)` is **absolutely free** for Ïƒ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X â†’ A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`ğ•‹(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for Ïƒ-algebras, we show that the lift of an arbitrary function :math:`h : X â†’ A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

The Lean code described in this section is in the source file ``clone.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_ Also, although we don't make it explicit below, all of the code in the first part of this section is contained inside a single block of the form 

.. code::

    namespace clone
      section clo 
        ... 
      end clo
    end clone

First, we define a structure that specifies the properties that a clone must have.  As defined in :numref:`Section %s <clones>`, in order to be a clone a collection must include all projections and be closed under general composition.

.. include:: _static/clone.lean.1.rst

Next we inductively define a clone of operations generated by a given collection ``X`` of "basic" operations.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

---------------------------

.. rubric:: Footnotes

.. [1]
   As of this writing (9 June 2019), this documentation describes code residing on the dev_wjd_ branch of the ``lean-ualib`` repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.
   
.. _Lean: https://leanprover.github.io/

.. _`github.com/UniversalAlgebra/lean-ualib`: https://github.com/UniversalAlgebra/lean-ualib/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/

.. _dev_wjd: https://gitlab.com/ualib/lean-ualib/tree/dev_wjd

.. _master: https://gitlab.com/ualib/lean-ualib/tree/master

