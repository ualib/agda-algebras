.. include:: _static/math_macros.rst

.. _inductively-defined-type:

=========================
Inductively Defined Types
=========================

A primary motivation for this project was our observation that, on the one hand, many important constructs in universal algebra can be defined inductively, and on the other hand, type theory in general, and Lean in particular, offers excellent support for defining inductive types and powerful tactics for proving their properties.

These two facts suggest that there should be much to gain from implementing universal algebra in an expressive type system that offers powerful tools for proving theorems about inductively defined types.  Examples demonstrating how this vision manifests in Lean code are provided in :numref:`Sections %s <subuniverse-generation>`, :numref:`%s <clones>` and :numref:`%s <terms-and-free-algebras>`.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: ! subalgebra, ! subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean2:
.. _subuniverse-generation:

Subuniverse generation in Lean
-------------------------------

(The code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of the lean-ualib_ repository.)

In :numref:`Section %s <subalgebras-in-lean1>`, we saw how :ref:`subalgebras <subalgebras>` can be implemented in Lean_ and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and manifests the :numref:`subuniverse generation theorem <thm-1-14>`. 

We present definitions of two inductive types, both of which implement the **subuniverse generated by a set**; cf. the definition :eq:`subalgebra-inductive` presented above in the informal syntax.

.. code-block:: lean

    definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
    definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
    structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
    definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
    definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
    instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
    instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameter {Ïƒ : signature} {Î± : Type*} {I : Type*}
        def F := Ïƒ.F
        def Ï := Ïƒ.Ï 
        def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
        def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
        def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
        theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
        assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
        theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
        assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
        -- Fact 1. X is a subset of Sgá´¬(X) ----------------------------------------
        lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= 
        assume x (h: x âˆˆ X), 
          show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
            assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
            show x âˆˆ W, from 
              have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
            hâ‚‚.right h
        -- Fact 2. A subuniverse that contains X also contains Sgá´¬ X --
        lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
        assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- An alternative proof of Fact 2. ---------
        lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
        assume R (hc : Sub R âˆ§ X âŠ† R),
        have hâ‚: Sub R, from hc.left,
        have hâ‚‚: X âŠ† R, from hc.right,
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- Yet another derivation of Fact 2. ---------
        lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
        show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
        -- Sgá´¬ X is a subuniverse of A --------------------------
        lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= 
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
        show ğ”¸ f a âˆˆ Sg X, from 
          assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
            have hâ‚: Sg X âŠ† W, from 
              sInter_mem' W h,
            have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
            (h.left f a h')

        -- BEGIN
        inductive Y (X : set Î±) : set Î±
        | var (x : Î±) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ Î±) : (âˆ€ i, Y (a i)) â†’ Y (A f a)

        inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
        | var (x : ğ”¸) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)
        -- END  

      end sub
    end subuniverse

Next we prove that the type ``Y X`` defines a subuniverse, and that it is, in fact, equal to :math:`\mathrm{Sg}^ğ€(X)`.

.. code-block:: lean

    definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
    definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
    structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
    definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
    definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
    instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
    instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameter {Ïƒ : signature} {Î± : Type*} {I : Type*}
        def F := Ïƒ.F
        def Ï := Ïƒ.Ï 
        def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
        def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
        def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
        theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
        assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
        theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
        assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
          -- Fact 1. X is a subset of Sgá´¬(X) ----------------------------------------
        lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= 
        assume x (h: x âˆˆ X), 
          show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
            assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
            show x âˆˆ W, from 
              have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
            hâ‚‚.right h
        -- Fact 2. A subuniverse that contains X also contains Sgá´¬ X --
        lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
        assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- An alternative proof of Fact 2. ---------
        lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
        assume R (hc : Sub R âˆ§ X âŠ† R),
        have hâ‚: Sub R, from hc.left,
        have hâ‚‚: X âŠ† R, from hc.right,
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- Yet another derivation of Fact 2. ---------
        lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
        show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
        -- Sgá´¬ X is a subuniverse of A --------------------------
        lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= 
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
        show ğ”¸ f a âˆˆ Sg X, from 
          assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
            have hâ‚: Sg X âŠ† W, from 
              sInter_mem' W h,
            have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
            (h.left f a h')

        inductive Y (X : set Î±) : set Î±
        | var (x : Î±) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ Î±) : (âˆ€ i, Y (a i)) â†’ Y (A f a)

        inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
        | var (x : ğ”¸) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)

        -- BEGIN
        -- Y X is a subuniverse
        lemma Y_is_Sub (X : set Î±) : Sub (Y X) := 
        assume f a (h: âˆ€ i, Y X (a i)), show Y X (A f a), from 
        Y.app f a h 
       
        -- Y X is the subuniverse generated by X
        theorem sg_inductive (X : set Î±) : Sg X = Y X :=
        have hâ‚€ : X âŠ† Y X, from 
          assume x (h : x âˆˆ X), 
          show x âˆˆ Y X, from Y.var x h,
        have hâ‚ : Sub (Y X), from 
          assume f a (h : âˆ€ x, Y X (a x)), 
          show Y X (A f a), from Y.app f a h,
        have inc_l : Sg X âŠ† Y X, from 
           assume u (h : u âˆˆ Sg X), 
           show u âˆˆ Y X, from (sInter_mem u) h hâ‚ hâ‚€,
        have inc_r : Y X âŠ† Sg X, from
           assume a (h: a âˆˆ Y X), show a âˆˆ Sg X, from
             have h' : a âˆˆ Y X â†’ a âˆˆ Sg X, from 
               Y.rec
               --base: a = x âˆˆ X
               ( assume x (h1 : x âˆˆ X), 
                 show x âˆˆ Sg X, from subset_X_of_SgX X h1 )
               --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
               ( assume f b (h2 : âˆ€ i, b i âˆˆ Y X) (h3 : âˆ€ i, b i âˆˆ Sg X),
                 show A f b âˆˆ Sg X, from SgX_is_Sub X f b h3 ),
             h' h,
        subset.antisymm inc_l inc_r
        -- END  

      end sub
    end subuniverse

Finally, we prove that ``Y`` is the smallest subalgebra containing ``X``.

.. code-block:: lean

    definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
    definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
    structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
    definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
    definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
    instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
    instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©
    import data.set  -- the set.lean file from mathlib
 
    namespace subuniverse
      section sub
        parameter {Ïƒ : signature} {Î± : Type*} {I : Type*}
        def F := Ïƒ.F
        def Ï := Ïƒ.Ï 
        def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
        def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
        def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
        theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
        assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
        theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
        lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
        assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
          -- Fact 1. X is a subset of Sgá´¬(X) ----------------------------------------
        lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= 
        assume x (h: x âˆˆ X), 
          show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
            assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
            show x âˆˆ W, from 
              have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
            hâ‚‚.right h
        -- Fact 2. A subuniverse that contains X also contains Sgá´¬ X --
        lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
        assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- An alternative proof of Fact 2. ---------
        lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
        assume R (hc : Sub R âˆ§ X âŠ† R),
        have hâ‚: Sub R, from hc.left,
        have hâ‚‚: X âŠ† R, from hc.right,
        show Sg X âŠ† R, from 
          assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
            h R (and.intro hâ‚ hâ‚‚)
        -- Yet another derivation of Fact 2. ---------
        lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
        âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
        show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
        -- Sgá´¬ X is a subuniverse of A --------------------------
        lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= 
        assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
        show ğ”¸ f a âˆˆ Sg X, from 
          assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
            have hâ‚: Sg X âŠ† W, from 
              sInter_mem' W h,
            have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
            (h.left f a h')

        inductive Y (X : set Î±) : set Î±
        | var (x : Î±) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ Î±) : (âˆ€ i, Y (a i)) â†’ Y (A f a)

        inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
        | var (x : ğ”¸) : x âˆˆ X â†’ Y x
        | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)

        -- Y X is a subuniverse
        lemma Y_is_Sub (X : set Î±) : Sub (Y X) := 
        assume f a (h: âˆ€ i, Y X (a i)), show Y X (A f a), from 
        Y.app f a h 
       
        -- Y X is the subuniverse generated by X
        theorem sg_inductive (X : set Î±) : Sg X = Y X :=
        have hâ‚€ : X âŠ† Y X, from 
          assume x (h : x âˆˆ X), 
          show x âˆˆ Y X, from Y.var x h,
        have hâ‚ : Sub (Y X), from 
          assume f a (h : âˆ€ x, Y X (a x)), 
          show Y X (A f a), from Y.app f a h,
        have inc_l : Sg X âŠ† Y X, from 
           assume u (h : u âˆˆ Sg X), 
           show u âˆˆ Y X, from (sInter_mem u) h hâ‚ hâ‚€,
        have inc_r : Y X âŠ† Sg X, from
           assume a (h: a âˆˆ Y X), show a âˆˆ Sg X, from
             have h' : a âˆˆ Y X â†’ a âˆˆ Sg X, from 
               Y.rec
               --base: a = x âˆˆ X
               ( assume x (h1 : x âˆˆ X), 
                 show x âˆˆ Sg X, from subset_X_of_SgX X h1 )
               --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
               ( assume f b (h2 : âˆ€ i, b i âˆˆ Y X) (h3 : âˆ€ i, b i âˆˆ Sg X),
                 show A f b âˆˆ Sg X, from SgX_is_Sub X f b h3 ),
             h' h,
        subset.antisymm inc_l inc_r

        -- BEGIN

        definition index_of_sub_above_X {ğ”¸: algebra Ïƒ} 
        (X: set ğ”¸) (C: I â†’ set ğ”¸): I â†’ Prop:= 
        Î» i, Sub (C i) âˆ§ X âŠ† (C i) 
    
        lemma sInter_mem_of_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸} (x: ğ”¸): 
        x âˆˆ Sg X â†” âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
        iff.intro
          (assume (h: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚: Sub R) (hâ‚‚: X âŠ† R), 
            show x âˆˆ R, from h R (and.intro hâ‚ hâ‚‚))
          (assume (h: âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R), 
            show x âˆˆ Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))
    
        -- Y is the smallest Sub containing X
        lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): 
        Sub U â†’ X âŠ† U â†’ Y X âŠ† U:=
        assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U),
        assume (y: ğ”¸)  (p: Y X y), show U y, from 
          have q: Y X y â†’ Y X y â†’ U y, from 
            Y.rec
    
            --base step: y = x âˆˆ X
            ( assume y (h: X y) (h': Y X y), hâ‚‚ h )
    
            --induction step: y = A f a for some a with âˆ€ i, a i âˆˆ Y
            ( assume f a,
              assume hâ‚ƒ: âˆ€ i, Y X (a i), 
              assume hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i),
              assume hâ‚…: Y X (ğ”¸ f a),
              have hâ‚†: âˆ€ i, a i âˆˆ U, from 
                assume i, hâ‚„ i (hâ‚ƒ i), show U (ğ”¸ f a), from hâ‚ f a hâ‚† ),
          q p p
        -- END  
      end sub
    
    end subuniverse

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A âŠ† B â†’ B âŠ† A â†’ A = B`.

.. index:: recursor

We proved ``Y X âŠ† Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined.

The Lean keyword ``assume`` is syntactic sugar for ``Î»``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

.. todo:: complete this section

---------------------------------------------

.. index:: variables, word, term, free algebra

.. _terms-and-free-algebras-in-lean:

Terms and free algebras in Lean
--------------------------------

(The code described in this section is found in the file ``free.lean`` in the ``src`` directory of the lean-ualib_ repository.)

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`ğ“(X)` of all terms of a given signature.

.. code-block:: lean

    import basic
    section
      parameters {Ïƒ : signature} (X :Type*) 
      local notation `F` := Ïƒ.F
      local notation `Ï` := Ïƒ.Ï 
    
      inductive term
      | var : X â†’ term
      | app (f : F) : (Ï f â†’ term) â†’ term
  
      def Term : algebra S := âŸ¨term, term.appâŸ©
    end

The set of terms along with the operations :math:`F^{ğ“} := \{\mathsf{app} f | f : F\}` forms an algebra :math:`ğ“(X) = âŸ¨T(X), F^{ğ“}âŸ©` in the signature :math:`Ïƒ = (F, Ï)`.

Suppose :math:`ğ€ = âŸ¨A, F^{ğ€}âŸ©` is an algebra in the same signature and :math:`h : X â†’ A` is an arbitrary function.  We will show that :math:`h : X â†’ A` has a unique *extension* (or *lift*) to a homomorphism from :math:`ğ“(X)` to ğ€.

Since ğ€ and :math:`h : X â†’ A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`ğ“(X)` is *universal* for Ïƒ-algebras. Some authors say, ":math:`ğ“(X)` is *absolutely free* for Ïƒ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. code-block:: lean

    section
      open term
      parameters {Ïƒ : signature} (X :Type*) {A : algebra Ïƒ}
      definition F := Ïƒ.F         -- operation symbols
      definition Ï := Ïƒ.Ï         -- arity function
      definition ğ•‹ := @Term Ïƒ     -- term algebra over X
      definition ğ• := @var Ïƒ X    -- generators of the term algebra

If :math:`h : X â†’ A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`ğ•‹(X)` is defined inductively as follows:

.. code-block:: lean

    definition lift_of (h : X â†’ A) : ğ•‹(X) â†’ 
    | (var x) := h x
    | (app f a) := (A f) (Î» x, lift_of (a x))

To prove that the term algebra is universal for Ïƒ-algebras, we show that the lift of an arbitrary function :math:`h : X â†’ A` is a homomorphism and that this lift is unique.

.. code-block:: lean

      -- The lift is a homomorphism.
      lemma lift_is_hom (h : X â†’ A) : homomorphic (lift_of h) :=
      Î» f a, show lift_of h (app f a) = A f (lift_of h âˆ˜ a), from rfl
    
      -- The lift is unique.
      lemma lift_is_unique : âˆ€ {h h' : ğ•‹(X) â†’ A},
      homomorphic h â†’ homomorphic h' â†’ h âˆ˜ ğ• = h' âˆ˜ ğ• â†’ h = h' :=
      assume (h h' : ğ•‹(X) â†’ A) (hâ‚ : homomorphic h)
        (hâ‚‚ : homomorphic h')(hâ‚ƒ : h âˆ˜ ğ• = h' âˆ˜ ğ•),
        show h = h', from 
          have hâ‚€ : âˆ€ t : ğ•‹(X), h t = h' t, from 
            assume t : ğ•‹(X), 
            begin
              induction t with t f a ihâ‚ ,
              show h (ğ• t) = h' (ğ• t),
              { apply congr_fun hâ‚ƒ t },
    
              show h (app f a) = h' (app f a),
              { have ihâ‚‚  : h âˆ˜ a = h' âˆ˜ a, from funext ihâ‚,
                calc h (app f a) = A f (h âˆ˜ a) : hâ‚ f a
                             ... = A f (h' âˆ˜ a) : congr_arg (A f) ihâ‚‚ 
                             ... = h' (app f a) : (hâ‚‚ f a).symm }
            end,
          funext hâ‚€ 
    end


.. todo:: complete this section


.. _Lean: https://leanprover.github.io/

.. _`github.com/UniversalAlgebra/lean-ualib`: https://github.com/UniversalAlgebra/lean-ualib/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/

