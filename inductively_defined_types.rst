.. highlight:: lean

.. include:: _static/math_macros.rst

.. _inductively-defined-types:

=========================
Inductively Defined Types
=========================

(`The chapter on inductive types <https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html>`_ in the `Theorem Proving in Lean`_ tutorial gives a nice presentation of this topic. We start our presentation by quoting four key points from the start of `that chapter <https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html>`_.)

#. "Lean's formal foundation includes basic types, ``Prop, Type 0, Type 1, ...``, and allows for the formation of :term:`dependent function types <dependent function type>`, ``Î  x : Î±, Î²``."

#. "In Lean's library, every concrete type other than the universes and every type constructor other than ``Pi`` is an instance of a general family of type constructions known as *inductive types*."

#. "It is remarkable that it is possible to construct a substantial edifice of mathematics based on nothing more than the type universes, Pi types, and inductive types; everything else follows from those."

#. "Intuitively, an inductive type is built up from a specified list of constructors. In Lean, the syntax for specifying such a type is as follows:

   .. code-block:: text

       inductive foo : Sort u
       | constructorâ‚ : ... â†’ foo
       | constructorâ‚‚ : ... â†’ foo
       ...
       | constructorâ‚™ : ... â†’ foo

   The intuition is that each constructor specifies a way of building new objects of type ``foo``, possibly from previously constructed values. The type ``foo`` consists of nothing more than the objects that are constructed in this way."

------------------------------

.. _the-recursor:

The Recursor
------------

Each inductively defined type, say ``foo``, is accompanied by an elimination principle known as a **recursor** (denoted by ``foo.rec`` in Lean). This elimination principle is what makes the type "inductive"; it allows us to define a function on ``foo`` by assigning values for each of ``foo``'s constructors.

.. todo:: complete this section; include an example.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: ! subalgebra, ! subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean:

Subalgebras in Lean
-------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of the lean-ualib_ repository. [1]_

In :numref:`Section %s <subuniverses-in-lean>`, we saw how :ref:`subalgebras <subalgebras>` can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the :ref:`subuniverse generation theorem <thm-1-14>`. 

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

::

  import data.set  -- the set.lean file from mathlib
  definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
  definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
  structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
  definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
  definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
  instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
  instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©

  namespace subuniverse
    section sub
      parameters {Ïƒ : signature} {Î± : Type*} {I : Type*}
      def F := Ïƒ.F
      def Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
      def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
      def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
      theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
      assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
      assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
      assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
      show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
      -- Fact 1. X is a subset of Sgá´¬(X) ----------------------------------------
      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= 
      assume x (h: x âˆˆ X), 
        show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
          assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
          show x âˆˆ W, from 
            have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
          hâ‚‚.right h
      -- Fact 2. A subuniverse that contains X also contains Sgá´¬ X --
      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
      âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
      show Sg X âŠ† R, from 
        assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
          h R (and.intro hâ‚ hâ‚‚)
      -- An alternative proof of Fact 2. ---------
      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
      âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R),
      have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right,
      show Sg X âŠ† R, from 
        assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
          h R (and.intro hâ‚ hâ‚‚)
      -- Yet another derivation of Fact 2. ---------
      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:
      âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
      assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
      show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
      -- Sgá´¬ X is a subuniverse of A --------------------------
      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= 
      assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
      show ğ”¸ f a âˆˆ Sg X, from 
        assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
          have hâ‚: Sg X âŠ† W, from 
            sInter_mem' W h,
          have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
          (h.left f a h')
    -- BEGIN
    inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
    | var (x : ğ”¸) : x âˆˆ X â†’ Y x
    | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)
    -- END  
    end sub
  end subuniverse

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^ğ”¸(X)`, which is another fact that we formalize and prove below.

::

  import data.set  -- the set.lean file from mathlib
  definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
  definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
  structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
  definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
  definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
  instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
  instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©

  namespace subuniverse
    section sub
      parameters {Ïƒ : signature} {Î± : Type*} {I : Type*}
      def F := Ïƒ.F
      def Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
      def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
      def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
      theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
      assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
      assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
      assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
      show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:=                                   -- Fact 1.
      assume x (h: x âˆˆ X), 
        show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
          assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
          show x âˆˆ W, from 
            have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
          hâ‚‚.right h
      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                                                     -- Fact 2.
      âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
      show Sg X âŠ† R, from 
        assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
          h R (and.intro hâ‚ hâ‚‚)
      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                               -- An alternative proof of Fact 2.
      âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R),
      have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right,
      show Sg X âŠ† R, from 
        assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
          h R (and.intro hâ‚ hâ‚‚)
      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                          -- Yet another derivation of Fact 2.
      âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
      assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
      show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):=               -- Sgá´¬ X is a subuniverse of A
      assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
      show ğ”¸ f a âˆˆ Sg X, from 
        assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
          have hâ‚: Sg X âŠ† W, from 
            sInter_mem' W h,
          have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
          (h.left f a h')
      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)

    -- BEGIN
    -- Y X is a subuniverse
    lemma Y_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Y X):= 
    assume f a (h: âˆ€ i, Y X (a i)), show Y X (ğ”¸ f a), from 
    Y.app f a h 

    -- Y A X is the subuniverse generated by X
    theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
    have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), 
      show x  âˆˆ Y X, from Y.var x h,
    have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), 
      show Y X (ğ”¸ f a), from Y.app f a h,
    have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
    have inc_r: Y X âŠ† Sg X, from assume a (h: a âˆˆ Y X), 
      show a âˆˆ Sg X, from
        have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from 
          Y.rec
          ( --base: a = x âˆˆ X
            assume x (hrâ‚: x âˆˆ X), 
            show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚ 
          )
          ( --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
            assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X),
            show ğ”¸ f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ 
          ),
        hâ‚‚ h,
    set.subset.antisymm inc_l inc_r
    -- END  
    end sub
  end subuniverse

Finally, we prove that ``Y`` is the smallest subalgebra containing ``X``.

::

  import data.set  -- the set.lean file from mathlib
  definition op (Î² Î±) := (Î² â†’ Î±) â†’ Î±
  definition Ï€ {Î² Î±} (i) : op Î² Î± := Î» a, a i
  structure signature := mk :: (F : Type*) (Ï : F â†’ Type*)
  definition algebra_on (Ïƒ : signature) (Î± : Type*) := Î  (f : Ïƒ.F), op (Ïƒ.Ï f) Î±   
  definition algebra (Ïƒ : signature) := sigma (algebra_on Ïƒ)
  instance alg_carrier (Ïƒ : signature) : has_coe_to_sort (algebra Ïƒ) := âŸ¨_, sigma.fstâŸ©
  instance alg_operations (Ïƒ : signature) : has_coe_to_fun (algebra Ïƒ) := âŸ¨_, sigma.sndâŸ©

  namespace subuniverse
    section sub
      parameters {Ïƒ : signature} {Î± : Type*} {I : Type*}
      def F := Ïƒ.F
      def Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ} (Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸ f a) âˆˆ Bâ‚€
      def is_subalgebra (ğ”¸: algebra Ïƒ) (Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸ f â†‘b
      def Sg (A : algebra_on Ïƒ Î±) (X : set Î±) : set Î± := â‹‚â‚€ {U | Sub A U âˆ§ X âŠ† U}
      theorem Inter.intro {ğ”¸: algebra Ïƒ} {s: I â†’ set ğ”¸}: âˆ€ (x: ğ”¸), (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) :=
      assume x h t âŸ¨j, (eq: t = s j)âŸ©, eq.symm â–¸ h j
      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: I â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h: x âˆˆ â‹‚ i, C i, by simp at h; apply h
      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: I â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= 
      assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
      assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
      show ğ”¸ f a âˆˆ â‹‚i, C i, from Inter.intro (ğ”¸ f a) (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))
      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:=                                   -- Fact 1.
      assume x (h: x âˆˆ X), 
        show x âˆˆ â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}, from 
          assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}),  
          show x âˆˆ W, from 
            have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, 
          hâ‚‚.right h
      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                                                     -- Fact 2.
      âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R),
      show Sg X âŠ† R, from 
        assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
          h R (and.intro hâ‚ hâ‚‚)
      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                               -- An alternative proof of Fact 2.
      âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R),
      have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right,
      show Sg X âŠ† R, from 
        assume x (h: x âˆˆ Sg X), show x âˆˆ R, from 
          h R (and.intro hâ‚ hâ‚‚)
      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}:                          -- Yet another derivation of Fact 2.
      âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
      assume x (hâ‚: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), 
      show x âˆˆ R, from hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)
      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):=               -- Sgá´¬ X is a subuniverse of A
      assume (f: F) (a: Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), 
      show ğ”¸ f a âˆˆ Sg X, from 
        assume W (h: Sub W âˆ§ X âŠ† W), show ğ”¸ f a âˆˆ W, from 
          have hâ‚: Sg X âŠ† W, from 
            sInter_mem' W h,
          have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i),
          (h.left f a h')
      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : F) (a : Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸ f a)

      -- Y X is a subuniverse
      lemma Y_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Y X):= 
      assume f a (h: âˆ€ i, Y X (a i)), show Y X (ğ”¸ f a), from 
      Y.app f a h 
  
      -- Y A X is the subuniverse generated by X
      theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
      have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), 
        show x  âˆˆ Y X, from Y.var x h,
      have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), 
        show Y X (ğ”¸ f a), from Y.app f a h,
      have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
      have inc_r: Y X âŠ† Sg X, from assume a (h: a âˆˆ Y X), 
        show a âˆˆ Sg X, from
          have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from 
            Y.rec
            ( --base: a = x âˆˆ X
              assume x (hrâ‚: x âˆˆ X), 
              show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚ 
            )
            ( --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
              assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X),
              show ğ”¸ f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ 
            ),
          hâ‚‚ h,
      set.subset.antisymm inc_l inc_r

    -- BEGIN
    definition index_of_sub_above_X {ğ”¸: algebra Ïƒ} 
    (X: set ğ”¸) (C: I â†’ set ğ”¸): I â†’ Prop:= 
    Î» i, Sub (C i) âˆ§ X âŠ† (C i) 

    lemma sInter_mem_of_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸} (x: ğ”¸): 
    x âˆˆ Sg X â†” âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= 
    iff.intro
      (assume (h: x âˆˆ Sg X) (R: set ğ”¸) (hâ‚: Sub R) (hâ‚‚: X âŠ† R), 
        show x âˆˆ R, from h R (and.intro hâ‚ hâ‚‚))
      (assume (h: âˆ€ {R: set ğ”¸}, Sub R â†’ X âŠ† R â†’ x âˆˆ R), 
        show x âˆˆ Sg X, from h (SgX_is_Sub X) (subset_X_of_SgX X))

    -- Y is the smallest Sub containing X
    lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): 
    Sub U â†’ X âŠ† U â†’ Y X âŠ† U:=
    assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U),
    assume (y: ğ”¸)  (p: Y X y), show U y, from 
      have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec

        --base step: y = x âˆˆ X
        ( assume y (h: X y) (h': Y X y), hâ‚‚ h )

        --induction step: y = A f a for some a with âˆ€ i, a i âˆˆ Y
        ( assume f a,
          assume hâ‚ƒ: âˆ€ i, Y X (a i), 
          assume hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i),
          assume hâ‚…: Y X (ğ”¸ f a),
          have hâ‚†: âˆ€ i, a i âˆˆ U, from 
            assume i, hâ‚„ i (hâ‚ƒ i), show U (ğ”¸ f a), from hâ‚ f a hâ‚† ),
      q p p

    -- END  
    end sub
  end subuniverse

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A âŠ† B â†’ B âŠ† A â†’ A = B`.

.. index:: recursor

We proved ``Y X âŠ† Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined.

The Lean keyword ``assume`` is syntactic sugar for ``Î»``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra
.. index:: universal for; Ïƒ-algebras
.. index:: absolutely free for; Ïƒ-algebras

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

The collection of terms over :math:`X`, along with the operations :math:`F^{ğ•‹(X)} := \{\mathsf{app} f âˆ£ f : F\}` forms an algebra in the signature :math:`Ïƒ = (F, Ï)`, which we denote and define by :math:`ğ•‹(X) = âŸ¨T(X), F^{ğ•‹(X)}âŸ©` .

Now, suppose :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` is an algebra in the signature Ïƒ and :math:`h : X â†’ A` is an arbitrary function.  We will show that :math:`h : X â†’ A` has a unique *extension* (or *lift*) to a homomorphism from :math:`ğ•‹(X)` to ğ”¸.

Since ğ”¸ and :math:`h : X â†’ A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`ğ•‹(X)` is **universal for** Ïƒ-algebras. Some authors say, ":math:`ğ•‹(X)` is **absolutely free for** Ïƒ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X â†’ A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`ğ•‹(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for Ïƒ-algebras, we show that the lift of an arbitrary function :math:`h : X â†’ A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

The Lean code described in this section is in the source file ``clone.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_ Also, although we don't make it explicit below, all of the code in the first part of this section is contained inside a single block of the form 

.. code::

    namespace clone
      section clo 
        ... 
      end clo
    end clone

First, we define a structure that specifies the properties that a clone must have.  As defined in :numref:`Section %s <clones>`, in order to be a clone a collection must include all projections and be closed under general composition.

.. include:: _static/clone.lean.1.rst

Next we define an inductive type that represents the clone generated by a given collection ``X`` of operations.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

---------------------------

Basic Facts in Lean
--------------------

In this section we show how to state and prove in Lean the basic facts of `basic-facts`_.

.. index:: ! equalizer

Recall, the **equalizer** of the functions :math:`g` and :math:`h` is the set

.. math:: ğ–¤(g,h) = \{ a : A âˆ£ g(a) = h(a) \}.

We begin by defining in Lean

#. the equalizer of two functions, ``E``,

#. the assertion that a function is a homomorphism ``hom``, and 

#. the equalizer of two homomorphisms ``E_hom``.

::

  import subuniverse 
  import data.set

  universe u -- where structure universe (i.e. carrier) types live  (Î±)

  namespace ualib

    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b

    section basic_facts

      -- equalizer (of functions)
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := 
      Î» (x: Î±), f x = g x 

      -- indicates whether g is a homomorphism  
      def hom {ğ”¸ ğ”¹: algebra Ïƒ}
      (g: ğ”¸ â†’ ğ”¹): Prop :=
      âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)

      -- the set on which two homs agree
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ}
      (g h: ğ”¸ â†’ ğ”¹)
      (hâ‚: hom g) (hâ‚‚: hom h): set ğ”¸ := 
      Î» a, g a = h a 

    end basic_facts

  end ualib

Recall the simple fact that composing two homomorphisms results in a homomorphism.

::

  import subuniverse 
  import data.set
  
  universe u -- where structure universe (i.e. carrier) types live  (Î±)
  
  namespace ualib
    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b
    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹)(hâ‚: hom g) (hâ‚‚: hom h): set ğ”¸ := Î» a, g a = h a 
    
    -- BEGIN
    -- 0. The composition of homs is a hom.
    lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ}
    (g: ğ”¸ â†’ ğ”¹) (hâ‚: hom g)
    (h: ğ”¹ â†’ â„‚) (hâ‚‚: hom h): 
    hom (h âˆ˜ g) :=
    assume f a, 
    show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
      have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
      calc
        (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                   ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)
    -- END
    end basic_facts
  end ualib

Next we see that the equalizer ``ğ–¤ g h`` of two homomorphisms ``g`` and ``h`` is a subuniverse of ğ”¸; cf. :numref:`Obs %s <obs-one>`.

::

  import subuniverse 
  import data.set
  
  universe u -- where structure universe (i.e. carrier) types live  (Î±)
  
  namespace ualib
    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b
    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹)(hâ‚: hom g) (hâ‚‚: hom h): set ğ”¸ := Î» a, g a = h a 
    
      lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹) (hâ‚: hom g) (h: ğ”¹ â†’ â„‚) (hâ‚‚: hom h): hom (h âˆ˜ g) :=
      assume f a, show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
        have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
        calc
          (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                     ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)
  
    -- BEGIN
    -- 1. The equalizer of homs is a subuniverse.
    lemma Sub_E_homs {ğ”¸ ğ”¹: algebra Ïƒ}
    (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): 
    Sub (E_homs h g hh hg) := 
    assume f a (hâ‚: âˆ€ x, a x âˆˆ (E_homs h g hh hg)),
    show ğ”¸ f a âˆˆ (E_homs h g hh hg),  from 
      have hâ‚‚: h âˆ˜ a = g âˆ˜ a, from funext hâ‚, 
      show h (ğ”¸ f a) = g (ğ”¸ f a), from 
        calc
          h (ğ”¸ f a) = ğ”¹ f (h âˆ˜ a) : hh f a
                ... = ğ”¹ f (g âˆ˜ a) : congr_arg (ğ”¹ f) hâ‚‚
                ... = g (ğ”¸ f a)   : eq.symm (hg f a)
    -- END
    end basic_facts
  end ualib
  
Next, if two homomorphisms agree on a generating set, then they are equal.

::

  import subuniverse 
  import data.set
  
  universe u -- where structure universe (i.e. carrier) types live  (Î±)
  
  namespace ualib
    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b
    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹)(hâ‚: hom g) (hâ‚‚: hom h): set ğ”¸ := Î» a, g a = h a 
    
      lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹) (hâ‚: hom g) (h: ğ”¹ â†’ â„‚) (hâ‚‚: hom h): hom (h âˆ˜ g) :=
      assume f a, show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
        have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
        calc
          (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                     ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)
  
      lemma Sub_E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): Sub (E_homs g h hg hh) := 
      assume f a (hâ‚: âˆ€ x, a x âˆˆ (E_homs g h hg hh)),
      show ğ”¸ f a âˆˆ (E_homs g h hg hh),  from 
        have hâ‚‚: g âˆ˜ a = h âˆ˜ a, from funext hâ‚, 
        show g (ğ”¸ f a) = h (ğ”¸ f a), from 
          calc
            g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a) : hg f a
                  ... = ğ”¹ f (h âˆ˜ a) : congr_arg (ğ”¹ f) hâ‚‚
                  ... = h (ğ”¸ f a)   : eq.symm (hh f a)
    
    -- BEGIN
    -- (a preliminary, "obvious" fact)
    lemma mem_of_eq {Î± : Type u}
    (s t : set Î±): s = t â†’  âˆ€ x, x âˆˆ s â†’ x âˆˆ t := 
    begin intros h x h', rw â†h, assumption end
  
    -- 2. If X âŠ† ğ”¸, g and h are homs, and X âŠ† E g h, then
    --    Sg X âŠ† X.
    lemma hom_determined_on_gens {ğ”¸ ğ”¹: algebra Ïƒ}
    (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h) (X: set ğ”¸) : 
    X âŠ† E g h â†’ Sg X âŠ† E g h := 
    -- Idea of the proof: we have
    --     1. X âŠ† E h g,
    --     2. Sub (E h g), i.e., E h g is a subalgebra
    --     3. and Sg X is the smallest subalgebra containing X
    -- Therefore, Sg X âŠ† E h g, which means h = g on Sg X.
    assume hâ‚: X âŠ† E g h, show Sg X âŠ† E g h, from 
      have hâ‚ƒ: Sub (E g h), from 
        (Sub_E_homs g h hg hh),
      sInter_mem (E g h) hâ‚ƒ hâ‚
    -- END
    end basic_facts
    end ualib
  
It may be instructive to consider an alternative proof of the last fact using the recursor.

::

  import subuniverse 
  import data.set
  
  universe u -- where structure universe (i.e. carrier) types live  (Î±)
  
  namespace ualib
    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b
    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹)(hâ‚: hom g) (hâ‚‚: hom h): set ğ”¸ := Î» a, g a = h a 
    
      lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹) (hâ‚: hom g) (h: ğ”¹ â†’ â„‚) (hâ‚‚: hom h): hom (h âˆ˜ g) :=
      assume f a, show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
        have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
        calc
          (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                     ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)
  
      lemma Sub_E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): Sub (E_homs g h hg hh) := 
      assume f a (hâ‚: âˆ€ x, a x âˆˆ (E_homs g h hg hh)),
      show ğ”¸ f a âˆˆ (E_homs g h hg hh),  from 
        have hâ‚‚: g âˆ˜ a = h âˆ˜ a, from funext hâ‚, 
        show g (ğ”¸ f a) = h (ğ”¸ f a), from 
          calc
            g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a) : hg f a
                  ... = ğ”¹ f (h âˆ˜ a) : congr_arg (ğ”¹ f) hâ‚‚
                  ... = h (ğ”¸ f a)   : eq.symm (hh f a)
    
      lemma mem_of_eq {Î± : Type u} (s t : set Î±): s = t â†’  âˆ€ x, x âˆˆ s â†’ x âˆˆ t :=
      begin intros h x h', rw â†h, assumption end
    
    -- BEGIN
    -- Here's another proof of the last result using the recursor of Y.
    lemma hom_determined_on_gens_rec
    {ğ”¸ ğ”¹: algebra Ïƒ}
    (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h) (X: set ğ”¸): 
    (âˆ€ x, x âˆˆ X â†’ g x = h x) â†’ (âˆ€ a, a âˆˆ Sg X â†’ g a = h a) := 
    assume (hâ‚: âˆ€ x, x âˆˆ X â†’ g x = h x), 
    assume a (hâ‚‚: a âˆˆ Sg X),
    show g a = h a, from 
      have hâ‚ƒ: a âˆˆ Y X, from
        mem_of_eq (Sg X) (Y X) (sg_inductive X) a hâ‚‚,
      Y.rec 
        --base step: assume a = x âˆˆ X
        hâ‚ 
        --inductive step:
        -- assume a = ğ”¸ f b for some b with âˆ€ i, b i âˆˆ Sg X
        ( assume f b (hâ‚„ : âˆ€ i, b i âˆˆ Y X),
          assume (hâ‚… : âˆ€ i, g (b i) = h (b i)),
          show g (ğ”¸ f b) = h (ğ”¸ f b), from 
            have hâ‚† : g âˆ˜ b = h âˆ˜ b, from funext hâ‚…, 
            calc
              g (ğ”¸ f b) = (ğ”¹ f) (g âˆ˜ b): hg f b
                    ... = (ğ”¹ f) (h âˆ˜ b): congr_arg (ğ”¹ f) hâ‚†    
                    ... = h (ğ”¸ f b)    : eq.symm (hh f b)) hâ‚ƒ 
    -- END
    end basic_facts
  end ualib

-------------------------

.. rubric:: Footnotes

.. [1]
   As of this writing (9 June 2019), this documentation describes code residing on the william_ branch of the lean-ualib_ repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.
   
.. include:: hyperlink_references.rst
