.. highlight:: lean

.. include:: _static/math_macros.rst

.. _inductively-defined-types:

=========================
Inductively Defined Types
=========================

(`The chapter on inductive types <https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html>`_ in the `Theorem Proving in Lean`_ tutorial gives a nice presentation of this topic. We start our presentation by quoting four key points from the start of `that chapter <https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html>`_.)

#. "Lean's formal foundation includes basic types, ``Prop, Type 0, Type 1, ...``, and allows for the formation of :term:`dependent function types <dependent function type>`, ``Î  x : Î±, Î²``."

#. "In Lean's library, every concrete type other than the universes and every type constructor other than ``Pi`` is an instance of a general family of type constructions known as *inductive types*."

#. "It is remarkable that it is possible to construct a substantial edifice of mathematics based on nothing more than the type universes, Pi types, and inductive types; everything else follows from those."

#. "Intuitively, an inductive type is built up from a specified list of constructors. In Lean, the syntax for specifying such a type is as follows:

   .. code-block:: text

       inductive foo : Sort u
       | constructorâ‚ : ... â†’ foo
       | constructorâ‚‚ : ... â†’ foo
       ...
       | constructorâ‚™ : ... â†’ foo

   The intuition is that each constructor specifies a way of building new objects of type ``foo``, possibly from previously constructed values. The type ``foo`` consists of nothing more than the objects that are constructed in this way."

------------------------------

.. _the-recursor:

The Recursor
------------

Each inductively defined type, say ``foo``, is accompanied by an elimination principle known as a **recursor** (denoted by ``foo.rec`` in Lean). This elimination principle is what makes the type "inductive"; it allows us to define a function on ``foo`` by assigning values for each of ``foo``'s constructors.

.. todo:: complete this section; include an example.

.. \ref{sec:leans-hierarchy-of-sorts-and-types})

---------------------------------------------------

.. index:: ! subalgebra, ! subuniverse

.. index:: subuniverse generated by a set

.. _subalgebras-in-lean:

Subalgebras in Lean
-------------------

The Lean code described in this section is found in the file ``subuniverse.lean`` in the ``src`` directory of the lean-ualib_ repository. [1]_

In :numref:`Section %s <subuniverses-in-lean>`, we saw how :ref:`subalgebras <subalgebras>` can be implemented in Lean and proved some easy facts about them.  This section views subalgebras as an inductively defined type over a set of generators and implements the :ref:`subuniverse generation theorem <thm-1-14>`. 

First, we define an inductive type that represents the **subuniverse generated by a set**; cf. the informal language definition in given by :eq:`subalgebra-inductive` .

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)

    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„±
      definition Ï := Ïƒ.Ï
      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}
      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h
      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h
  
      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i), Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      -- BEGIN
      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x: ğ”¸): x âˆˆ X â†’ Y x
      | app (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸): (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)
      -- END
  end subuniverse

Next we prove that the type ``Y X`` is a subuniverse. Moreover, ``Y X`` is equal to :math:`\mathrm{Sg}^ğ”¸(X)`, which is another fact that we formalize and prove below.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)

    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„±
      definition Ï := Ïƒ.Ï

      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}
      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h
      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h
   
      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i), Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)
      
    -- BEGIN
    -- Y X is a subuniverse
    lemma Y_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Y X):= 
    assume f a (h: âˆ€ i, Y X (a i)), show Y X (ğ”¸ f a), from 
    Y.app f a h 

    -- Y A X is the subuniverse generated by X
    theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
    have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), 
    show x  âˆˆ Y X, from Y.var x h,
    have hâ‚: Sub (Y X), from
      assume f a (h : âˆ€ x, Y X (a x)), 
      show Y X (ğ”¸ f a), from Y.app f a h,
        have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
        have inc_r: Y X âŠ† Sg X, from assume a (h: a âˆˆ Y X), 
      show a âˆˆ Sg X, from
        have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from 
          Y.rec
          -- base step: a = x âˆˆ X
            (
              assume x (hrâ‚: x âˆˆ X), 
              show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚
            )
          -- induct step: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
            (
              assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X),
              assume (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X),
              show ğ”¸ f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ
            ),
          hâ‚‚ h,
          set.subset.antisymm inc_l inc_r
    -- END  
  end subuniverse

Finally, we prove that ``Y`` is the smallest subuniverse containing ``X``.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)

    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„±
      definition Ï := Ïƒ.Ï
      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}

      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h
    
      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i), Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)

      lemma Y_is_Sub {ğ”¸: algebra Ïƒ}(X: set ğ”¸): Sub (Y X):= assume f a (h: âˆ€ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
      have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), Y.var x h,
      have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
      have inc_r: Y X âŠ† Sg X, from
        assume a (h: a âˆˆ Y X), have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from
        Y.rec
          (assume x (hrâ‚: x âˆˆ X), show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚)
          (assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X), show ğ”¸.snd f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ ),
          hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

    -- BEGIN
    -- Y is the smallest Sub containing X
    lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): 
    Sub U â†’ X âŠ† U â†’ Y X âŠ† U:=
    assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U),
    assume (y: ğ”¸) (p: Y X y), show U y, from 
      have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec

        --base step: y = x âˆˆ X
        ( assume y (h: X y) (h': Y X y), hâ‚‚ h )

        --induction step: y = A f a for some a with âˆ€ i, a i âˆˆ Y
        ( assume f a,
          assume hâ‚ƒ: âˆ€ i, Y X (a i), 
          assume hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i),
          assume hâ‚…: Y X (ğ”¸ f a),
          have hâ‚†: âˆ€ i, a i âˆˆ U, from 
            assume i, hâ‚„ i (hâ‚ƒ i), show U (ğ”¸ f a), from hâ‚ f a hâ‚† ),
      q p p
    -- END  
    end sub
  end subuniverse

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A âŠ† B â†’ B âŠ† A â†’ A = B`.

.. index:: recursor

We proved ``Y X âŠ† Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined. (We will see many more examples of inductive proofs below.)

The Lean keyword ``assume`` is syntactic sugar for ``Î»``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

.. with congruence lattice $\Con\<A, \dots \>$.

---------------------------------------------

.. index:: variables, word, term, free algebra
.. index:: universal for; Ïƒ-algebras
.. index:: absolutely free for; Ïƒ-algebras

.. _terms-in-lean:

Terms in Lean
-------------

The Lean code described in this section is in the source files ``free.lean`` and ``term.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`T(X)` of all terms of a given signature over a collection :math:`X` of variables.

.. include:: _static/free.lean.1.rst

The collection of terms over :math:`X`, along with the operations :math:`F^{ğ•‹(X)} := \{\mathsf{app} f âˆ£ f : F\}` forms an algebra in the signature :math:`Ïƒ = (F, Ï)`, which we denote and define by :math:`ğ•‹(X) = âŸ¨T(X), F^{ğ•‹(X)}âŸ©` .

Now, suppose :math:`ğ”¸ = âŸ¨A, F^ğ”¸âŸ©` is an algebra in the signature Ïƒ and :math:`h : X â†’ A` is an arbitrary function.  We will show that :math:`h : X â†’ A` has a unique *extension* (or *lift*) to a homomorphism from :math:`ğ•‹(X)` to ğ”¸.

Since ğ”¸ and :math:`h : X â†’ A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`ğ•‹(X)` is **universal for** Ïƒ-algebras. Some authors say, ":math:`ğ•‹(X)` is **absolutely free for** Ïƒ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. include:: _static/free.lean.2.rst

If :math:`h : X â†’ A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`ğ•‹(X)` is defined inductively as follows:

.. include:: _static/free.lean.3.rst

To prove that the term algebra is universal for Ïƒ-algebras, we show that the lift of an arbitrary function :math:`h : X â†’ A` is a homomorphism and that this lift is unique.

.. include:: _static/free.lean.4.rst

---------------------------------------------

.. index:: clone

.. _clones-in-lean:

Clones in Lean
---------------

The Lean code described in this section is in the source file ``clone.lean``, which reside in the ``src`` directory of the lean-ualib_ repository. [1]_ Also, although we don't make it explicit below, all of the code in the first part of this section is contained inside a single block of the form 

.. code::

    namespace clone
      section clo 
        ... 
      end clo
    end clone

First, we define a structure that specifies the properties that a clone must have.  As defined in :numref:`Section %s <clones>`, in order to be a clone a collection must include all projections and be closed under general composition.

.. include:: _static/clone.lean.1.rst

Next we define an inductive type that represents the clone generated by a given collection ``X`` of operations.

.. include:: _static/clone.lean.2.rst

Finally, we check that the foregoing definition is indeed a clone and that it is the smallest clone containing the given collection of operations.

.. include:: _static/clone.lean.3.rst

---------------------------

.. _basic-facts-in-lean:

Basic Facts in Lean
--------------------

In this section we show how to state and prove in Lean the basic facts of :numref:`basic-facts`.

.. index:: ! equalizer

Recall, the **equalizer** of the functions :math:`g` and :math:`h` is the set

.. math:: ğ–¤(g,h) = \{ a : A âˆ£ g(a) = h(a) \}.

We begin by defining in Lean

#. the equalizer of two functions, ``E``,

#. a homomorphism, ``hom``, and 

#. the equalizer of two homomorphisms, ``E_hom``.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
  
    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„± 
      definition Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}

      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)

      lemma Y_is_Sub {ğ”¸: algebra Ïƒ}(X: set ğ”¸): Sub (Y X):= assume f a (h: âˆ€ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
      have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), Y.var x h,
      have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
      have inc_r: Y X âŠ† Sg X, from
        assume a (h: a âˆˆ Y X), have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from
        Y.rec
          (assume x (hrâ‚: x âˆˆ X), show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚)
          (assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X), show ğ”¸.snd f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ ),
          hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): Sub U â†’ X âŠ† U â†’ Y X âŠ† U:= assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U), assume (y: ğ”¸)  (p: Y X y), have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), hâ‚‚ h )
          ( assume f a (hâ‚ƒ: âˆ€ i, Y X (a i)) (hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i)) (hâ‚…: Y X (ğ”¸.snd f a)), have hâ‚†: âˆ€ i, a i âˆˆ U, from
            assume i, hâ‚„ i (hâ‚ƒ i), hâ‚ f a hâ‚† ), q p p
    end subuniverse

    section homomorphism
      parameters {Î±: Type u} {Î³: Type v}
      def homomorphic {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸ â†’ ğ”¹) := âˆ€ f a, h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
      def homomorphic_verbose {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸.fst â†’ ğ”¹.fst) := âˆ€ (f: Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸.fst), h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
    end homomorphism

    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b

    -- BEGIN
    section basic_facts
      parameter {Ïƒ: signature}

      -- equalizer (of functions)
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := 
      Î» (x: Î±), f x = g x 

      -- indicates whether g is a homomorphism  
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop :=
      âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)

      -- the set on which two homs agree
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ} (g h: ğ”¸ â†’ ğ”¹)
      (hg: hom g) (hh: hom h): set ğ”¸ := 
      Î» (a: ğ”¸), g a = h a 

    end basic_facts
    -- END

  end ualib

Recall the simple fact that composing two homomorphisms results in a homomorphism.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
  
    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„± 
      definition Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}

      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)

      lemma Y_is_Sub {ğ”¸: algebra Ïƒ}(X: set ğ”¸): Sub (Y X):= assume f a (h: âˆ€ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
      have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), Y.var x h,
      have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
      have inc_r: Y X âŠ† Sg X, from
        assume a (h: a âˆˆ Y X), have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from
        Y.rec
          (assume x (hrâ‚: x âˆˆ X), show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚)
          (assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X), show ğ”¸.snd f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ ),
          hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): Sub U â†’ X âŠ† U â†’ Y X âŠ† U:= assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U), assume (y: ğ”¸)  (p: Y X y), have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), hâ‚‚ h )
          ( assume f a (hâ‚ƒ: âˆ€ i, Y X (a i)) (hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i)) (hâ‚…: Y X (ğ”¸.snd f a)), have hâ‚†: âˆ€ i, a i âˆˆ U, from
            assume i, hâ‚„ i (hâ‚ƒ i), hâ‚ f a hâ‚† ), q p p
    end subuniverse

    section homomorphism
      parameters {Î±: Type u} {Î³: Type v}
      def homomorphic {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸ â†’ ğ”¹) := âˆ€ f a, h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
      def homomorphic_verbose {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸.fst â†’ ğ”¹.fst) := âˆ€ (f: Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸.fst), h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
    end homomorphism

    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b

    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ} (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): set ğ”¸ :=  Î» (a: ğ”¸), g a = h a 

    -- BEGIN
    -- 0. The composition of homs is a hom.
    lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ}
    (g: ğ”¸ â†’ ğ”¹) (h: ğ”¹ â†’ â„‚) (hg: hom g) (hh: hom h): hom (h âˆ˜ g) :=
    assume f a, 
    show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
      have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
      calc
        (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                   ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)
    -- END
    end basic_facts
  end ualib

(As with the other numbered results appearing in this section, we include the statement and proof of the above fact inside the ``basic_facts`` section.)

Next we formally prove that the equalizer ``ğ–¤ g h`` of two homomorphisms ``g`` and ``h`` is a subuniverse of ğ”¸ (cf. :numref:`Obs %s <obs-one>`).

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
  
    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„± 
      definition Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}

      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)

      lemma Y_is_Sub {ğ”¸: algebra Ïƒ}(X: set ğ”¸): Sub (Y X):= assume f a (h: âˆ€ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
      have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), Y.var x h,
      have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
      have inc_r: Y X âŠ† Sg X, from
        assume a (h: a âˆˆ Y X), have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from
        Y.rec
          (assume x (hrâ‚: x âˆˆ X), show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚)
          (assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X), show ğ”¸.snd f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ ),
          hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): Sub U â†’ X âŠ† U â†’ Y X âŠ† U:= assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U), assume (y: ğ”¸)  (p: Y X y), have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), hâ‚‚ h )
          ( assume f a (hâ‚ƒ: âˆ€ i, Y X (a i)) (hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i)) (hâ‚…: Y X (ğ”¸.snd f a)), have hâ‚†: âˆ€ i, a i âˆˆ U, from
            assume i, hâ‚„ i (hâ‚ƒ i), hâ‚ f a hâ‚† ), q p p
    end subuniverse

    section homomorphism
      parameters {Î±: Type u} {Î³: Type v}
      def homomorphic {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸ â†’ ğ”¹) := âˆ€ f a, h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
      def homomorphic_verbose {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸.fst â†’ ğ”¹.fst) := âˆ€ (f: Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸.fst), h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
    end homomorphism

    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b

    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ} (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): set ğ”¸ :=  Î» (a: ğ”¸), g a = h a 

      lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ}(g: ğ”¸ â†’ ğ”¹) (h: ğ”¹ â†’ â„‚) (hg: hom g) (hh: hom h): hom (h âˆ˜ g) :=
    assume f a, show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
      have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
      calc
        (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                   ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)
    -- BEGIN
    -- 1. The equalizer of homs is a subuniverse.
    lemma Sub_E_homs {ğ”¸ ğ”¹: algebra Ïƒ}
    (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): 
    Sub (E_homs h g hh hg) := 
    assume f a (hâ‚: âˆ€ x, a x âˆˆ (E_homs h g hh hg)),
    show ğ”¸ f a âˆˆ (E_homs h g hh hg),  from 
      have hâ‚‚: h âˆ˜ a = g âˆ˜ a, from funext hâ‚, 
      show h (ğ”¸ f a) = g (ğ”¸ f a), from 
        calc
          h (ğ”¸ f a) = ğ”¹ f (h âˆ˜ a) : hh f a
                ... = ğ”¹ f (g âˆ˜ a) : congr_arg (ğ”¹ f) hâ‚‚
                ... = g (ğ”¸ f a)   : eq.symm (hg f a)
    -- END
    end basic_facts
  end ualib
  
Recall (:numref:`Obs %s <obs-two>`) if two homomorphisms agree on a generating set, then they are equal.

More precisely, if a subset ``X`` is contained in the equalizer of two homomorphisms, then ``Sg X`` is also contained in the equalizer; thus, homomorphisms that agree on ``X`` also agree on ``Sg X``. Let us now state and prove this in Lean.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
  
    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„± 
      definition Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}

      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)

      lemma Y_is_Sub {ğ”¸: algebra Ïƒ}(X: set ğ”¸): Sub (Y X):= assume f a (h: âˆ€ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
      have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), Y.var x h,
      have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
      have inc_r: Y X âŠ† Sg X, from
        assume a (h: a âˆˆ Y X), have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from
        Y.rec
          (assume x (hrâ‚: x âˆˆ X), show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚)
          (assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X), show ğ”¸.snd f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ ),
          hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): Sub U â†’ X âŠ† U â†’ Y X âŠ† U:= assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U), assume (y: ğ”¸)  (p: Y X y), have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), hâ‚‚ h )
          ( assume f a (hâ‚ƒ: âˆ€ i, Y X (a i)) (hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i)) (hâ‚…: Y X (ğ”¸.snd f a)), have hâ‚†: âˆ€ i, a i âˆˆ U, from
            assume i, hâ‚„ i (hâ‚ƒ i), hâ‚ f a hâ‚† ), q p p
    end subuniverse

    section homomorphism
      parameters {Î±: Type u} {Î³: Type v}
      def homomorphic {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸ â†’ ğ”¹) := âˆ€ f a, h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
      def homomorphic_verbose {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸.fst â†’ ğ”¹.fst) := âˆ€ (f: Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸.fst), h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
    end homomorphism

    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b

    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ} (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): set ğ”¸ :=  Î» (a: ğ”¸), g a = h a 

      lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹) (hâ‚: hom g) (h: ğ”¹ â†’ â„‚) (hâ‚‚: hom h): hom (h âˆ˜ g) :=
      assume f a, show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
        have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
        calc
          (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                     ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)

      lemma Sub_E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): Sub (E_homs g h hg hh) := 
      assume f a (hâ‚: âˆ€ x, a x âˆˆ (E_homs g h hg hh)),
      show ğ”¸ f a âˆˆ (E_homs g h hg hh),  from 
        have hâ‚‚: g âˆ˜ a = h âˆ˜ a, from funext hâ‚, 
        show g (ğ”¸ f a) = h (ğ”¸ f a), from 
          calc
            g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a) : hg f a
                  ... = ğ”¹ f (h âˆ˜ a) : congr_arg (ğ”¹ f) hâ‚‚
                  ... = h (ğ”¸ f a)   : eq.symm (hh f a)

    -- BEGIN
    -- 2. If X âŠ† ğ”¸, g and h are homs, and X âŠ† E g h,
    --    then Sg X âŠ† X.
    lemma hom_determined_on_gens {ğ”¸ ğ”¹: algebra Ïƒ}
    (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h) (X: set ğ”¸) : 
    X âŠ† E g h â†’ Sg X âŠ† E g h := 
    -- Idea of the proof: we have
    --     1. X âŠ† E h g,
    --     2. Sub (E h g), i.e., E h g is a subalgebra
    --     3. and Sg X is the smallest subalgebra containing X
    -- Therefore, Sg X âŠ† E h g, which means h = g on Sg X.
    assume hâ‚: X âŠ† E g h, show Sg X âŠ† E g h, from 
      have hâ‚ƒ: Sub (E g h), from 
        (Sub_E_homs g h hg hh),
      sInter_mem (E g h) hâ‚ƒ hâ‚
    -- END
    end basic_facts
  end ualib
  
Alternatively, we could have proved the last fact using the inductive nature of the definition of subalgebra generated by a set.

Indeed, recall the definition of ``Y`` above and the proof that ``Y X`` is equal to ``Sg X``; thus, properties of the subuniverse generated by the set ``X`` can be proved using the recursor of ``Y``.

::

  import data.set
  universes u v w
  namespace ualib
    definition op (Î³: Type w) (Î±: Type u) := (Î³ â†’ Î±) â†’ Î±
    structure signature := mk :: (â„±: Type v) (Ï: â„±  â†’ Type u)
  
    section algebra
      parameter Ïƒ: signature
      def algebra_on (Î±: Type u) := Î  f, op (Ïƒ.Ï f) Î±
      def algebra := sigma algebra_on
      instance alg_carrier : has_coe_to_sort algebra := âŸ¨_, sigma.fstâŸ©
      instance alg_operations : has_coe_to_fun algebra := âŸ¨_, sigma.sndâŸ©
    end algebra

    section subuniverse
      parameters {Î±: Type u} {Î³: Type w} {Ïƒ: signature}
      definition F := Ïƒ.â„± 
      definition Ï := Ïƒ.Ï 
      def Sub {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸): Prop:= âˆ€ (f: F) (a: Ï f â†’ ğ”¸), (âˆ€ x, a x âˆˆ Bâ‚€) â†’ (ğ”¸.snd f a) âˆˆ Bâ‚€
      def is_subalgebra {ğ”¸: algebra Ïƒ}(Bâ‚€: set ğ”¸) (ğ”¹: algebra_on Ïƒ Bâ‚€): Prop:= âˆ€ f b, â†‘(ğ”¹ f b) = ğ”¸.snd f â†‘b
      def Sg {ğ”¸: algebra Ïƒ}(X: set ğ”¸): set ğ”¸:= â‹‚â‚€ {U | Sub U âˆ§ X âŠ† U}

      theorem Inter.intro {ğ”¸: algebra Ïƒ} {x: ğ”¸} {s: Î³ â†’ set ğ”¸}: (âˆ€ i, x âˆˆ s i) â†’ (x âˆˆ â‹‚ i, s i) := assume h, iff.elim_right set.mem_Inter h

      theorem Inter.elim {ğ”¸: algebra Ïƒ} {x: ğ”¸} {C: Î³ â†’ set ğ”¸}: (x âˆˆ â‹‚ i, C i) â†’  (âˆ€ i, x âˆˆ C i):= assume h, iff.elim_left set.mem_Inter h

      lemma sub_of_sub_inter_sub {ğ”¸: algebra Ïƒ} (C: Î³ â†’ set ğ”¸): (âˆ€ i, Sub (C i)) â†’ Sub (â‹‚i, C i):= assume h: (âˆ€ i, Sub (C i)), show Sub (â‹‚i, C i), from
        assume (f: Ïƒ.â„±) (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚: âˆ€ x, a x âˆˆ â‹‚i, C i),
        Inter.intro (Î» j, (h j) f a (Î» x, Inter.elim (hâ‚ x) j))

      lemma subset_X_of_SgX {ğ”¸: algebra Ïƒ} (X : set ğ”¸): X âŠ† Sg X:= assume x (h: x âˆˆ X), 
      assume W (hâ‚: W âˆˆ {U | Sub U âˆ§ X âŠ† U}), have hâ‚‚: Sub W âˆ§ X âŠ† W, from hâ‚, hâ‚‚.right h

      lemma sInter_mem {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R â†’ X âŠ† R â†’ (Sg X âŠ† R) := 
      assume R (hâ‚: Sub R) (hâ‚‚: X âŠ† R), assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ R, Sub R âˆ§ X âŠ† R â†’ (Sg X âŠ† R):= 
      assume R (hc : Sub R âˆ§ X âŠ† R), have hâ‚: Sub R, from hc.left,
      have hâ‚‚: X âŠ† R, from hc.right, assume x (h: x âˆˆ Sg X), h R (and.intro hâ‚ hâ‚‚)

      lemma sInter_mem'' {ğ”¸: algebra Ïƒ} {X: set ğ”¸}: âˆ€ x, x âˆˆ Sg X â†’ âˆ€ R, Sub R â†’ X âŠ† R â†’ x âˆˆ R:= assume x (hâ‚: x âˆˆ Sg X), assume (R: set ğ”¸) (hâ‚‚: Sub R) (hâ‚ƒ: X âŠ† R), hâ‚ R (and.intro hâ‚‚ hâ‚ƒ)

      lemma SgX_is_Sub {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sub (Sg X):= assume f (a: Ïƒ.Ï f â†’ ğ”¸) (hâ‚€: âˆ€ i, a i âˆˆ Sg X), assume W (h: Sub W âˆ§ X âŠ† W), have hâ‚: Sg X âŠ† W, from sInter_mem' W h,
      have h': âˆ€ i, a i âˆˆ W, from assume i, hâ‚ (hâ‚€ i), (h.left f a h')

      inductive Y {ğ”¸: algebra Ïƒ} (X: set ğ”¸): set ğ”¸
      | var (x : ğ”¸) : x âˆˆ X â†’ Y x
      | app (f : Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸) : (âˆ€ i, Y (a i)) â†’ Y (ğ”¸.snd f a)

      lemma Y_is_Sub {ğ”¸: algebra Ïƒ}(X: set ğ”¸): Sub (Y X):= assume f a (h: âˆ€ i, Y X (a i)),Y.app f a h 

      theorem sg_inductive {ğ”¸: algebra Ïƒ} (X: set ğ”¸): Sg X = Y X :=
      have hâ‚€: X âŠ† Y X, from assume x (h: x âˆˆ X), Y.var x h,
      have hâ‚: Sub (Y X), from assume f a (h : âˆ€ x, Y X (a x)), Y.app f a h,
      have inc_l: Sg X âŠ† Y X, from sInter_mem (Y X) hâ‚ hâ‚€, 
      have inc_r: Y X âŠ† Sg X, from
        assume a (h: a âˆˆ Y X), have hâ‚‚: a âˆˆ Y X â†’ a âˆˆ Sg X, from
        Y.rec
          (assume x (hrâ‚: x âˆˆ X), show x âˆˆ Sg X, from subset_X_of_SgX X hrâ‚)
          (assume f b (hrâ‚‚: âˆ€ i, b i âˆˆ Y X) (hrâ‚ƒ: âˆ€ i, b i âˆˆ Sg X), show ğ”¸.snd f b âˆˆ Sg X, from SgX_is_Sub X f b hrâ‚ƒ ),
          hâ‚‚ h,
        set.subset.antisymm inc_l inc_r

      lemma Y_is_min_Sub {ğ”¸: algebra Ïƒ} (U X: set ğ”¸): Sub U â†’ X âŠ† U â†’ Y X âŠ† U:= assume (hâ‚: Sub U) (hâ‚‚ : X âŠ† U), assume (y: ğ”¸)  (p: Y X y), have q: Y X y â†’ Y X y â†’ U y, from 
        Y.rec
          ( assume y (h: X y) (h': Y X y), hâ‚‚ h )
          ( assume f a (hâ‚ƒ: âˆ€ i, Y X (a i)) (hâ‚„: âˆ€ i, Y X (a i) â†’ U (a i)) (hâ‚…: Y X (ğ”¸.snd f a)), have hâ‚†: âˆ€ i, a i âˆˆ U, from
            assume i, hâ‚„ i (hâ‚ƒ i), hâ‚ f a hâ‚† ), q p p
    end subuniverse

    section homomorphism
      parameters {Î±: Type u} {Î³: Type v}
      def homomorphic {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸ â†’ ğ”¹) := âˆ€ f a, h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
      def homomorphic_verbose {Ïƒ: signature} {ğ”¸ ğ”¹: algebra Ïƒ} (h: ğ”¸.fst â†’ ğ”¹.fst) := âˆ€ (f: Ïƒ.â„±) (a : Ïƒ.Ï f â†’ ğ”¸.fst), h (ğ”¸.snd f a) = ğ”¹.snd f (h âˆ˜ a)
    end homomorphism

    def ker {Î± Î²: Type u} (f: Î± â†’ Î²): Î± â†’ Î± â†’ Prop := Î» a b, f a = f b

    section basic_facts
      parameter {Ïƒ: signature}
      def E {Î± Î²: Type u} (f g: Î± â†’ Î²): set Î± := Î» (x: Î±), f x = g x 
      def hom {ğ”¸ ğ”¹: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹): Prop := âˆ€ f a, g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a)
      def E_homs {ğ”¸ ğ”¹: algebra Ïƒ} (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): set ğ”¸ :=  Î» (a: ğ”¸), g a = h a 

      lemma hom_comp_of_hom {ğ”¸ ğ”¹ â„‚: algebra Ïƒ} (g: ğ”¸ â†’ ğ”¹) (hâ‚: hom g) (h: ğ”¹ â†’ â„‚) (hâ‚‚: hom h): hom (h âˆ˜ g) :=
      assume f a, show (h âˆ˜ g)(ğ”¸ f a) = â„‚ f (h âˆ˜ g âˆ˜ a), from 
        have hâ‚ƒ: (h âˆ˜ g)(ğ”¸ f a) = h (g (ğ”¸ f a)), from  rfl,
        calc
          (h âˆ˜ g)(ğ”¸ f a) = h ((ğ”¹ f) (g âˆ˜ a)) : (hâ‚ f a) â–¸ hâ‚ƒ 
                     ... = (â„‚ f) (h âˆ˜ g âˆ˜ a)  : hâ‚‚ f (g âˆ˜ a)

      lemma Sub_E_homs {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h): Sub (E_homs g h hg hh) := 
      assume f a (hâ‚: âˆ€ x, a x âˆˆ (E_homs g h hg hh)),
      show ğ”¸ f a âˆˆ (E_homs g h hg hh),  from 
        have hâ‚‚: g âˆ˜ a = h âˆ˜ a, from funext hâ‚, 
        show g (ğ”¸ f a) = h (ğ”¸ f a), from 
          calc
            g (ğ”¸ f a) = ğ”¹ f (g âˆ˜ a) : hg f a
                  ... = ğ”¹ f (h âˆ˜ a) : congr_arg (ğ”¹ f) hâ‚‚
                  ... = h (ğ”¸ f a)   : eq.symm (hh f a)

      lemma hom_determined_on_gens {ğ”¸ ğ”¹: algebra Ïƒ}(g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h) (X: set ğ”¸): X âŠ† E g h â†’ Sg X âŠ† E g h :=
      assume hâ‚: X âŠ† E g h, show Sg X âŠ† E g h, from
        have hâ‚ƒ: Sub (E g h), from (Sub_E_homs g h hg hh),
        sInter_mem (E g h) hâ‚ƒ hâ‚
    
    -- BEGIN
    -- 2. If X âŠ† ğ”¸, g and h are homs, and X âŠ† E g h,
    --    then Sg X âŠ† X.
    lemma hom_determined_on_gens_rec {ğ”¸ ğ”¹: algebra Ïƒ}
    (g h: ğ”¸ â†’ ğ”¹) (hg: hom g) (hh: hom h) (X: set ğ”¸): 
    X âŠ† E g h â†’ Sg X âŠ† E g h := 
    assume (hâ‚€: X âŠ† E g h) (a: ğ”¸) (hâ‚: a âˆˆ Sg X),
    show g a = h a, from
      have hâ‚‚: a âˆˆ Y X, from eq.subst (sg_inductive X) hâ‚,
      have hâ‚ƒ: âˆ€ x, x âˆˆ X â†’ g x = h x, from
        assume x (h': x âˆˆ X), hâ‚€ h',
      show g a = h a, from 
        Y.rec
          --base step: assume a âˆˆ X
          hâ‚ƒ
          --inductive step:
          -- assume a = ğ”¸ f b for some b with âˆ€ i, b i âˆˆ Sg X
          (
            assume f b (hâ‚„ : âˆ€ i, b i âˆˆ Y X),
            assume hâ‚… : âˆ€ i, g (b i) = h (b i),
            show g (ğ”¸ f b) = h (ğ”¸ f b), from 
              have hâ‚† : g âˆ˜ b = h âˆ˜ b, from funext hâ‚…, 
              calc
                g (ğ”¸ f b) = (ğ”¹ f) (g âˆ˜ b): hg f b
                      ... = (ğ”¹ f) (h âˆ˜ b): congr_arg (ğ”¹ f) hâ‚†    
                      ... = h (ğ”¸ f b)    : eq.symm (hh f b)
          ) hâ‚‚ 
    -- END
    end basic_facts
  end ualib

Before implementing :numref:`Obs %s <obs-four>` in Lean, we reiterate that we cannot do so constructively.  Here is a related passage from `Theorem Proving in Lean`_ that explains why.

  "The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces 'data' from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions as noncomputable to flag that fact... To summarize, then, on top of the underlying framework of universes, dependent function types, and inductive types, the standard library adds three additional components:

  #. the axiom of propositional extensionality
  #. a quotient construction, which implies function extensionality
  #. a choice principle, which produces data from an existential proposition.

  The first two of these block normalization within Lean, but are compatible with bytecode evaluation, whereas the third is not amenable to computational interpretation."
   
The upshot is that we cannot always use Lean's ``exists.elim`` to produce data.

.. todo:: insert Lean proof here

To see that :math:`k` is a homomorphism, assume there are :math:`m` operation symbols. Fix arbitrary :math:`0â‰¤ i< m` and :math:`b: \underline{k_i} â†’ B`.
   
Since :math:`g` is surjective, for each :math:`i: \underline{k_i}`, the subset :math:`g^{-1}\{b(i)\}âŠ† A` is nonempty and is mapped by :math:`h` to a single point of :math:`C` (since :math:`\ker g âŠ† \ker h`.


-------------------------

.. rubric:: Footnotes

.. [1]
   As of this writing (9 June 2019), this documentation describes code residing on the william_ branch of the lean-ualib_ repository. Eventually, the latest code will reside on the master_ branch and the docs will describe the code on that branch.
   
.. include:: hyperlink_references.rst
