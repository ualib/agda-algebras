<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Terms.Basic</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Background">---
layout: default
title : Terms.Basic module (The Agda Universal Algebra Library)
date : 2021-01-14
author: [the agda-algebras development team][]
---

### &lt;a id=&quot;basic-definitions&quot;&gt;Basic Definitions&lt;/a&gt;

This is the [Terms.Basic][] module of the [Agda Universal Algebra Library][].

</a><a id="287" class="Markup">\begin{code}</a>

<a id="301" class="Symbol">{-#</a> <a id="305" class="Keyword">OPTIONS</a> <a id="313" class="Pragma">--without-K</a> <a id="325" class="Pragma">--exact-split</a> <a id="339" class="Pragma">--safe</a> <a id="346" class="Symbol">#-}</a>

<a id="351" class="Keyword">open</a> <a id="356" class="Keyword">import</a> <a id="363" href="Algebras.Basic.html" class="Module">Algebras.Basic</a>

<a id="379" class="Keyword">module</a> <a id="386" href="Terms.Basic.html" class="Module">Terms.Basic</a> <a id="398" class="Symbol">{</a><a id="399" href="Terms.Basic.html#399" class="Bound">ğ‘†</a> <a id="401" class="Symbol">:</a> <a id="403" href="Algebras.Basic.html#3576" class="Function">Signature</a> <a id="413" href="Algebras.Basic.html#1210" class="Generalizable">ğ“</a> <a id="415" href="Algebras.Basic.html#1212" class="Generalizable">ğ“¥</a><a id="416" class="Symbol">}</a> <a id="418" class="Keyword">where</a>

<a id="425" class="Keyword">open</a> <a id="430" class="Keyword">import</a> <a id="437" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>            <a id="463" class="Keyword">using</a>    <a id="472" class="Symbol">(</a> <a id="474" href="Agda.Primitive.html#597" class="Postulate">Level</a> <a id="480" class="Symbol">)</a>
                                      <a id="520" class="Keyword">renaming</a> <a id="529" class="Symbol">(</a> <a id="531" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="535" class="Symbol">to</a> <a id="538" class="Primitive">Type</a> <a id="543" class="Symbol">)</a>
<a id="545" class="Keyword">open</a> <a id="550" class="Keyword">import</a> <a id="557" href="Data.Product.html" class="Module">Data.Product</a>              <a id="583" class="Keyword">using</a>    <a id="592" class="Symbol">(</a> <a id="594" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="598" class="Symbol">)</a>
<a id="600" class="Keyword">open</a> <a id="605" class="Keyword">import</a> <a id="612" href="Overture.Preliminaries.html" class="Module">Overture.Preliminaries</a>    <a id="638" class="Keyword">using</a>    <a id="647" class="Symbol">(</a> <a id="649" href="Overture.Preliminaries.html#4144" class="Function Operator">âˆ£_âˆ£</a> <a id="653" class="Symbol">;</a> <a id="655" href="Overture.Preliminaries.html#4182" class="Function Operator">âˆ¥_âˆ¥</a> <a id="659" class="Symbol">)</a>
<a id="661" class="Keyword">open</a> <a id="666" class="Keyword">import</a> <a id="673" href="Algebras.Products.html" class="Module">Algebras.Products</a>    <a id="694" class="Symbol">{</a><a id="695" class="Argument">ğ‘†</a> <a id="697" class="Symbol">=</a> <a id="699" href="Terms.Basic.html#399" class="Bound">ğ‘†</a><a id="700" class="Symbol">}</a> <a id="702" class="Keyword">using</a>    <a id="711" class="Symbol">(</a> <a id="713" href="Algebras.Products.html#2952" class="Function">ov</a> <a id="716" class="Symbol">)</a>

<a id="719" class="Keyword">private</a> <a id="727" class="Keyword">variable</a> <a id="736" href="Terms.Basic.html#736" class="Generalizable">Ï‡</a> <a id="738" class="Symbol">:</a> <a id="740" href="Agda.Primitive.html#597" class="Postulate">Level</a>

<a id="747" class="Markup">\end{code}</a><a id="757" class="Background">

#### The type of terms

Fix a signature `ğ‘†` and let `X` denote an arbitrary nonempty collection of variable symbols. Assume the symbols in `X` are distinct from the operation symbols of `ğ‘†`, that is `X âˆ© âˆ£ ğ‘† âˆ£ = âˆ…`.

By a *word* in the language of `ğ‘†`, we mean a nonempty, finite sequence of members of `X âˆª âˆ£ ğ‘† âˆ£`. We denote the concatenation of such sequences by simple juxtaposition.

Let `Sâ‚€` denote the set of nullary operation symbols of `ğ‘†`. We define by induction on `n` the sets `ğ‘‡â‚™` of *words* over `X âˆª âˆ£ ğ‘† âˆ£` as follows (cf. [Bergman (2012)][] Def. 4.19):

`ğ‘‡â‚€ := X âˆª Sâ‚€` and `ğ‘‡â‚™â‚Šâ‚ := ğ‘‡â‚™ âˆª ğ’¯â‚™`

where `ğ’¯â‚™` is the collection of all `ğ‘“ ğ‘¡` such that `ğ‘“ : âˆ£ ğ‘† âˆ£` and `ğ‘¡ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ ğ‘‡â‚™`. (Recall, `âˆ¥ ğ‘† âˆ¥ ğ‘“` is the arity of the operation symbol ğ‘“.)

We define the collection of *terms* in the signature `ğ‘†` over `X` by `Term X := â‹ƒâ‚™ ğ‘‡â‚™`. By an ğ‘†-*term* we mean a term in the language of `ğ‘†`.

The definition of `Term X` is recursive, indicating that an inductive type could be used to represent the semantic notion of terms in type theory. Indeed, such a representation is given by the following inductive type.

</a><a id="1878" class="Markup">\begin{code}</a>

<a id="1892" class="Keyword">data</a> <a id="Term"></a><a id="1897" href="Terms.Basic.html#1897" class="Datatype">Term</a> <a id="1902" class="Symbol">(</a><a id="1903" href="Terms.Basic.html#1903" class="Bound">X</a> <a id="1905" class="Symbol">:</a> <a id="1907" href="Terms.Basic.html#538" class="Primitive">Type</a> <a id="1912" href="Terms.Basic.html#736" class="Generalizable">Ï‡</a> <a id="1914" class="Symbol">)</a> <a id="1916" class="Symbol">:</a> <a id="1918" href="Terms.Basic.html#538" class="Primitive">Type</a> <a id="1923" class="Symbol">(</a><a id="1924" href="Algebras.Products.html#2952" class="Function">ov</a> <a id="1927" href="Terms.Basic.html#1912" class="Bound">Ï‡</a><a id="1928" class="Symbol">)</a>  <a id="1931" class="Keyword">where</a>
 <a id="Term.â„Š"></a><a id="1938" href="Terms.Basic.html#1938" class="InductiveConstructor">â„Š</a> <a id="1940" class="Symbol">:</a> <a id="1942" href="Terms.Basic.html#1903" class="Bound">X</a> <a id="1944" class="Symbol">â†’</a> <a id="1946" href="Terms.Basic.html#1897" class="Datatype">Term</a> <a id="1951" href="Terms.Basic.html#1903" class="Bound">X</a>    <a id="1956" class="Comment">-- (â„Š for &quot;generator&quot;)</a>
 <a id="Term.node"></a><a id="1980" href="Terms.Basic.html#1980" class="InductiveConstructor">node</a> <a id="1985" class="Symbol">:</a> <a id="1987" class="Symbol">(</a><a id="1988" href="Terms.Basic.html#1988" class="Bound">f</a> <a id="1990" class="Symbol">:</a> <a id="1992" href="Overture.Preliminaries.html#4144" class="Function Operator">âˆ£</a> <a id="1994" href="Terms.Basic.html#399" class="Bound">ğ‘†</a> <a id="1996" href="Overture.Preliminaries.html#4144" class="Function Operator">âˆ£</a><a id="1997" class="Symbol">)(</a><a id="1999" href="Terms.Basic.html#1999" class="Bound">t</a> <a id="2001" class="Symbol">:</a> <a id="2003" href="Overture.Preliminaries.html#4182" class="Function Operator">âˆ¥</a> <a id="2005" href="Terms.Basic.html#399" class="Bound">ğ‘†</a> <a id="2007" href="Overture.Preliminaries.html#4182" class="Function Operator">âˆ¥</a> <a id="2009" href="Terms.Basic.html#1988" class="Bound">f</a> <a id="2011" class="Symbol">â†’</a> <a id="2013" href="Terms.Basic.html#1897" class="Datatype">Term</a> <a id="2018" href="Terms.Basic.html#1903" class="Bound">X</a><a id="2019" class="Symbol">)</a> <a id="2021" class="Symbol">â†’</a> <a id="2023" href="Terms.Basic.html#1897" class="Datatype">Term</a> <a id="2028" href="Terms.Basic.html#1903" class="Bound">X</a>

<a id="2031" class="Markup">\end{code}</a><a id="2041" class="Background">

This is a very basic inductive type that represents each term as a tree with an operation symbol at each `node` and a variable symbol at each leaf (`generator`).

**Notation**. As usual, the type `X` represents an arbitrary collection of variable symbols. Recall, `ov Ï‡` is our shorthand notation for the universe level `ğ“ âŠ” ğ“¥ âŠ” lsuc Ï‡`.



#### The term algebra

For a given signature `ğ‘†`, if the type `Term X` is nonempty (equivalently, if `X` or `âˆ£ ğ‘† âˆ£` is nonempty), then we can define an algebraic structure, denoted by `ğ‘» X` and called the *term algebra in the signature* `ğ‘†` *over* `X`.  Terms are viewed as acting on other terms, so both the domain and basic operations of the algebra are the terms themselves.


+ For each operation symbol `ğ‘“ : âˆ£ ğ‘† âˆ£`, denote by `ğ‘“ Ì‚ (ğ‘» X)` the operation on `Term X` that maps a tuple `ğ‘¡ : âˆ¥ ğ‘† âˆ¥ ğ‘“ â†’ âˆ£ ğ‘» X âˆ£` to the formal term `ğ‘“ ğ‘¡`.
+ Define `ğ‘» X` to be the algebra with universe `âˆ£ ğ‘» X âˆ£ := Term X` and operations `ğ‘“ Ì‚ (ğ‘» X)`, one for each symbol `ğ‘“` in `âˆ£ ğ‘† âˆ£`.

In [Agda][] the term algebra can be defined as simply as one could hope.

</a><a id="3127" class="Markup">\begin{code}</a>

<a id="ğ‘»"></a><a id="3141" href="Terms.Basic.html#3141" class="Function">ğ‘»</a> <a id="3143" class="Symbol">:</a> <a id="3145" class="Symbol">(</a><a id="3146" href="Terms.Basic.html#3146" class="Bound">X</a> <a id="3148" class="Symbol">:</a> <a id="3150" href="Terms.Basic.html#538" class="Primitive">Type</a> <a id="3155" href="Terms.Basic.html#736" class="Generalizable">Ï‡</a> <a id="3157" class="Symbol">)</a> <a id="3159" class="Symbol">â†’</a> <a id="3161" href="Algebras.Basic.html#6389" class="Function">Algebra</a> <a id="3169" class="Symbol">(</a><a id="3170" href="Algebras.Products.html#2952" class="Function">ov</a> <a id="3173" href="Terms.Basic.html#736" class="Generalizable">Ï‡</a><a id="3174" class="Symbol">)</a> <a id="3176" href="Terms.Basic.html#399" class="Bound">ğ‘†</a>
<a id="3178" href="Terms.Basic.html#3141" class="Function">ğ‘»</a> <a id="3180" href="Terms.Basic.html#3180" class="Bound">X</a> <a id="3182" class="Symbol">=</a> <a id="3184" href="Terms.Basic.html#1897" class="Datatype">Term</a> <a id="3189" href="Terms.Basic.html#3180" class="Bound">X</a> <a id="3191" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3193" href="Terms.Basic.html#1980" class="InductiveConstructor">node</a>

<a id="3199" class="Markup">\end{code}</a><a id="3209" class="Background">


------------------------------

[the agda-algebras development team]: https://github.com/ualib/agda-algebras#the-agda-algebras-development-team

</a></pre></body></html>