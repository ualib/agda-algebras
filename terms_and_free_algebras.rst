===============================
Terms and Free Algebras in Lean
===============================

Most of the Lean code described in this section can be found in the file at https://github.com/UniversalAlgebra/lean-ualib/blob/master/src/free.lean .
Most of the Lean code described in this section can be found in the files ``free.lean`` which reside in the ``src`` directory of the lean-ualib_ repository.

.. _inductively-defined-type:

Inductively defined types
-------------------------

A primary motivation for this project was our observation that, on the one hand, many important constructs in universal algebra can be defined inductively, and on the other hand, type theory in general, and Lean in particular, offers excellent support for defining inductive types and powerful tactics for proving their properties.

These two facts suggest that there should be much to gain from implementing universal algebra in an expressive type system that offers powerful tools for proving theorems about inductively defined types.

.. index:: subuniverse generated by a set

As such, we are pleased to present the following inductive type that implements the **subuniverse generated by a set**; cf. the definition :eq:`subalgebra-inductive` given in the informal language.

.. code-block:: lean

    inductive Y (X : set Î±) : set Î±
    | var (x : Î±) : x âˆˆ X â†’ Y x
    | app (f : F) (a : Ï f â†’ Î±) : (âˆ€ i, Y (a i)) â†’ Y (A f a)
  
Next we prove that the type ``Y X`` defines a subuniverse, and that it is, in fact, equal to :math:`\mathrm{Sg}^ğ€(X)`.

.. code-block:: lean

    -- Y X is a subuniverse
    lemma Y_is_Sub (X : set Î±) : Sub (Y X) := 
    assume f a (h: âˆ€ i, Y X (a i)), show Y X (A f a), from 
    Y.app f a h 
   
    -- Y X is the subuniverse generated by X
    theorem sg_inductive (X : set Î±) : Sg X = Y X :=
    have hâ‚€ : X âŠ† Y X, from 
      assume x (h : x âˆˆ X), 
      show x âˆˆ Y X, from Y.var x h,
    have hâ‚ : Sub (Y X), from 
      assume f a (h : âˆ€ x, Y X (a x)), 
      show Y X (A f a), from Y.app f a h,
    have inc_l : Sg X âŠ† Y X, from 
       assume u (h : u âˆˆ Sg X), 
       show u âˆˆ Y X, from (sInter_mem u) h hâ‚ hâ‚€,
    have inc_r : Y X âŠ† Sg X, from
       assume a (h: a âˆˆ Y X), show a âˆˆ Sg X, from
         have h' : a âˆˆ Y X â†’ a âˆˆ Sg X, from 
           Y.rec
           --base: a = x âˆˆ X
           ( assume x (h1 : x âˆˆ X), 
             show x âˆˆ Sg X, from subset_X_of_SgX X h1 )
           --inductive: a = A f b for some b with âˆ€ i, b i âˆˆ Sg X
           ( assume f b (h2 : âˆ€ i, b i âˆˆ Y X) (h3 : âˆ€ i, b i âˆˆ Sg X),
             show A f b âˆˆ Sg X, from SgX_is_Sub X f b h3 ),
         h' h,
    subset.antisymm inc_l inc_r

Observe that the last proof proceeds exactly as would a typical informal proof that two sets are equal---prove two subset inclusions and then apply the ``subset.antisymm`` rule, :math:`A âŠ† B â†’ B âŠ† A â†’ A = B`.

.. index:: recursor

We proved ``Y X âŠ† Sg X`` in this case by induction using the **recursor**, ``Y.rec``, which Lean creates for us automatically whenever an inductive type is defined.

The Lean keyword ``assume`` is syntactic sugar for ``Î»``; this and other notational conveniences, such as Lean's ``have...from`` and ``show...from`` syntax, make it possible to render formal proofs in a very clear and readable way.

----------------------------------------------

.. index:: variables, word, term, free algebra

.. _terms-and-free-algebras:

Terms and free algebras
-----------------------

Fix a signature :math:`Ïƒ = (F, Ï)`, let :math:`X` be a set of **variables** and assume :math:`X âˆ© F = âˆ…`.

For every :math:`n < Ï‰`, let  :math:`F_n = Ï^{-1} \{n\}` be the set of :math:`ğ—‡`-ary operation symbols.

By a **word** on :math:`X âˆª F` we mean a nonempty, finite sequence of members of :math:`X âˆª T`.

We denote the concatenation of sequences by simple juxtaposition. We define, by recursion on :math:`n`, the sets :math:`T_n` of words on :math:`X âˆª F` by

.. math::      T_0 &= X âˆª F_0;\\
           T_{n+1} &= T_n âˆª \{ f s âˆ£ f âˆˆ  F, \ s : Ïf â†’ T_n \}. 

Define the set of **terms in the signature** Ïƒ **over** :math:`X` by :math:`T_Ï(X) = â‹ƒ_{n < Ï‰}T_n`.

The definition of :math:`T_Ï (X)` is recursive, indicating that *the set of terms in a signature can be implemented in Lean using an inductive type*.

We will confirm this in the next subsection, but before doing so, we impose an algebraic structure on :math:`T_Ï(X)`, and then state and prove some basic but important facts about this algebra. These will be formalized in the next section, giving us another chance to compare informal language proofs to their formal Lean counterparts and to show off inductively defined types in Lean.

If :math:`w` is a term, let :math:`|w|` be the least :math:`n` such that :math:`w âˆˆ T_n`, called the *height* of :math:`w`. [1]_ The height is a useful index for recursion and induction.

Notice that the set :math:`T_Ï (X)` is nonempty iff either :math:`X` or :math:`F_0` is nonempty. As long as :math:`T_Ï (X)` is nonempty, we can impose upon this set an algebraic structure, as follows:

For every basic operation symbol :math:`f âˆˆ F` let :math:`f^{ğ“_Ï (X)}` be the operation on :math:`ğ“_Ï (X)` that maps each tuple :math:`ğš : Ïf â†’ T_Ï (X)` to the formal term :math:`f ğš`.

We define :math:`ğ“_Ï (X)` to be the algebra with universe :math:`T_Ï (X)` and with basic operations :math:`\{f^{ğ“_Ï (X)} | f âˆˆ F\}`. [2]_

Indeed, Part (2) of :ref:`Theorem 4.21 <thm-4-21>` below asserts that :math:`ğ“_Ï (X)` is *universal for* \sigma-algebras.

To prove this, we need the following basic lemma, which states that a homomorphism is uniquely determined by its restriction to a generating set. (See also :cite:`Bergman:2012`, Ex. 1.16.6.)

.. _ex_1-16-6-brief:

.. proof:lemma::

   Let :math:`f` and :math:`g` be homomorphisms from ğ€ to ğ. If :math:`X âŠ† A` and :math:`X` generates ğ€ and :math:`f|_X = g|_X`, then :math:`f = g`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      Suppose the subset :math:`X âŠ† A` generates ğ€ and suppose :math:`f|_X = g|_X`. Fix an arbitrary element :math:`a âˆˆ A`.

      We show :math:`f(a) = g(a)`. Since :math:`X` generates ğ€, there exists a (say, :math:`n`-ary) term :math:`t` and a tuple :math:`(x_1, \dots, x_n) âˆˆ X^n` such that :math:`a = t^{ğ€}(x_1, \dots, x_n)`. Therefore,

      .. math:: f(a) = f(t^{ğ€}(x_1, \dots, x_n)) &= t^{ğ}(f(x_1), \dots, f(x_n)) \\
                                    &= t^{ğ}(g(x_1), \dots, g(x_n)) = g(t^{ğ€}(x_1, \dots, x_n)) = g(a).

Here is another useful theorem. (See also :cite:`Bergman:2012`, Thm. 4.21.) 

.. _thm-4-21:

.. proof:theorem::

   Let :math:`Ïƒ = (F, Ï)` be a signature.

   #. :math:`ğ“_Ï (X)` is generated by X.
   #. For every Ïƒ-algebra ğ€ and every function :math:`h : X â†’ A` there is a unique homomorphism :math:`g : ğ“_Ï (X) â†’ ğ€` such that :math:`g|_X = h`.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      The definition of :math:`ğ“_Ï (X)` exactly parallels the construction in :ref:`Theorem 1.14 <thm-1-14>`. That accounts for (1).

      For (2), define :math:`g(t)` by induction on :math:`Ït`. Suppose :math:`Ït = 0`. Then :math:`t âˆˆ X âˆª F`.
      
      If :math:`t âˆˆ X` then define :math:`g(t) = h(t)`. For :math:`t âˆ‰ X`, :math:`g(t) = t^{ğ€}`.
      
      Note that since ğ€ is an \sigma-algebra and ğ— is a nullary operation symbol, :math:`t^{ğ€}` is defined.
    
      For the inductive step, let :math:`|t| = n + 1`. Then :math:`t = f(s_1, \dots, s_k)` for some :math:`f âˆˆ F_k` and :math:`s_1, \dots, s_k` each of height at most :math:`n`.
      
      We define :math:`g(t) = f^{ğ€}(g(s_1), \dots, g(s_k))`.
      
      By its very definition, ğ—€ is a homomorphism.
      
      Finally, the uniqueness of ğ—€ follows from :ref:`Lemma 1.16 <ex_1-16-6-brief>`. 

As a second demonstration of inductive types in Lean, we define a type representing the (infinite) collection :math:`ğ“(X)` of all terms of a given signature.

.. code-block:: lean

    import basic
    section
      parameters {Ïƒ : signature} (X :Type*) 
      local notation `F` := Ïƒ.F
      local notation `Ï` := Ïƒ.Ï 
    
      inductive term
      | var : X â†’ term
      | app (f : F) : (Ï f â†’ term) â†’ term
  
      def Term : algebra S := âŸ¨term, term.appâŸ©
    end

The set of terms along with the operations :math:`F^{ğ“} := \{\mathsf{app} f | f : F\}` forms an algebra :math:`ğ“(X) = âŸ¨T(X), F^{ğ“}âŸ©` in the signature :math:`Ïƒ = (F, Ï)`.

Suppose :math:`ğ€ = âŸ¨A, F^{ğ€}âŸ©` is an algebra in the same signature and :math:`h : X â†’ A` is an arbitrary function.  We will show that :math:`h : X â†’ A` has a unique *extension* (or *lift*) to a homomorphism from :math:`ğ“(X)` to ğ€.

Since ğ€ and :math:`h : X â†’ A` are arbitrary, this unique homomorphic lifting property holds universally; accordingly we say that the term algebra :math:`ğ“(X)` is *universal* for Ïƒ-algebras. Some authors say, ":math:`ğ“(X)` is *absolutely free* for Ïƒ-algebras," in this and only this case.

Before implementing the formal proof of this fact in Lean, let us first define some domain specific syntactic sugar.

.. code-block:: lean

    section
      open term
      parameters {Ïƒ : signature} (X :Type*) {A : algebra Ïƒ}
      definition F := Ïƒ.F         -- operation symbols
      definition Ï := Ïƒ.Ï         -- arity function
      definition ğ•‹ := @Term Ïƒ     -- term algebra over X
      definition ğ• := @var Ïƒ X    -- generators of the term algebra

If :math:`h : X â†’ A` is a function defined on the generators of the term algebra, then the *lift* (or *extension*) of :math:`h` to all of :math:`ğ•‹(X)` is defined inductively as follows:

.. code-block:: lean

    definition lift_of (h : X â†’ A) : ğ•‹(X) â†’ 
    | (var x) := h x
    | (app f a) := (A f) (Î» x, lift_of (a x))

To prove that the term algebra is universal for Ïƒ-algebras, we show that the lift of an arbitrary function :math:`h : X â†’ A` is a homomorphism and that this lift is unique.

.. code-block:: lean

      -- The lift is a homomorphism.
      lemma lift_is_hom (h : X â†’ A) : homomorphic (lift_of h) :=
      Î» f a, show lift_of h (app f a) = A f (lift_of h âˆ˜ a), from rfl
    
      -- The lift is unique.
      lemma lift_is_unique : âˆ€ {h h' : ğ•‹(X) â†’ A},
      homomorphic h â†’ homomorphic h' â†’ h âˆ˜ ğ• = h' âˆ˜ ğ• â†’ h = h' :=
      assume (h h' : ğ•‹(X) â†’ A) (hâ‚ : homomorphic h)
        (hâ‚‚ : homomorphic h')(hâ‚ƒ : h âˆ˜ ğ• = h' âˆ˜ ğ•),
        show h = h', from 
          have hâ‚€ : âˆ€ t : ğ•‹(X), h t = h' t, from 
            assume t : ğ•‹(X), 
            begin
              induction t with t f a ihâ‚ ,
              show h (ğ• t) = h' (ğ• t),
              { apply congr_fun hâ‚ƒ t },
    
              show h (app f a) = h' (app f a),
              { have ihâ‚‚  : h âˆ˜ a = h' âˆ˜ a, from funext ihâ‚,
                calc h (app f a) = A f (h âˆ˜ a) : hâ‚ f a
                             ... = A f (h' âˆ˜ a) : congr_arg (A f) ihâ‚‚ 
                             ... = h' (app f a) : (hâ‚‚ f a).symm }
            end,
          funext hâ‚€ 
    end

Let :math:`ğ€ = âŸ¨A, F^{ğ€}âŸ©` be a \sigma-algebra.

.. with congruence lattice $\Con\<A, \dots \>$.

.. index:: clone

Recall that a **clone** on a nonempty set :math:`A` is a set of operations on :math:`A` that contains the projection operations and is closed under general composition. 

Let :math:`A` denote the set of all clones on :math:`A`.

The **clone of term operations** of an Ïƒ-algebra ğ€, denoted by :math:`\mathrm{Clo} ğ€`, is the smallest clone on :math:`A` containing the basic operations of ğ€, that is,

.. math:: \mathrm{Clo} ğ€ = â‹‚ \{ U âˆˆ ğ–¢ A âˆ£ F^{ğ€} âŠ† U\}.

The set of :math:`n`-ary members of :math:`\mathrm{Clo} ğ€` is sometimes denoted by :math:`\mathrm{Clo}_n ğ€` (despite the fact that the latter is obviously not a clone).

We now state a theorem that shows how the clone of term operations of a signature can be defined inductively.

.. _thm-4-3:

.. proof:theorem::

   Let :math:`X` be a set and :math:`Ïƒ = (F, Ï)` a signature. Define

   .. math:: F_0 &= X;\\
         F_{n+1} &= F_n âˆª \{ f g âˆ£ f âˆˆ F, g : Ïf â†’ (F_n âˆ© (Ï g â†’ X)) \}, \quad n < Ï‰.

   Then :math:`\mathrm{Clo}^X(F) = â‹ƒ_n F_n`.

Thus *the clone of terms operations can be implemented (e.g., in Lean) as an inductive type*. The following theorem makes this precise. (See also :cite:`Bergman:2012`, Thm. 4.32.)

.. _thm-4-32:

.. proof:theorem::

   Let ğ€ and ğ be algebras of type :math:`Ï`.

   #. For every :math:`n`-ary term :math:`t âˆˆ T_Ï (X_Ï‰)` and homomorphism :math:`g : ğ€ â†’ ğ`,
      
      .. math:: g(t^{ğ€}(a_1,\dots, a_n)) = t^{ğ}(g(a_1),\dots, g(a_n)).

   #. For all :math:`t âˆˆ T_Ï (X_Ï‰)`, :math:`Î¸ âˆˆ \mathrm{Con} ğ€`, :math:`ğš : Ï t â†’ A` and :math:`ğ› : Ï t â†’ A`,
   
      .. math:: ğš \mathrel{Î¸} ğ› âŸ¹ t^{ğ€}(ğš) \mathrel{Î¸} t^{ğ€}(ğ›).

   #. For every subset :math:`Y âŠ† A`,

      .. math:: \mathrm{Sg}^{ğ€}(Y) = \{ t^{ğ€}(a_1, \dots, a_n) : t âˆˆ T(X_n), a_i âˆˆ Y, i â‰¤ n < Ï‰\}.

   .. container:: toggle
 
      .. container:: header
 
         *Proof*.
      
      The first statement is an easy induction on :math:`|t|`.

      The second statement follows from the first by taking :math:`ğ = ğ€/Î¸` and ğ—€ the canonical homomorphism.
  
      For the third statement, again by induction on the height of ğ—, every subalgebra must be closed under the action of :math:`t^{ğ€}`. 
  
      Thus the right-hand side is contained in the left. On the other hand, the right-hand side is clearly a subalgebra containing the elements of :math:`Y` (take :math:`t = x_1`) from which the reverse inclusion follows.

------------------------

.. rubric:: Footnotes

.. [1]
   The **height** of a type is simply type's *level* (see Section ???) and the syntax :math:`Type*` indicates that we do not wish to commit in advance to a specific height.

.. [2]
   The construction of :math:`ğ“_Ï (X)` may seem to be making something out of nothing, but it plays a crucial role in the theory.

.. _Lean: https://leanprover.github.io/

.. _`github.com/UniversalAlgebra/lean-ualib`: https://github.com/UniversalAlgebra/lean-ualib/

.. _lean-ualib: https://github.com/UniversalAlgebra/lean-ualib/